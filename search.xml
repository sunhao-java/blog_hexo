<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>CentOS安装FFmpeg</title>
      <link href="/2020/09/05/gong-ju/centos-an-zhuang-ffmpeg/"/>
      <url>/2020/09/05/gong-ju/centos-an-zhuang-ffmpeg/</url>
      
        <content type="html"><![CDATA[<h2 id="设置环境变量"><a href="#设置环境变量" class="headerlink" title="设置环境变量"></a>设置环境变量</h2><pre class=" language-shell"><code class="language-shell">export FFMPEG_PACKAGE=/home/tools/packagesexport FFMPEG_INSTALL=/home/tools/ffmpeg_installexport PATH=$PATH:$HOME/bin:$FFMPEG_INSTALL/bin</code></pre><a id="more"></a><h2 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h2><pre class=" language-shell"><code class="language-shell">yum install -y autoconf automake bzip2 bzip2-devel cmake freetype-devel gcc gcc-c++ git libtool make mercurial pkgconfig zlib-devel</code></pre><h2 id="libx264"><a href="#libx264" class="headerlink" title="libx264"></a>libx264</h2><pre class=" language-shell"><code class="language-shell">cd $FFMPEG_PACKAGEgit clone https://code.videolan.org/videolan/x264.gitcd x264PKG_CONFIG_PATH="$FFMPEG_INSTALL/ffmpeg_build/lib/pkgconfig" ./configure --prefix="$FFMPEG_INSTALL/ffmpeg_build" --bindir="$FFMPEG_INSTALL/bin" --enable-static --disable-asmmakemake install</code></pre><h2 id="FFmpeg"><a href="#FFmpeg" class="headerlink" title="FFmpeg"></a>FFmpeg</h2><pre class=" language-shell"><code class="language-shell">cd $FFMPEG_PACKAGEcurl -O -L http://ffmpeg.org/releases/ffmpeg-4.3.1.tar.gztar -zxvf ffmpeg-4.3.1.tar.gzcd ffmpeg-4.3.1PATH="$HOME/bin:$PATH" PKG_CONFIG_PATH="$FFMPEG_INSTALL/ffmpeg_build/lib/pkgconfig" ./configure \  --prefix="$FFMPEG_INSTALL/ffmpeg_build" \  --pkg-config-flags="--static" \  --extra-cflags="-I$FFMPEG_INSTALL/ffmpeg_build/include" \  --extra-ldflags="-L$FFMPEG_INSTALL/ffmpeg_build/lib" \  --extra-libs=-lpthread \  --extra-libs=-lm \  --bindir="$FFMPEG_INSTALL/bin" \  --enable-gpl \  --enable-libfreetype \  --enable-libx264 \  --enable-nonfree \  --disable-x86asmmakemake installhash -d ffmpeg  </code></pre><h2 id="准备字体文件"><a href="#准备字体文件" class="headerlink" title="准备字体文件"></a>准备字体文件</h2><pre class=" language-shell"><code class="language-shell"># 微软雅黑cp msyh.ttc /home/tools/</code></pre><h2 id="测试是否安装成功"><a href="#测试是否安装成功" class="headerlink" title="测试是否安装成功"></a>测试是否安装成功</h2><pre class=" language-shell"><code class="language-shell"># 测试：#   1. 获取视频文件信息 #   2. 添加文字、图片水印 #   3. 压缩前面加了水印的视频文件# 测试文件放在/homt/tools下，命名为1.mp4</code></pre><ol><li><p>获取视频文件信息</p><pre class=" language-shell"><code class="language-shell">[root@acr-2 tools]# ffprobe /home/tools/1.mp4ffprobe version 4.3.1 Copyright (c) 2007-2020 the FFmpeg developers  built with gcc 4.8.5 (GCC) 20150623 (Red Hat 4.8.5-39)  configuration: --prefix=/home/tools/ffmpeg_install/ffmpeg_build --pkg-config-flags=--static --extra-cflags=-I/home/tools/ffmpeg_install/ffmpeg_build/include --extra-ldflags=-L/home/tools/ffmpeg_install/ffmpeg_build/lib --extra-libs=-lpthread --extra-libs=-lm --bindir=/home/tools/ffmpeg_install/bin --enable-gpl --enable-libfreetype --enable-libx264 --enable-nonfree --disable-x86asm  libavutil      56. 51.100 / 56. 51.100  libavcodec     58. 91.100 / 58. 91.100  libavformat    58. 45.100 / 58. 45.100  libavdevice    58. 10.100 / 58. 10.100  libavfilter     7. 85.100 /  7. 85.100  libswscale      5.  7.100 /  5.  7.100  libswresample   3.  7.100 /  3.  7.100  libpostproc    55.  7.100 / 55.  7.100Input #0, mov,mp4,m4a,3gp,3g2,mj2, from '/home/tools/1.mp4':  Metadata:    major_brand     : mp42    minor_version   : 1    compatible_brands: mp41mp42isom    creation_time   : 2017-09-28T02:49:03.000000Z  Duration: 00:00:10.07, start: 0.000000, bitrate: 1185 kb/s    Stream #0:0(und): Video: h264 (High) (avc1 / 0x31637661), yuv420p, 540x960, 1124 kb/s, 29.80 fps, 30 tbr, 15360 tbn, 60 tbc (default)    Metadata:      creation_time   : 2017-09-28T02:49:03.000000Z      handler_name    : Core Media Video    Stream #0:1(und): Audio: aac (LC) (mp4a / 0x6134706D), 44100 Hz, stereo, fltp, 48 kb/s (default)    Metadata:      creation_time   : 2017-09-28T02:49:03.000000Z      handler_name    : Core Media Audio</code></pre></li><li><p>添加文字、图片水印</p><pre class=" language-shell"><code class="language-shell">[root@acr-2 tools]# ffmpeg -i /home/tools/1.mp4 -vcodec h264 -vf "[in]drawtext=x=(w-text_w)/2:y=(h-line_h)/2+14:text='ID\: 1234567890':fontfile=/home/tools/msyh.ttc:fontsize=15:fontcolor=white[text];movie=/home/tools/watermark.png[wm];[text][wm]overlay=(W-w)/2:(H-h)/2[out]" /home/tools/2.mp4# ...# ...# ...[libx264 @ 0x24e6940] consecutive B-frames: 17.5% 56.3%  8.9% 17.2%[libx264 @ 0x24e6940] mb I  I16..4: 13.8% 62.2% 24.0%[libx264 @ 0x24e6940] mb P  I16..4:  3.0%  7.4%  1.2%  P16..4: 55.5% 10.0%  4.0%  0.0%  0.0%    skip:18.9%[libx264 @ 0x24e6940] mb B  I16..4:  0.3%  0.5%  0.0%  B16..8: 34.7%  2.7%  0.5%  direct: 1.8%  skip:59.4%  L0:35.4% L1:55.3% BI: 9.3%[libx264 @ 0x24e6940] 8x8 transform intra:63.1% inter:55.8%[libx264 @ 0x24e6940] coded y,uvDC,uvAC intra: 45.5% 32.8% 3.8% inter: 15.5% 5.7% 0.2%[libx264 @ 0x24e6940] i16 v,h,dc,p: 19% 41% 15% 25%[libx264 @ 0x24e6940] i8 v,h,dc,ddl,ddr,vr,hd,vl,hu: 17% 24% 33%  3%  4%  4%  4%  4%  6%[libx264 @ 0x24e6940] i4 v,h,dc,ddl,ddr,vr,hd,vl,hu: 18% 26% 26%  5%  5%  5%  5%  5%  6%[libx264 @ 0x24e6940] i8c dc,h,v,p: 67% 18% 12%  2%[libx264 @ 0x24e6940] Weighted P-Frames: Y:10.1% UV:1.9%[libx264 @ 0x24e6940] ref P L0: 68.8% 19.3% 10.5%  1.3%  0.1%[libx264 @ 0x24e6940] ref B L0: 92.0%  7.7%  0.3%[libx264 @ 0x24e6940] ref B L1: 99.9%  0.1%[libx264 @ 0x24e6940] kb/s:1703.29[aac @ 0x24e5e00] Qavg: 1049.078# 出现以上信息并且在/home/tools目录下生成2.mp4文件就表示成功</code></pre></li><li><p>压缩前面加了水印的视频文件</p><pre class=" language-shell"><code class="language-shell">[root@acr-2 tools]# ffmpeg -i /home/tools/2.mp4 -vcodec h264 -vf "scale=iw*0.5:-1" -r 15  -ac 2 -ar 22050 -f mp4 -b:v 400k -y /home/tools/3.mp4# ...# ...# ...[libx264 @ 0x320a880] mb P  I16..4:  2.4%  7.0%  2.7%  P16..4: 32.1% 31.2% 19.1%  0.0%  0.0%    skip: 5.4%[libx264 @ 0x320a880] mb B  I16..4:  0.3%  0.4%  0.1%  B16..8: 43.4% 17.2%  4.8%  direct: 3.4%  skip:30.5%  L0:37.0% L1:46.9% BI:16.1%[libx264 @ 0x320a880] final ratefactor: 26.39[libx264 @ 0x320a880] 8x8 transform intra:53.9% inter:54.9%[libx264 @ 0x320a880] coded y,uvDC,uvAC intra: 58.2% 42.6% 8.4% inter: 32.0% 13.0% 0.8%[libx264 @ 0x320a880] i16 v,h,dc,p: 24% 33% 13% 29%[libx264 @ 0x320a880] i8 v,h,dc,ddl,ddr,vr,hd,vl,hu: 12% 17% 39%  4%  6%  5%  5%  5%  7%[libx264 @ 0x320a880] i4 v,h,dc,ddl,ddr,vr,hd,vl,hu: 14% 22% 25%  7%  6%  6%  6%  7%  7%[libx264 @ 0x320a880] i8c dc,h,v,p: 72% 15% 12%  2%[libx264 @ 0x320a880] Weighted P-Frames: Y:35.0% UV:8.8%[libx264 @ 0x320a880] ref P L0: 64.8% 26.5%  6.9%  1.5%  0.3%[libx264 @ 0x320a880] ref B L0: 96.8%  2.7%  0.5%[libx264 @ 0x320a880] ref B L1: 98.5%  1.5%[libx264 @ 0x320a880] kb/s:433.09[aac @ 0x31eb340] Qavg: 6954.015# 出现以上信息并且在/home/tools目录下生成3.mp4文件就表示成功</code></pre></li></ol><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li>官网：<a href="https://trac.ffmpeg.org/wiki/CompilationGuide/Centos" target="_blank" rel="noopener">https://trac.ffmpeg.org/wiki/CompilationGuide/Centos</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> FFmpeg </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java语法糖介绍</title>
      <link href="/2020/08/13/hou-duan/java-yu-fa-tang-jie-shao/"/>
      <url>/2020/08/13/hou-duan/java-yu-fa-tang-jie-shao/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><ol><li><p>什么是语法糖</p><blockquote><p>语法糖（Syntactic sugar），也译为糖衣语法，是由英国计算机科学家彼得·兰丁发明的一个术语，指计算机语言中添加的某种语法，这种语法对语言的功能没有影响，但是更方便程序员使用。</p></blockquote></li><li><p>能够带来的好处</p><blockquote><p>语法糖让程序更加简洁，有更高的可读性</p></blockquote></li><li><p>有哪些语法糖</p><ol><li>自动拆箱、装箱</li><li>泛型擦除</li><li>不定长参数</li><li>迭代器</li><li>枚举</li><li>switch支持枚举和字符串</li><li>内部类</li><li>try-with-resources</li><li>lambda</li></ol></li></ol><a id="more"></a><h1 id="自动拆箱、装箱"><a href="#自动拆箱、装箱" class="headerlink" title="自动拆箱、装箱"></a>自动拆箱、装箱</h1><ol><li>Java是面向对象编程（万物皆对象）</li><li>对象即需要new出来的，但是想想基本数据类型（int/double/boolean…）,并不需要去new</li><li>why?</li><li>为了方便去使用，Java对这些基本数据类型提供了装箱类型</li></ol><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Demo</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 自动装箱</span>        <span class="token comment" spellcheck="true">// 相当于代码：Integer i = Integer.valueOf(1);</span>        Integer i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 自动拆箱</span>        <span class="token comment" spellcheck="true">// 相当于代码：int j = i.intValue();</span>        <span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i <span class="token operator">+</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// # 编译</span><span class="token comment" spellcheck="true">// javac Demo.java</span><span class="token comment" spellcheck="true">// # 查看字节码</span><span class="token comment" spellcheck="true">// javap -c Demo</span>Compiled from <span class="token string">"Demo.java"</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Demo</span> <span class="token keyword">extends</span> <span class="token class-name">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>Object</span><span class="token punctuation">{</span><span class="token keyword">public</span> <span class="token function">Demo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  Code<span class="token operator">:</span>   <span class="token number">0</span><span class="token operator">:</span>   aload_0   <span class="token number">1</span><span class="token operator">:</span>   invokespecial   #<span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//Method java/lang/Object."&lt;init>":()V</span>   <span class="token number">4</span><span class="token operator">:</span>   <span class="token keyword">return</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  Code<span class="token operator">:</span>   <span class="token number">0</span><span class="token operator">:</span>   iconst_1   <span class="token number">1</span><span class="token operator">:</span>   invokestatic    #<span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;</span>   <span class="token number">4</span><span class="token operator">:</span>   astore_1   <span class="token number">5</span><span class="token operator">:</span>   aload_1   <span class="token number">6</span><span class="token operator">:</span>   invokevirtual   #<span class="token number">3</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//Method java/lang/Integer.intValue:()I</span>   <span class="token number">9</span><span class="token operator">:</span>   istore_2   <span class="token number">10</span><span class="token operator">:</span>  getstatic       #<span class="token number">4</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//Field java/lang/System.out:Ljava/io/PrintStream;</span>   <span class="token number">13</span><span class="token operator">:</span>  aload_1   <span class="token number">14</span><span class="token operator">:</span>  invokevirtual   #<span class="token number">3</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//Method java/lang/Integer.intValue:()I</span>   <span class="token number">17</span><span class="token operator">:</span>  iload_2   <span class="token number">18</span><span class="token operator">:</span>  iadd   <span class="token number">19</span><span class="token operator">:</span>  inv<span class="token comment" spellcheck="true">// okevirtual   #5; //Method java/io/PrintStream.println:(I)V</span>   <span class="token number">22</span><span class="token operator">:</span>  <span class="token keyword">return</span><span class="token punctuation">}</span></code></pre><ol start="5"><li>思考<ol><li>Integer的装箱类型能否用==比较？<ol><li>Integer类型的valueof方法，-128~127区间采用缓存，这部分值是可以用==比较的，区间外的是重新创建的对象，用==比较的只是引用</li></ol></li><li>==、equals的区别？</li><li>为何阿里规范中心POJO以及RPC的入参、返回值的类属性定义都要用用包装数据？<ol><li>有时候，接收到的值可能事null类型，如果用的是基本类型，则会在拆箱的过程中发生NPE</li></ol></li></ol></li></ol><h1 id="泛型擦除"><a href="#泛型擦除" class="headerlink" title="泛型擦除"></a>泛型擦除</h1><ol><li>Java的泛型，其实是 <code>伪泛型</code> ，泛型仅仅存在于编码期间，供编译器进行类型检测，编译后，会被擦除。</li><li>运行时，通过类型强制转换来实现的。</li><li>泛型是JDK1.5之后引入</li></ol><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// // 1. 源码</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>*<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Demo</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        List<span class="token operator">&lt;</span>String<span class="token operator">></span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 并不能编译通过</span>        <span class="token comment" spellcheck="true">// a.add(111);</span>        a<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"test"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        String temp <span class="token operator">=</span> a<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>temp<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token number">2</span><span class="token punctuation">.</span> 通过jd<span class="token operator">-</span>gui反编译后得到<span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>ArrayList<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Demo</span> <span class="token punctuation">{</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> paramArrayOfString<span class="token punctuation">)</span> <span class="token punctuation">{</span>    ArrayList arrayList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    arrayList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"test"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 通过类型强制转换来获取List中的对象，这里已经由编码期的泛型来保证了类型安全</span>    String str <span class="token operator">=</span> <span class="token punctuation">(</span>String<span class="token punctuation">)</span>arrayList<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 3. 如何证明泛型在编译时被擦除，运行时并不需要这个</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>*<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Demo</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        List<span class="token operator">&lt;</span>String<span class="token operator">></span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 并不能编译通过</span>        <span class="token comment" spellcheck="true">// a.addAll(b);</span>        Class <span class="token class-name">c1</span> <span class="token operator">=</span> a<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          Class <span class="token class-name">c2</span> <span class="token operator">=</span> b<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">// 打印:</span>        <span class="token comment" spellcheck="true">// class java.util.ArrayList</span>        <span class="token comment" spellcheck="true">// true</span>        <span class="token comment" spellcheck="true">// 运行时获取a和b的类型</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>c1<span class="token punctuation">)</span><span class="token punctuation">;</span>          System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>c1 <span class="token operator">==</span> c2<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h1 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h1><ol><li>枚举其实就是一个Java类，继承了 <code>java.lang.Enum</code> ，并且其本身是不允许被继承的</li><li>用 <code>enum</code> 修饰的</li></ol><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 枚举源码</span><span class="token keyword">public</span> <span class="token keyword">enum</span> Demo <span class="token punctuation">{</span>    ENUM_A<span class="token punctuation">,</span>    ENUM_B<span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 2. 编译后，用javap查看字节码文件</span><span class="token comment" spellcheck="true">// javac Demo.java</span><span class="token comment" spellcheck="true">// javap -c Demo</span>Compiled from <span class="token string">"Demo.java"</span><span class="token comment" spellcheck="true">// 此处可以看出来枚举类，其实就是一个普普通通的Java类</span><span class="token comment" spellcheck="true">// 首先，它是被final修饰的，所有不能被继承</span><span class="token comment" spellcheck="true">// 其次，默认继承了java.lang.Enum，并包含泛型，泛型类型为其本身</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Demo</span> <span class="token keyword">extends</span> <span class="token class-name">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>Enum</span><span class="token operator">&lt;</span>Demo<span class="token operator">></span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 有两个静态定义的枚举值</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Demo ENUM_A<span class="token punctuation">;</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Demo ENUM_B<span class="token punctuation">;</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> Demo<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">values</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Code<span class="token operator">:</span>       <span class="token number">0</span><span class="token operator">:</span> getstatic     #<span class="token number">1</span>                  <span class="token comment" spellcheck="true">// Field $VALUES:[LDemo;</span>       <span class="token number">3</span><span class="token operator">:</span> invokevirtual #<span class="token number">2</span>                  <span class="token comment" spellcheck="true">// Method "[LDemo;".clone:()Ljava/lang/Object;</span>       <span class="token number">6</span><span class="token operator">:</span> checkcast     #<span class="token number">3</span>                  <span class="token comment" spellcheck="true">// class "[LDemo;"</span>       <span class="token number">9</span><span class="token operator">:</span> areturn  <span class="token keyword">public</span> <span class="token keyword">static</span> Demo <span class="token function">valueOf</span><span class="token punctuation">(</span>java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>String<span class="token punctuation">)</span><span class="token punctuation">;</span>    Code<span class="token operator">:</span>       <span class="token number">0</span><span class="token operator">:</span> ldc           #<span class="token number">4</span>                  <span class="token comment" spellcheck="true">// class Demo</span>       <span class="token number">2</span><span class="token operator">:</span> aload_0       <span class="token number">3</span><span class="token operator">:</span> invokestatic  #<span class="token number">5</span>                  <span class="token comment" spellcheck="true">// Method java/lang/Enum.valueOf:(Ljava/lang/Class;Ljava/lang/String;)Ljava/lang/Enum;</span>       <span class="token number">6</span><span class="token operator">:</span> checkcast     #<span class="token number">4</span>                  <span class="token comment" spellcheck="true">// class Demo</span>       <span class="token number">9</span><span class="token operator">:</span> areturn  <span class="token keyword">static</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    Code<span class="token operator">:</span>       <span class="token comment" spellcheck="true">// new一个对象，类型事Demo</span>       <span class="token number">0</span><span class="token operator">:</span> <span class="token keyword">new</span>           #<span class="token number">4</span>                  <span class="token comment" spellcheck="true">// class Demo</span>       <span class="token number">3</span><span class="token operator">:</span> dup       <span class="token comment" spellcheck="true">// 将常量压入栈</span>       <span class="token number">4</span><span class="token operator">:</span> ldc           #<span class="token number">7</span>                  <span class="token comment" spellcheck="true">// String ENUM_A</span>       <span class="token comment" spellcheck="true">// 定义变量0</span>       <span class="token number">6</span><span class="token operator">:</span> iconst_0       <span class="token comment" spellcheck="true">// 调用构造器，注意入参是两个(上面入栈的两个)</span>       <span class="token number">7</span><span class="token operator">:</span> invokespecial #<span class="token number">8</span>                  <span class="token comment" spellcheck="true">// Method "&lt;init>":(Ljava/lang/String;I)V</span>      <span class="token comment" spellcheck="true">// 赋值</span>      <span class="token number">10</span><span class="token operator">:</span> putstatic     #<span class="token number">9</span>                  <span class="token comment" spellcheck="true">// Field ENUM_A:LDemo;</span>      <span class="token number">13</span><span class="token operator">:</span> <span class="token keyword">new</span>           #<span class="token number">4</span>                  <span class="token comment" spellcheck="true">// class Demo</span>      <span class="token number">16</span><span class="token operator">:</span> dup      <span class="token number">17</span><span class="token operator">:</span> ldc           #<span class="token number">10</span>                 <span class="token comment" spellcheck="true">// String ENUM_B</span>      <span class="token number">19</span><span class="token operator">:</span> iconst_1      <span class="token number">20</span><span class="token operator">:</span> invokespecial #<span class="token number">8</span>                  <span class="token comment" spellcheck="true">// Method "&lt;init>":(Ljava/lang/String;I)V</span>      <span class="token number">23</span><span class="token operator">:</span> putstatic     #<span class="token number">11</span>                 <span class="token comment" spellcheck="true">// Field ENUM_B:LDemo;</span>      <span class="token number">26</span><span class="token operator">:</span> iconst_2      <span class="token comment" spellcheck="true">// 创建数组，类型是o</span>      <span class="token number">27</span><span class="token operator">:</span> anewarray     #<span class="token number">4</span>                  <span class="token comment" spellcheck="true">// class Demo</span>      <span class="token comment" spellcheck="true">// 压栈</span>      <span class="token number">30</span><span class="token operator">:</span> dup      <span class="token comment" spellcheck="true">// 第0位</span>      <span class="token number">31</span><span class="token operator">:</span> iconst_0      <span class="token comment" spellcheck="true">// 取值</span>      <span class="token number">32</span><span class="token operator">:</span> getstatic     #<span class="token number">9</span>                  <span class="token comment" spellcheck="true">// Field ENUM_A:LDemo;</span>      <span class="token comment" spellcheck="true">// 存入对应的数组元素中</span>      <span class="token number">35</span><span class="token operator">:</span> aastore      <span class="token number">36</span><span class="token operator">:</span> dup      <span class="token number">37</span><span class="token operator">:</span> iconst_1      <span class="token number">38</span><span class="token operator">:</span> getstatic     #<span class="token number">11</span>                 <span class="token comment" spellcheck="true">// Field ENUM_B:LDemo;</span>      <span class="token number">41</span><span class="token operator">:</span> aastore      <span class="token number">42</span><span class="token operator">:</span> putstatic     #<span class="token number">1</span>                  <span class="token comment" spellcheck="true">// Field $VALUES:[LDemo;</span>      <span class="token number">45</span><span class="token operator">:</span> <span class="token keyword">return</span><span class="token punctuation">}</span></code></pre><h1 id="try-with-resources"><a href="#try-with-resources" class="headerlink" title="try-with-resources"></a>try-with-resources</h1><ol><li>以前在写访问数据库、流编程，通常需要将资源关闭</li><li>以前使用try-catch-finally的写法，在finally中将资源关闭</li><li>这时候就要注意很多细节上的问题<ol><li>资源是否打开，是否存在</li><li>关闭的过程中如何处理异常</li><li>finally中不能写return</li></ol></li><li>自从JDK7之后，支持 <code>try-with-resources</code> 的写法，下面简单介绍一下两种写法的区别：</li></ol><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 1. try-catch-finally写法：</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">copy</span><span class="token punctuation">(</span>String src<span class="token punctuation">)</span> <span class="token punctuation">{</span>    InputStream in <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>in<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>in <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                in<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 2. try-with-resources写法：</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">copy</span><span class="token punctuation">(</span>String src<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">try</span> <span class="token punctuation">(</span>InputStream in <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span>src<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>in<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><ol start="5"><li>很明显，第二种写法较第一种，清晰、明了。</li><li>下面进行源码分析：</li><li>查看JDK7版本中的 <code>FileInputStream</code> 源码</li></ol><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 1. FileInputStream源码</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FileInputStream</span> <span class="token keyword">extends</span> <span class="token class-name">InputStream</span> <span class="token punctuation">{</span>     <span class="token comment" spellcheck="true">// ...</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>closeLock<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>closed<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            closed <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>channel <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            channel<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        fd<span class="token punctuation">.</span><span class="token function">closeAll</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Closeable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>                <span class="token function">close0</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>   <span class="token comment" spellcheck="true">// 2. FileInputStream父类InputStream源码</span><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">InputStream</span> <span class="token keyword">implements</span> <span class="token class-name">Closeable</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// ...</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 3. InputStream实现的接口Closeable的源码</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Closeable</span> <span class="token keyword">extends</span> <span class="token class-name">AutoCloseable</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 4. AutoCloseable的源码</span><span class="token comment" spellcheck="true">/** * ... * @since 1.7 */</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">AutoCloseable</span> <span class="token punctuation">{</span>    <span class="token keyword">void</span> <span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><ol start="8"><li>可见最终是实现了一个JDK7才提供的接口 <code>AutoCloseable</code> </li><li>我们再去查看一下<code>try-with-resources</code> 写法的字节码文件</li></ol><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// javap -c Demo</span>Compiled from <span class="token string">"Demo.java"</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Demo</span> <span class="token punctuation">{</span>  <span class="token keyword">public</span> <span class="token function">Demo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Code<span class="token operator">:</span>       <span class="token number">0</span><span class="token operator">:</span> aload_0       <span class="token number">1</span><span class="token operator">:</span> invokespecial #<span class="token number">1</span>                  <span class="token comment" spellcheck="true">// Method java/lang/Object."&lt;init>":()V</span>       <span class="token number">4</span><span class="token operator">:</span> <span class="token keyword">return</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">copy</span><span class="token punctuation">(</span>java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>String<span class="token punctuation">)</span><span class="token punctuation">;</span>    Code<span class="token operator">:</span>       <span class="token number">0</span><span class="token operator">:</span> <span class="token keyword">new</span>           #<span class="token number">2</span>                  <span class="token comment" spellcheck="true">// class java/io/FileInputStream</span>       <span class="token number">3</span><span class="token operator">:</span> dup       <span class="token number">4</span><span class="token operator">:</span> aload_0       <span class="token number">5</span><span class="token operator">:</span> invokespecial #<span class="token number">3</span>                  <span class="token comment" spellcheck="true">// Method java/io/FileInputStream."&lt;init>":(Ljava/lang/String;)V</span>       <span class="token number">8</span><span class="token operator">:</span> astore_1       <span class="token number">9</span><span class="token operator">:</span> aconst_null      <span class="token number">10</span><span class="token operator">:</span> astore_2      <span class="token number">11</span><span class="token operator">:</span> getstatic     #<span class="token number">4</span>                  <span class="token comment" spellcheck="true">// Field java/lang/System.out:Ljava/io/PrintStream;</span>      <span class="token number">14</span><span class="token operator">:</span> aload_1      <span class="token number">15</span><span class="token operator">:</span> invokevirtual #<span class="token number">5</span>                  <span class="token comment" spellcheck="true">// Method java/io/PrintStream.println:(Ljava/lang/Object;)V</span>      <span class="token number">18</span><span class="token operator">:</span> aload_1      <span class="token number">19</span><span class="token operator">:</span> ifnull        <span class="token number">89</span>      <span class="token number">22</span><span class="token operator">:</span> aload_2      <span class="token number">23</span><span class="token operator">:</span> ifnull        <span class="token number">42</span>      <span class="token number">26</span><span class="token operator">:</span> aload_1      <span class="token number">27</span><span class="token operator">:</span> invokevirtual #<span class="token number">6</span>                  <span class="token comment" spellcheck="true">// Method java/io/InputStream.close:()V</span>      <span class="token number">30</span><span class="token operator">:</span> <span class="token keyword">goto</span>          <span class="token number">89</span>      <span class="token number">33</span><span class="token operator">:</span> astore_3      <span class="token number">34</span><span class="token operator">:</span> aload_2      <span class="token number">35</span><span class="token operator">:</span> aload_3      <span class="token number">36</span><span class="token operator">:</span> invokevirtual #<span class="token number">8</span>                  <span class="token comment" spellcheck="true">// Method java/lang/Throwable.addSuppressed:(Ljava/lang/Throwable;)V</span>      <span class="token number">39</span><span class="token operator">:</span> <span class="token keyword">goto</span>          <span class="token number">89</span>      <span class="token number">42</span><span class="token operator">:</span> aload_1      <span class="token number">43</span><span class="token operator">:</span> invokevirtual #<span class="token number">6</span>                  <span class="token comment" spellcheck="true">// Method java/io/InputStream.close:()V</span>      <span class="token number">46</span><span class="token operator">:</span> <span class="token keyword">goto</span>          <span class="token number">89</span>      <span class="token number">49</span><span class="token operator">:</span> astore_3      <span class="token number">50</span><span class="token operator">:</span> aload_3      <span class="token number">51</span><span class="token operator">:</span> astore_2      <span class="token number">52</span><span class="token operator">:</span> aload_3      <span class="token number">53</span><span class="token operator">:</span> athrow      <span class="token number">54</span><span class="token operator">:</span> astore        <span class="token number">4</span>      <span class="token number">56</span><span class="token operator">:</span> aload_1      <span class="token number">57</span><span class="token operator">:</span> ifnull        <span class="token number">86</span>      <span class="token number">60</span><span class="token operator">:</span> aload_2      <span class="token number">61</span><span class="token operator">:</span> ifnull        <span class="token number">82</span>      <span class="token number">64</span><span class="token operator">:</span> aload_1      <span class="token number">65</span><span class="token operator">:</span> invokevirtual #<span class="token number">6</span>                  <span class="token comment" spellcheck="true">// Method java/io/InputStream.close:()V</span>      <span class="token number">68</span><span class="token operator">:</span> <span class="token keyword">goto</span>          <span class="token number">86</span>      <span class="token number">71</span><span class="token operator">:</span> astore        <span class="token number">5</span>      <span class="token number">73</span><span class="token operator">:</span> aload_2      <span class="token number">74</span><span class="token operator">:</span> aload         <span class="token number">5</span>      <span class="token number">76</span><span class="token operator">:</span> invokevirtual #<span class="token number">8</span>                  <span class="token comment" spellcheck="true">// Method java/lang/Throwable.addSuppressed:(Ljava/lang/Throwable;)V</span>      <span class="token number">79</span><span class="token operator">:</span> <span class="token keyword">goto</span>          <span class="token number">86</span>      <span class="token number">82</span><span class="token operator">:</span> aload_1      <span class="token number">83</span><span class="token operator">:</span> invokevirtual #<span class="token number">6</span>                  <span class="token comment" spellcheck="true">// Method java/io/InputStream.close:()V</span>      <span class="token number">86</span><span class="token operator">:</span> aload         <span class="token number">4</span>      <span class="token number">88</span><span class="token operator">:</span> athrow      <span class="token number">89</span><span class="token operator">:</span> <span class="token keyword">goto</span>          <span class="token number">97</span>      <span class="token number">92</span><span class="token operator">:</span> astore_1      <span class="token number">93</span><span class="token operator">:</span> aload_1      <span class="token number">94</span><span class="token operator">:</span> invokevirtual #<span class="token number">10</span>                 <span class="token comment" spellcheck="true">// Method java/io/IOException.printStackTrace:()V</span>      <span class="token number">97</span><span class="token operator">:</span> <span class="token keyword">return</span>    Exception table<span class="token operator">:</span>       from    to  target type          <span class="token number">26</span>    <span class="token number">30</span>    <span class="token number">33</span>   Class <span class="token class-name">java</span><span class="token operator">/</span>lang<span class="token operator">/</span>Throwable          <span class="token number">11</span>    <span class="token number">18</span>    <span class="token number">49</span>   Class <span class="token class-name">java</span><span class="token operator">/</span>lang<span class="token operator">/</span>Throwable          <span class="token number">11</span>    <span class="token number">18</span>    <span class="token number">54</span>   any          <span class="token number">64</span>    <span class="token number">68</span>    <span class="token number">71</span>   Class <span class="token class-name">java</span><span class="token operator">/</span>lang<span class="token operator">/</span>Throwable          <span class="token number">49</span>    <span class="token number">56</span>    <span class="token number">54</span>   any           <span class="token number">0</span>    <span class="token number">89</span>    <span class="token number">92</span>   Class <span class="token class-name">java</span><span class="token operator">/</span>io<span class="token operator">/</span>IOException<span class="token punctuation">}</span></code></pre><ol start="10"><li><p>思考</p><ol><li>问题一<ol><li>在第一种方案中，如果try块中抛出了异常，该异常时可以被正常抛出记录的</li><li>如果在finally中产生异常，然后抛出，那该异常也可以被正常记录</li><li>如果try中先出现异常，finally中也会被正常执行，但是如果finally中也出现了异常并抛出，try中的异常还能被捕获么？</li></ol></li></ol></li><li><p>关于异常</p><ol><li>jdk7之前，如果不做任何处理，try中的异常就会被忽略掉，无法捕获</li><li>jdk7之后，引入了“可被抑制”的异常，finally中产生的异常，可以获取到try中的异常</li><li>jdk7之前，需要实现自己的异常类</li><li>jdk7之后，已经对Throwable类进行了修改以支持这种情况。在java7中为Throwable类增加addSuppressed方法。当一个异常被抛出的时候，可能有其他异常因为该异常而被抑制住，从而无法正常抛出。这时可以通过addSuppressed方法把这些被抑制的方法记录下来。被抑制的异常会出现在抛出的异常的堆栈信息中，也可以通过getSuppressed方法来获取这些异常。这样做的好处是不会丢失任何异常，方便开发人员进行调试。</li><li>可以查看一下上面例子反编译后的源码：</li></ol><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>*<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Demo</span> <span class="token punctuation">{</span>   <span class="token keyword">public</span> <span class="token function">Demo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token punctuation">}</span>   <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">copy</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span> <span class="token punctuation">{</span>       FileInputStream fileinputstream<span class="token punctuation">;</span>       Throwable throwable<span class="token punctuation">;</span>       fileinputstream <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>       throwable <span class="token operator">=</span> null<span class="token punctuation">;</span>       <span class="token keyword">try</span> <span class="token punctuation">{</span>           System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>fileinputstream<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token punctuation">}</span>       <span class="token keyword">catch</span><span class="token punctuation">(</span>Throwable throwable2<span class="token punctuation">)</span> <span class="token punctuation">{</span>           throwable <span class="token operator">=</span> throwable2<span class="token punctuation">;</span>           <span class="token keyword">throw</span> throwable2<span class="token punctuation">;</span>       <span class="token punctuation">}</span>       <span class="token keyword">if</span><span class="token punctuation">(</span>fileinputstream <span class="token operator">!=</span> null<span class="token punctuation">)</span>           <span class="token keyword">if</span><span class="token punctuation">(</span>throwable <span class="token operator">!=</span> null<span class="token punctuation">)</span>               <span class="token keyword">try</span> <span class="token punctuation">{</span>                   fileinputstream<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token punctuation">}</span> <span class="token keyword">catch</span><span class="token punctuation">(</span>Throwable throwable1<span class="token punctuation">)</span> <span class="token punctuation">{</span>                   <span class="token comment" spellcheck="true">// 这里就是将catch中的异常，放在可能阻断异常抛出的异常中，然后统一在后面抛出异常，这样throwable1就在throwable的异常栈中了</span>                   throwable<span class="token punctuation">.</span><span class="token function">addSuppressed</span><span class="token punctuation">(</span>throwable1<span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token punctuation">}</span>           <span class="token keyword">else</span>               fileinputstream<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// 这一块，源码是finally块，由于反编译工具的问题，导致看到break语句</span>       <span class="token comment" spellcheck="true">// 其实Java中的break也是支持跳出的指定label的</span>       <span class="token keyword">break</span> MISSING_BLOCK_LABEL_97<span class="token punctuation">;</span>       Exception exception<span class="token punctuation">;</span>       exception<span class="token punctuation">;</span>       <span class="token keyword">if</span><span class="token punctuation">(</span>fileinputstream <span class="token operator">!=</span> null<span class="token punctuation">)</span>           <span class="token keyword">if</span><span class="token punctuation">(</span>throwable <span class="token operator">!=</span> null<span class="token punctuation">)</span>               <span class="token keyword">try</span> <span class="token punctuation">{</span>                   fileinputstream<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token punctuation">}</span> <span class="token keyword">catch</span><span class="token punctuation">(</span>Throwable throwable3<span class="token punctuation">)</span> <span class="token punctuation">{</span>                   throwable<span class="token punctuation">.</span><span class="token function">addSuppressed</span><span class="token punctuation">(</span>throwable3<span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token punctuation">}</span>           <span class="token keyword">else</span>               fileinputstream<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token keyword">throw</span> exception<span class="token punctuation">;</span>       IOException ioexception<span class="token punctuation">;</span>       ioexception<span class="token punctuation">;</span>       ioexception<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 语法糖 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git同时push到多个远端仓库</title>
      <link href="/2020/07/23/gong-ju/git-tong-shi-push-dao-duo-ge-yuan-duan-cang-ku/"/>
      <url>/2020/07/23/gong-ju/git-tong-shi-push-dao-duo-ge-yuan-duan-cang-ku/</url>
      
        <content type="html"><![CDATA[<blockquote><p>当你的项目同时放在两个远程仓库(例如：一个开源中国，一个github)上时，需要分别push两次，进行以下修改，即可一次push，推送到两个远程库！</p></blockquote><a id="more"></a><h2 id="添加第二个远端地址"><a href="#添加第二个远端地址" class="headerlink" title="添加第二个远端地址"></a>添加第二个远端地址</h2><pre><code>git remote set-url --add origin git@gitee.com:xxx/xxx.git</code></pre><h2 id="有加，就有删"><a href="#有加，就有删" class="headerlink" title="有加，就有删"></a>有加，就有删</h2><pre><code>git remote set-url --delete origin git@gitee.com:xxx/xxx.git</code></pre><h2 id="查看远端分支"><a href="#查看远端分支" class="headerlink" title="查看远端分支"></a>查看远端分支</h2><pre><code>git remote -vorigin  git@github.com:xxx/xxx.git (fetch)origin  git@github.com:xxx/xxx.git (push)origin  git@gitee.com:xxx/xxx.git (push)</code></pre><h2 id="推送"><a href="#推送" class="headerlink" title="推送"></a>推送</h2><pre><code>git add .git commit -m &quot;commit message&quot;git push</code></pre>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flume消费Kafka中的消息存储到Hbase中</title>
      <link href="/2020/05/13/da-shu-ju/flume-xiao-fei-kafka-zhong-de-xiao-xi-cun-chu-dao-hbase-zhong/"/>
      <url>/2020/05/13/da-shu-ju/flume-xiao-fei-kafka-zhong-de-xiao-xi-cun-chu-dao-hbase-zhong/</url>
      
        <content type="html"><![CDATA[<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><ol><li>先安装《OpenResty记录日志输出到kafka.md》和《安装HBase.md》实际操作安装好以下中间件<ul><li>openResty[1.15.8.3]</li><li>kafka[2.5.0]</li><li>zookeeper[3.6.0]</li><li>hbase[0.94.27]</li></ul></li><li>特别注意Flume和Hbase的版本号可能会有兼容问题    </li></ol><a id="more"></a><h2 id="配置Hbase"><a href="#配置Hbase" class="headerlink" title="配置Hbase"></a>配置Hbase</h2><ol><li><p>配置hbase的环境变量，可以添加到.bash_profile中</p><pre class=" language-shell"><code class="language-shell"> export HBASE_HOME=/home/tools/hbase-0.94.27 export PATH=$HBASE_HOME/bin:$PATH</code></pre></li><li><p>进入hbase shell环境</p><pre><code> [root@docker-server tools]# hbase shell HBase Shell; enter &#39;help&lt;RETURN&gt;&#39; for list of supported commands. Type &quot;exit&lt;RETURN&gt;&quot; to leave the HBase Shell Version 0.94.27, rfb434617716493eac82b55180b0bbd653beb90bf, Thu Mar 19 06:17:55 UTC 2015 hbase(main):001:0&gt; create &#39;dcc&#39;, &#39;dcc-column&#39; 0 row(s) in 1.5810 seconds hbase(main):002:0&gt; </code></pre><p> 创建<code>dcc</code>这张表，其中列族为<code>dcc-column</code></p></li></ol><h2 id="安装、配置Flume"><a href="#安装、配置Flume" class="headerlink" title="安装、配置Flume"></a>安装、配置Flume</h2><h3 id="下载指定版本的Flume"><a href="#下载指定版本的Flume" class="headerlink" title="下载指定版本的Flume"></a>下载指定版本的Flume</h3><pre><code># 这里使用1.7.0版本，比较稳定，也使用的比较多wget http://archive.apache.org/dist/flume/1.7.0/apache-flume-1.7.0-bin.tar.gz</code></pre><h3 id="安装flume"><a href="#安装flume" class="headerlink" title="安装flume"></a>安装flume</h3><pre><code>tar -zxvf apache-flume-1.7.0-bin.tar.gz -C /home/tools/mv /home/tools/apache-flume-1.7.0-bin /home/tools/flume-1.7.0cd /home/tools/flume-1.7.0# 配置环境变量vim ~/.bash_profile## add envexport FLUME_CLASSPATH=/home/tools/flume-1.7.0/lib</code></pre><h3 id="配置flume"><a href="#配置flume" class="headerlink" title="配置flume"></a>配置flume</h3><pre><code># 创建配置文件vim /home/tools/flume-1.7.0/conf/flume-kafka-hbase.conf# 内容如下</code></pre><pre><code># flume-kafka-hbase.conf# 各组件命名  a1.sources = r1a1.sinks = k1a1.channels = c1# 指定数据源  a1.sources.r1.type = org.apache.flume.source.kafka.KafkaSource# kafka地址  a1.sources.r1.kafka.bootstrap.servers = 192.168.137.100:9092# 组ID  a1.sources.r1.kafka.consumer.group.id = flume-dcc-group# topic多个逗号隔开  a1.sources.r1.kafka.topics = dcc-topic# 指定hbase为数据存储  a1.sinks.k1.type = asynchbase# 表名  a1.sinks.k1.table = dcc# 列族名  a1.sinks.k1.columnFamily = dcc-columna1.sinks.k1.serializer = org.apache.flume.sink.hbase.SimpleAsyncHbaseEventSerializer# channel类型  a1.channels.c1.type = memory# channel存储的事件容量  a1.channels.c1.capacity = 1500000# 事务容量  a1.channels.c1.transactionCapacity = 10000# 绑定source和sink到channel  a1.sources.r1.channels = c1a1.sinks.k1.channel = c1</code></pre><h3 id="运行flume"><a href="#运行flume" class="headerlink" title="运行flume"></a>运行flume</h3><pre><code>/home/tools/flume-1.7.0/bin/flume-ng agent --conf /home/tools/flume-1.7.0/conf/ -f /home/tools/flume-1.7.0/conf/flume-kafka-hbase.conf -n a1 -Dflume.root.logger=INFO,console</code></pre><h3 id="F-amp-Q"><a href="#F-amp-Q" class="headerlink" title="F&amp;Q"></a>F&amp;Q</h3><p>如果出现ClassNotFoundException，请检查是否配置了Flume的环境变量，或者各组件的版本是否兼容</p><h2 id="查看效果"><a href="#查看效果" class="headerlink" title="查看效果"></a>查看效果</h2><ol><li><p>刷新在文章《OpenResty记录日志输出到kafka.md》中创建的html页面</p></li><li><p>埋点的日志将会被Nginx中的lua推送到kafka中</p></li><li><p>而Flume订阅了kafka中的<code>dcc-topic</code>，其将会把消费到的消息原封不动的推送到Hbase中存储</p></li><li><p>进入Hbase的shell界面，可以看到数据确实存储下来了：</p><pre><code> [root@docker-server conf]# hbase shell HBase Shell; enter &#39;help&lt;RETURN&gt;&#39; for list of supported commands. Type &quot;exit&lt;RETURN&gt;&quot; to leave the HBase Shell Version 0.94.27, rfb434617716493eac82b55180b0bbd653beb90bf, Thu Mar 19 06:17:55 UTC 2015 hbase(main):001:0&gt; scan &#39;dcc&#39; ROW                                                                                COLUMN+CELL                                                                                                                                                                                                                                       defaultc37a20c9-5a08-41b7-9999-6b25eb7daa92                                       column=dcc-column:pCol, timestamp=1589355681397, value={&quot;host&quot;:&quot;dcc.yeahzee.com&quot;,&quot;time_local&quot;:&quot;13\x5C/May\x5C/2020:15:41:19 +0800&quot;,&quot;http_referer&quot;:&quot;http:\x5C/\x5C/www.yeahzee.com\x5C/&quot;,&quot;status&quot;:&quot;304&quot;,&quot;remote_addr&quot;:&quot;192.168.137.1&quot;,&quot;request_tim                                                                                 e&quot;:&quot;0.000&quot;,&quot;uri&quot;:&quot;\x5C/dcc.gif&quot;,&quot;args&quot;:&quot;domain=www.yeahzee.com&amp;url=http%3A%2F%2Fwww.yeahzee.com%2F&amp;title=Welcome%20to%20OpenResty!&amp;referrer=&amp;sh=1080&amp;sw=1920&amp;cd=24&amp;lang=zh-CN&amp;_setAccount=%E7%BC%83%E6%88%A0%E7%8F%AF%E9%8F%8D%E5%9B%AA%E7%98%91&quot;                                                                                 ,&quot;http_user_agent&quot;:&quot;Mozilla\x5C/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit\x5C/537.36 (KHTML, like Gecko) Chrome\x5C/81.0.4044.138 Safari\x5C/537.36&quot;,&quot;body_bytes_sent&quot;:&quot;0&quot;}                                                                   incRow                                                                            column=dcc-column:iCol, timestamp=1589355681398, value=\x00\x00\x00\x00\x00\x00\x00\x03                                                                                                                                                           2 row(s) in 0.4480 seconds hbase(main):002:0&gt;     </code></pre></li></ol><h2 id="PS"><a href="#PS" class="headerlink" title="PS"></a>PS</h2><ol><li>查看Hbase中的数据可以下载<a href="https://github.com/bit-ware/HBaseXplorer" target="_blank" rel="noopener" title="工具">工具</a></li><li>下载完成后按照操作系统选择对应的启动脚本双击，在打开的窗口填入Hbase连接的zookeeper地址，点击确定即可</li><li>效果<br><img src="/imgs/big_data/1.png" alt="效果图"></li></ol>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flume </tag>
            
            <tag> kafka </tag>
            
            <tag> hbase </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kafka常用命令</title>
      <link href="/2020/05/13/da-shu-ju/kafka-chang-yong-ming-ling/"/>
      <url>/2020/05/13/da-shu-ju/kafka-chang-yong-ming-ling/</url>
      
        <content type="html"><![CDATA[<ol><li><p>查看kafka topic列表，使用–list参数</p><pre><code> ./kafka-topics.sh --zookeeper 192.168.137.100:2181 --list</code></pre></li><li><p>查看kafka特定topic的详情，使用–topic与–describe参数</p><pre><code> ./kafka-topics.sh --zookeeper 192.168.137.100:2181 --topic dcc-topic --describe</code></pre></li><li><p>查看consumer group列表，使用–list参数</p><pre><code> ./kafka-consumer-groups.sh --bootstrap-server 192.168.137.100:9292 --list</code></pre></li><li><p>查看特定consumer group 详情，使用–group与–describe参数</p><pre><code> ./kafka-consumer-groups.sh --bootstrap-server 192.168.137.100:9092 --group flume_test --describe</code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kafka </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安装HBase</title>
      <link href="/2020/05/13/da-shu-ju/an-zhuang-hbase/"/>
      <url>/2020/05/13/da-shu-ju/an-zhuang-hbase/</url>
      
        <content type="html"><![CDATA[<h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><ol><li>地址：<a href="https://mirror-hk.koddos.net/apache/hbase/${hbase_version}/hbase-${hbase_version}-bin.tar.gz" target="_blank" rel="noopener">https://mirror-hk.koddos.net/apache/hbase/${hbase_version}/hbase-${hbase_version}-bin.tar.gz</a></li><li>${hbase_version}替换成具体的版本</li><li>tar -zxvf hbase-${hbase_version}-bin.tar.gz</li><li>cd hbase-${hbase_version}-bin/bin</li><li>./start-hbase.sh</li></ol><a id="more"></a><h2 id="HBase和Java的版本兼容性"><a href="#HBase和Java的版本兼容性" class="headerlink" title="HBase和Java的版本兼容性"></a>HBase和Java的版本兼容性</h2><table><thead><tr><th>Hbase版本</th><th>JDK6</th><th>JDK7</th><th>JDK8</th></tr></thead><tbody><tr><td>1.2</td><td>Not Supported</td><td>yes</td><td>yes</td></tr><tr><td>1.1</td><td>Not Supported</td><td>yes</td><td>Not Supported</td></tr><tr><td>1</td><td>Not Supported</td><td>yes</td><td>Not Supported</td></tr><tr><td>0.98</td><td>yes</td><td>yes</td><td>Not Supported</td></tr><tr><td>0.94</td><td>yes</td><td>yes</td><td>N/A</td></tr></tbody></table><h2 id="单机部署"><a href="#单机部署" class="headerlink" title="单机部署"></a>单机部署</h2><h3 id="HBase配置"><a href="#HBase配置" class="headerlink" title="HBase配置"></a>HBase配置</h3><ol><li><p>修改<code>conf/hbase-env.sh</code>文件</p><pre><code> # 配置JDK路径 export JAVA_HOME=/opt/jdk1.8.0_191 # true: 使用自带的zk来维护hbase集群 # false: 使用外部zk来维护hbase集群 export HBASE_MANAGES_ZK=false</code></pre></li><li><p>配置<code>config/hbase-site.xml</code>文件</p><pre><code> &lt;configuration&gt;   &lt;!-- hbase存放数据目录 --&gt;   &lt;property&gt;     &lt;name&gt;hbase.rootdir&lt;/name&gt;     &lt;value&gt;file:///home/tools/hbase-2.2.4/data&lt;/value&gt;   &lt;/property&gt;   &lt;!-- ZooKeeper配置开始：以下二选一 --&gt;   &lt;!-- 方式1. 内部zk的方式 --&gt;   &lt;property&gt;     &lt;name&gt;hbase.zookeeper.property.dataDir&lt;/name&gt;     &lt;!-- zk存储路径 --&gt;     &lt;value&gt;/data/soft/hbase-2.2.1/zookeeper&lt;/value&gt;   &lt;/property&gt;   &lt;!-- 方式2. 外部zk的方式 --&gt;   &lt;property&gt;     &lt;name&gt;hbase.zookeeper.quorum&lt;/name&gt;     &lt;!-- zk服务ip:port --&gt;     &lt;value&gt;192.168.137.100:2181&lt;/value&gt;   &lt;/property&gt;   &lt;!-- ZooKeeper配置结束 --&gt;   &lt;!-- 集群模式 --&gt;   &lt;property&gt;     &lt;name&gt;hbase.cluster.distributed&lt;/name&gt;     &lt;value&gt;true&lt;/value&gt;   &lt;/property&gt;   &lt;property&gt;     &lt;name&gt;hbase.unsafe.stream.capability.enforce&lt;/name&gt;     &lt;value&gt;false&lt;/value&gt;     &lt;description&gt;       Controls whether HBase will check for stream capabilities (hflush/hsync).       Disable this if you intend to run on LocalFileSystem, denoted by a rootdir       with the &#39;file://&#39; scheme, but be mindful of the NOTE below.       WARNING: Setting this to false blinds you to potential data loss and       inconsistent system state in the event of process and/or node failures. If       HBase is complaining of an inability to use hsync or hflush it&#39;s most       likely not a false positive.     &lt;/description&gt;   &lt;/property&gt; &lt;/configuration&gt;</code></pre></li></ol><h2 id="集群部署【待处理】"><a href="#集群部署【待处理】" class="headerlink" title="集群部署【待处理】"></a>集群部署【待处理】</h2><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><pre><code>cd $HBASE_HOME/bin</code></pre><ol><li><p>启动</p><pre><code> ./start-hbase.sh</code></pre></li><li><p>检查服务是否启动</p><pre><code> [root@docker-server conf]# jps 126934 HMaster 127768 Jps 127007 HRegionServer</code></pre></li><li><p>停止</p><pre><code> ./stop-hbase.sh</code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HBase </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenResty记录日志输出到kafka</title>
      <link href="/2020/05/11/da-shu-ju/openresty-ji-lu-ri-zhi-shu-chu-dao-kafka/"/>
      <url>/2020/05/11/da-shu-ju/openresty-ji-lu-ri-zhi-shu-chu-dao-kafka/</url>
      
        <content type="html"><![CDATA[<h2 id="安装zookeeper（基于docker安装）"><a href="#安装zookeeper（基于docker安装）" class="headerlink" title="安装zookeeper（基于docker安装）"></a>安装zookeeper（基于docker安装）</h2><ol><li>docker-compose.yml</li></ol><pre><code>version: &#39;3.1&#39;services:  zookeeper:    image: zookeeper    container_name: zookeeper    restart: always    network_mode: &quot;bridge&quot;    ports:      - &quot;2181:2181&quot;    volumes:      - /home/docker_volume/zookeeper/zoo.cfg:/conf/zoo.cfg      - /home/docker_volume/zookeeper/data/:/data/      - /home/docker_volume/zookeeper/logs/:/datalog/</code></pre><ol start="2"><li><code>docker-compose up -d</code><a id="more"></a></li></ol><h2 id="安装kafka-基于docker安装"><a href="#安装kafka-基于docker安装" class="headerlink" title="安装kafka(基于docker安装)"></a>安装kafka(基于docker安装)</h2><ol><li>docker-compose.yml</li></ol><pre><code>version: &#39;3.1&#39;services:  kafka:    image: wurstmeister/kafka    container_name: kafka    restart: always    network_mode: &quot;bridge&quot;    ports:      - &quot;9092:9092&quot;    environment:      KAFKA_BROKER_ID: 0      # 宿主机ip      KAFKA_ZOOKEEPER_CONNECT: 192.168.137.100:2181      # 宿主机ip      KAFKA_ADVERTISED_LISTENERS: PLAINTEXT://192.168.137.100:9092      KAFKA_LISTENERS: PLAINTEXT://0.0.0.0:9092</code></pre><ol start="2"><li><code>docker-compose up -d</code></li></ol><h2 id="安装OpenResty"><a href="#安装OpenResty" class="headerlink" title="安装OpenResty"></a>安装OpenResty</h2><ol><li>见<code>安装OpenResty.md</code></li></ol><h2 id="安装lua-resty-kafka"><a href="#安装lua-resty-kafka" class="headerlink" title="安装lua-resty-kafka"></a>安装<code>lua-resty-kafka</code></h2><ol><li>下载<code>lua-resty-kafka</code></li></ol><pre><code>wget https://github.com/doujiang24/lua-resty-kafka/archive/master.zipunzip lua-resty-kafka-master.zip -d /home/software/</code></pre><ol start="2"><li>拷贝<code>lua-resty-kafka</code>到<code>openresty</code></li></ol><pre><code>mkdir /home/tools/openresty/lualib/kafkacp -rf /home/software/lua-resty-kafka-master/lib/resty /home/tools/openresty/lualib/kafka/</code></pre><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><ol><li>nginx.conf</li></ol><pre><code>worker_processes  1;events {    worker_connections  1024;}http {    include       mime.types;    default_type  application/octet-stream;    sendfile        on;    keepalive_timeout  65;    #gzip  on;    # 配置lua依赖库地址    lua_package_path &quot;/home/tools/openresty/lualib/kafka/?.lua;;&quot;;    server {        listen       80;        server_name  localhost;        location / {            root   html;            index  index.html index.htm;        }        error_page   500 502 503 504  /50x.html;        location = /50x.html {            root   html;        }    }    include conf.d/*.conf;}</code></pre><ol start="2"><li><code>dcc.conf</code></li></ol><pre><code>server {    listen       80;    server_name  dcc.lodsve.com;    location /dcc.gif {        #伪装成gif文件        default_type image/gif;        #本身关闭access_log，通过subrequest记录log        access_log off;        log_by_lua &#39;            -- 引入lua所有api            local cjson = require &quot;cjson&quot;            local producer = require &quot;resty.kafka.producer&quot;            -- 定义kafka broker地址，ip需要和kafka的host.name配置一致            local broker_list = {                { host = &quot;192.168.137.100&quot;, port = 9092 },            }            -- 定义json便于日志数据整理收集            local log_json = {}            log_json[&quot;uri&quot;]=ngx.var.uri            log_json[&quot;args&quot;]=ngx.var.args            log_json[&quot;host&quot;]=ngx.var.host            log_json[&quot;request_body&quot;]=ngx.var.request_body            log_json[&quot;remote_addr&quot;] = ngx.var.remote_addr            log_json[&quot;remote_user&quot;] = ngx.var.remote_user            log_json[&quot;time_local&quot;] = ngx.var.time_local            log_json[&quot;status&quot;] = ngx.var.status            log_json[&quot;body_bytes_sent&quot;] = ngx.var.body_bytes_sent            log_json[&quot;http_referer&quot;] = ngx.var.http_referer            log_json[&quot;http_user_agent&quot;] = ngx.var.http_user_agent            log_json[&quot;http_x_forwarded_for&quot;] = ngx.var.http_x_forwarded_for            log_json[&quot;upstream_response_time&quot;] = ngx.var.upstream_response_time            log_json[&quot;request_time&quot;] = ngx.var.request_time            -- 转换json为字符串            local message = cjson.encode(log_json);            -- 定义kafka异步生产者            local bp = producer:new(broker_list, { producer_type = &quot;async&quot; })            -- 发送日志消息,send第二个参数key,用于kafka路由控制:            -- key为nill(空)时，一段时间向同一partition写入数据            -- 指定key，按照key的hash写入到对应的partition            local ok, err = bp:send(&quot;dcc-topic&quot;, nil, message)            if not ok then                ngx.log(ngx.ERR, &quot;kafka send err:&quot;, err)                return            end        &#39;;        #此请求不缓存        add_header Expires &quot;Fri, 01 Jan 1980 00:00:00 GMT&quot;;        add_header Pragma &quot;no-cache&quot;;        add_header Cache-Control &quot;no-cache, max-age=0, must-revalidate&quot;;        #返回一个1×1的空gif图片        empty_gif;    }}server {    listen       80;    server_name  www.lodsve.com;    location / {        root   /home/tools/openresty/nginx/html/www;        index  index.html index.htm;    }}</code></pre><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ol><li><p>使用<code>docker-compose</code>依次启动<code>zookeeper</code>、<code>kafka</code></p></li><li><p>创建<code>/home/tools/openresty/nginx/html/www/dcc.js</code>文件，模拟埋点采集中心提供出去的前端SDK包</p><pre><code> (function () {     var params = {};     //Document对象数据     if(document) {         params.domain = document.domain || &#39;&#39;;         params.url = document.URL || &#39;&#39;;         params.title = document.title || &#39;&#39;;         params.referrer = document.referrer || &#39;&#39;;     }     //Window对象数据     if(window &amp;&amp; window.screen) {         params.sh = window.screen.height || 0;         params.sw = window.screen.width || 0;         params.cd = window.screen.colorDepth || 0;     }     //navigator对象数据     if(navigator) {         params.lang = navigator.language || &#39;&#39;;     }     //解析_maq配置     if(_data) {         for(var i in _data) {             params[_data[i][0]] = _data[i][1];         }     }     //拼接参数串     var args = &#39;&#39;;     for(var i in params) {         if(args != &#39;&#39;) {             args += &#39;&amp;&#39;;         }         args += i + &#39;=&#39; + encodeURIComponent(params[i]);     }     //通过Image对象请求后端脚本     var img = new Image(1, 1);     img.src = &#39;http://dcc.lodsve.com/dcc.gif?&#39; + args; })();</code></pre></li><li><p>创建<code>/home/tools/openresty/nginx/html/www/index.html</code>文件，模拟业务系统</p><pre><code> &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Welcome to OpenResty!&lt;/title&gt; &lt;style&gt;     body {         width: 35em;         margin: 0 auto;         font-family: Tahoma, Verdana, Arial, sans-serif;     } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Welcome to OpenResty!&lt;/h1&gt; &lt;p&gt;If you see this page, the OpenResty web platform is successfully installed and working. Further configuration is required.&lt;/p&gt; &lt;p&gt;For online documentation and support please refer to &lt;a href=&quot;https://openresty.org/&quot;&gt;openresty.org&lt;/a&gt;.&lt;br/&gt; Commercial support is available at &lt;a href=&quot;https://openresty.com/&quot;&gt;openresty.com&lt;/a&gt;.&lt;/p&gt; &lt;p&gt;&lt;em&gt;Thank you for flying OpenResty.&lt;/em&gt;&lt;/p&gt; &lt;script type=&quot;text/javascript&quot;&gt;     var _data = _data || [];     _data.push([&#39;_setAccount&#39;, &#39;网站标识&#39;]);     (function() {         var dcc = document.createElement(&#39;script&#39;);          dcc.type = &#39;text/javascript&#39;;         dcc.async = true;         dcc.src = &#39;http://www.lodsve.com/dcc.js&#39;;         var s = document.getElementsByTagName(&#39;script&#39;)[0];          s.parentNode.insertBefore(dcc, s);     })(); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt;</code></pre></li><li><p>启动<code>nginx</code>: <code>/home/tools/openresty/nginx/sbin/nginx</code>    </p></li><li><p>进入kafka容器，打开kafka，创建topi，并且监听这个topic</p><pre><code> 1. 进入容器     docker exec -it kafka bash 2. 创建topic     cd /opt/kafka/bin     sh kafka-topics.sh --zookeeper localhost:2181 --create --topic dcc-topic --partitions 1 --replication-factor 1 3. 新打开一个窗口，进入kafka容器同样的目录，监听这个topic     sh kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic dcc-topic --from-beginning 4. 在之前的窗口，kafka容器中测试发送监听消息     sh kafka-console-producer.sh --broker-list localhost:9092 --topic dcc-topic 5. 然后输入内容回车，即可在另一个监听窗口看到 6. 不要关闭该窗口</code></pre></li><li><p>客户机上配置host</p><pre><code> 192.168.137.100   dcc.lodsve.com 192.168.137.100   www.lodsve.com</code></pre></li><li><p>访问<code>http://www.lodsve.com</code>，即可在kafka的topic监听窗口看到如下效果了：</p><pre><code> {&quot;host&quot;:&quot;dcc.lodsve.com&quot;,&quot;time_local&quot;:&quot;11\/May\/2020:10:28:57 +0800&quot;,&quot;http_referer&quot;:&quot;http:\/\/www.lodsve.com\/&quot;,&quot;status&quot;:&quot;200&quot;,&quot;remote_addr&quot;:&quot;192.168.137.1&quot;,&quot;request_time&quot;:&quot;0.000&quot;,&quot;uri&quot;:&quot;\/dcc.gif&quot;,&quot;args&quot;:&quot;domain=www.lodsve.com&amp;url=http%3A%2F%2Fwww.lodsve.com%2F&amp;title=Welcome%20to%20OpenResty!&amp;referrer=&amp;sh=1080&amp;sw=1920&amp;cd=24&amp;lang=zh-CN&amp;_setAccount=%E7%BD%91%E7%AB%99%E6%A0%87%E8%AF%86&quot;,&quot;http_user_agent&quot;:&quot;Mozilla\/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit\/537.36 (KHTML, like Gecko) Chrome\/81.0.4044.138 Safari\/537.36&quot;,&quot;body_bytes_sent&quot;:&quot;43&quot;} {&quot;host&quot;:&quot;dcc.lodsve.com&quot;,&quot;time_local&quot;:&quot;11\/May\/2020:11:00:38 +0800&quot;,&quot;http_referer&quot;:&quot;http:\/\/www.lodsve.com\/&quot;,&quot;status&quot;:&quot;304&quot;,&quot;remote_addr&quot;:&quot;192.168.137.1&quot;,&quot;request_time&quot;:&quot;0.000&quot;,&quot;uri&quot;:&quot;\/dcc.gif&quot;,&quot;args&quot;:&quot;domain=www.lodsve.com&amp;url=http%3A%2F%2Fwww.lodsve.com%2F&amp;title=Welcome%20to%20OpenResty!&amp;referrer=&amp;sh=1080&amp;sw=1920&amp;cd=24&amp;lang=zh-CN&amp;_setAccount=%E7%BD%91%E7%AB%99%E6%A0%87%E8%AF%86&quot;,&quot;http_user_agent&quot;:&quot;Mozilla\/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit\/537.36 (KHTML, like Gecko) Chrome\/81.0.4044.138 Safari\/537.36&quot;,&quot;body_bytes_sent&quot;:&quot;0&quot;}</code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kafka </tag>
            
            <tag> OpenResty </tag>
            
            <tag> 埋点采集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安装OpenResty</title>
      <link href="/2020/05/11/da-shu-ju/an-zhuang-openresty/"/>
      <url>/2020/05/11/da-shu-ju/an-zhuang-openresty/</url>
      
        <content type="html"><![CDATA[<h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><ol><li>打开url：<a href="https://openresty.org/cn/download.html" target="_blank" rel="noopener">https://openresty.org/cn/download.html</a></li><li>找到最新版本或者合适的版本<pre><code>curl https://openresty.org/download/openresty-${version}.tar.gztar -zxvf openresty-${version}.tar.gzcd openresty-${version}</code></pre><a id="more"></a></li></ol><h2 id="编译、安装"><a href="#编译、安装" class="headerlink" title="编译、安装"></a>编译、安装</h2><ol><li>安装前的准备：安装基础库<pre><code>yum install -y pcre-devel openssl-devel gcc curl</code></pre></li><li><code>./configure</code><pre><code># prefix: 指定安装路径./configure --prefix=/opt/openresty \ # lua环境 --with-luajit \ --with-http_iconv_module \ --with-http_postgres_module</code></pre></li><li>安装<pre><code>make &amp;&amp; make install</code></pre></li></ol><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ol><li>启动nginx<pre><code>cd openresty-${version}/nginx/sbin./nginx</code></pre></li><li>重新加载nginx配置<pre><code>./nginx -s reload</code></pre></li><li>停止nginx<pre><code>./nginx -s stop</code></pre></li><li>重启nginx<pre><code>./nginx -s restart</code></pre></li></ol><h2 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h2><ol><li>执行<code>./configure</code>时，可能会出现以下错误<ul><li>错误: <code>./configure: error: ngx_postgres addon was unable to detect version of the libpq library.</code></li><li>解决: <code>yum install -y postgresql-devel</code></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenResty </tag>
            
            <tag> 埋点采集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>跟我一起系列之读Spring注解源码</title>
      <link href="/2020/03/25/hou-duan/gen-wo-yi-qi-xi-lie-zhi-du-spring-zhu-jie-yuan-ma/"/>
      <url>/2020/03/25/hou-duan/gen-wo-yi-qi-xi-lie-zhi-du-spring-zhu-jie-yuan-ma/</url>
      
        <content type="html"><![CDATA[<blockquote><p>读源码系列之Spring注解</p></blockquote><a id="more"></a><h1 id="注解的前世今生"><a href="#注解的前世今生" class="headerlink" title="注解的前世今生"></a>注解的前世今生</h1><ol><li><p>注解在JDK1.5才被发明</p></li><li><p>什么是注解</p><pre><code> 用一个词就可以描述注解，那就是元数据，即一种描述数据的数据。所以，可以说注解就是源代码的元数据。比如，下面这段代码： // 这里注解就是标注此方法是一个重写方法 // 如果父类不存在，或者子类方法名写错了、入参写错了，编译器就会报错 // 否则，就算没有这个注解，编译、运行都是正常的 @Override public String toString() {     return &quot;This is String Representation of current object.&quot;; }</code></pre></li><li><p>为何会存在<code>java.io.Serializable</code>这个空接口？—Java中的语法糖</p></li><li><p>如何定义一个接口</p><ul><li>修饰词：<code>@interface</code></li><li>@Retention(生命周期)<ul><li><code>SOURCE</code>：只保留在源码中，编译时会被擦除（Override）</li><li><code>CLASS</code>：注解将会保留到class文件阶段，但是在加载到JVM时会被抛弃</li><li><code>RUNTIME</code>：注解一直会被保存到运行时</li></ul></li><li>@Target(作用域): TYPE/FIELD/METHOD …</li><li>@Inherited: 注解是否可以被继承（下面介绍）</li></ul></li></ol><h1 id="Java中的语法糖"><a href="#Java中的语法糖" class="headerlink" title="Java中的语法糖"></a>Java中的语法糖</h1><ul><li>字符串拼接</li><li>条件编译</li><li>断言</li><li>枚举与Switch语句</li><li>字符串与Switch语句</li><li>可变参数</li><li>自动装箱/拆箱</li><li>枚举</li><li>内部类</li><li>泛型擦除</li><li>增强for循环</li><li>lambda表达式</li><li>try-with-resources语句</li><li>JDK10的局部变量类型推断</li></ul><h1 id="Spring-Boot中的注解"><a href="#Spring-Boot中的注解" class="headerlink" title="Spring-Boot中的注解"></a>Spring-Boot中的注解</h1><h2 id="EnableXXX的实现原理"><a href="#EnableXXX的实现原理" class="headerlink" title="EnableXXX的实现原理"></a>EnableXXX的实现原理</h2><p>首先我们使用<code>@EnableSwagger2</code>举例。我们在使用swagger的时候，只需要在启动类或者一些JavaConfig的配置文件上加上这个注解，就可以使用swagger了。思考一下，这是如何实现的。</p><ol><li>看<code>@EnableSwagger2</code>的源码<pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span>value <span class="token operator">=</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>RetentionPolicy<span class="token punctuation">.</span>RUNTIME<span class="token punctuation">)</span><span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token punctuation">{</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>ElementType<span class="token punctuation">.</span>TYPE <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token annotation punctuation">@Documented</span><span class="token annotation punctuation">@Import</span><span class="token punctuation">(</span><span class="token punctuation">{</span>Swagger2DocumentationConfiguration<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">EnableSwagger2</span> <span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre>有没有发现不太一样的地方？</li><li>在这个注解上面还有一个注解，叫<code>@Import</code>，这个注解时spring在JavaConfig方式配置时，提供的一个注解，可以引入外部配置<br> 看代码<code>org.springframework.context.annotation.ConfigurationClassParser#doProcessConfigurationClass#Line303</code></li><li>通过上面的处理，spring容器就可以拿到swagger的配置<code>Swagger2DocumentationConfiguration</code>，加载到上下文中</li><li>此时就可以正常使用了</li><li>综上，<code>EnableXXX</code>基本上是一下逻辑：<ul><li>提前将你需要的组件的配置以JavaConfig的方式定义好</li><li>自定义好一个Enable注解</li><li>在Enable注解上，加上@Import注解，参数是定义好的JavaConfig类</li><li>然后将该注解加在需要使用组件的工程的启动类上</li></ul></li></ol><h2 id="ConditionalOnXXX的实现原理"><a href="#ConditionalOnXXX的实现原理" class="headerlink" title="ConditionalOnXXX的实现原理"></a>ConditionalOnXXX的实现原理</h2><p>有没有听过spring提供的注解<code>@org.springframework.context.annotation.Conditional</code>。@Conditional注解可以根据是否满足某一个特定条件来决定要不要创建某个特定的Bean。比如，当某一个jar包在一个类路径下的时自动配置一个或多个Bean；或者只有某个Bean被创建才会创建另外一个Bean。该注解由Spring4开始提供。</p><ol><li><code>@Conditional</code>注解中有一个参数value，需要提供一个实现接口<code>org.springframework.context.annotation.Condition</code>的类</li><li>先看<code>org.springframework.context.annotation.Condition</code>，只有一个方法<code>boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata);</code></li><li>该方法是返回布尔值，也就是说只有当该返回值是true的时候，才会将这个类（有Conditional的类）加载到spring上下文中。</li><li>在spring的代码中，由以下步骤调用：<ul><li>ConfigurationClassParser#doProcessConfigurationClass</li><li>ConditionEvaluator#shouldSkip</li><li>获取到类、bean、方法等上面添加的注解，然后循环去执行注解中的<code>Condition#match</code>方法，获取到返回值，取并集</li><li>true的话，就会加载。false的话，就不会加载。</li></ul></li></ol><h2 id="Profile的实现原理"><a href="#Profile的实现原理" class="headerlink" title="Profile的实现原理"></a>Profile的实现原理</h2><p>直接看<code>@Profile</code>的源码：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span><span class="token punctuation">{</span>ElementType<span class="token punctuation">.</span>TYPE<span class="token punctuation">,</span> ElementType<span class="token punctuation">.</span>METHOD<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span>RetentionPolicy<span class="token punctuation">.</span>RUNTIME<span class="token punctuation">)</span><span class="token annotation punctuation">@Documented</span><span class="token annotation punctuation">@Conditional</span><span class="token punctuation">(</span>ProfileCondition<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">Profile</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * The set of profiles for which the annotated component should be registered.     */</span>    String<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><ol><li>说白了也是基于<code>@Conditional</code>来实现的</li><li>【看源码】</li><li>可以发现，spring在上下文环境中，检查这个profile参数</li><li>上下文中的参数值来源于启动时，设置的启动参数<code>spring.profiles.active</code>传入的<pre class=" language-java"><code class="language-java"><span class="token keyword">protected</span> Set<span class="token operator">&lt;</span>String<span class="token operator">></span> <span class="token function">doGetActiveProfiles</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>activeProfiles<span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>activeProfiles<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>             <span class="token comment" spellcheck="true">// 这里的ACTIVE_PROFILES_PROPERTY_NAME=spring.profiles.active</span>             String profiles <span class="token operator">=</span> <span class="token function">getProperty</span><span class="token punctuation">(</span>ACTIVE_PROFILES_PROPERTY_NAME<span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token keyword">if</span> <span class="token punctuation">(</span>StringUtils<span class="token punctuation">.</span><span class="token function">hasText</span><span class="token punctuation">(</span>profiles<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                 <span class="token function">setActiveProfiles</span><span class="token punctuation">(</span>StringUtils<span class="token punctuation">.</span><span class="token function">commaDelimitedListToStringArray</span><span class="token punctuation">(</span>                         StringUtils<span class="token punctuation">.</span><span class="token function">trimAllWhitespace</span><span class="token punctuation">(</span>profiles<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token punctuation">}</span>         <span class="token punctuation">}</span>         <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>activeProfiles<span class="token punctuation">;</span>     <span class="token punctuation">}</span> <span class="token punctuation">}</span></code></pre></li></ol><h2 id="AutoConfigureAfter、AutoConfigureBefore的实现原理"><a href="#AutoConfigureAfter、AutoConfigureBefore的实现原理" class="headerlink" title="AutoConfigureAfter、AutoConfigureBefore的实现原理"></a>AutoConfigureAfter、AutoConfigureBefore的实现原理</h2><p>简介：</p><ol><li>AutoConfigureAfter 声明 当前配置应该在 指定配置之后初始化</li><li>AutoConfigureBefore 声明 当前配置应该在 指定配置之前初始化</li></ol><p>源码：</p><ol><li><code>org.springframework.boot.autoconfigure.AutoConfigurationSorter#getInPriorityOrder</code>这个方法进行排序</li><li>由于这两个方法是由spring-boot定义的，而配置的加载是由spring-framework来执行的，所以并不能影响到spring加载配置的顺序</li><li>那这两个类的作用域是哪里呢？看源码，可以看到是从<code>SpringFactoriesLoader.loadFactoryNames</code>这个方法取到的配置，进行加载的。【后面有分析】</li><li>而这些类都是由spring的spi提供的</li><li>所以这两个注解只能用于spring-boot定义的配置【定义在spring.factories中的，后面分析】</li></ol><h2 id="Java的SPI和Spring的SpringFactoriesLoader初探"><a href="#Java的SPI和Spring的SpringFactoriesLoader初探" class="headerlink" title="Java的SPI和Spring的SpringFactoriesLoader初探"></a>Java的SPI和Spring的SpringFactoriesLoader初探</h2><p>首先抛出一个问题，我们在使用数据源的时候，只需要把对应数据库的驱动依赖进来，在Java的代码中就可以获取到相应的数据源实现，JDK中，怎么提前知道你这个数据源具体的实现类呢？？？<br>啥也不说，直接看代码【举例MySQL的驱动包】：</p><ol><li>打开源码，找到数据源驱动的具体实现：<code>com.mysql.jdbc.Driver</code></li><li>果然是实现<code>java.sql.Driver</code>的</li><li>那JVM是怎么知道这个类的呢？</li><li>看MySQL驱动包下<code>META-INF/services/java.sql.Driver</code>文件，该文件中有两行代码（第二行忽略）<pre><code> com.mysql.jdbc.Driver com.mysql.fabric.jdbc.FabricMySQLDriver</code></pre></li><li>这里果然有驱动的实现类，那就有理由怀疑这个文件在影响到JVM的加载</li></ol><h3 id="Java的-SPI"><a href="#Java的-SPI" class="headerlink" title="Java的 SPI"></a>Java的 <code>SPI</code></h3><ol><li>首先，SPI的全称是：Service Provider Interface（Java提供的一套用来被第三方实现或者扩展的API，它可以用来启用框架扩展和替换组件。）</li><li>可以先看看Java中怎么通过SPI获取到具体数据源的驱动的：<pre><code> java.sql.DriverManager#586 // 这里去classpath*:META-INF/services/下寻找传入的类名的文件，然后取到该文件中的每一行 ServiceLoader&lt;Driver&gt; loadedDrivers = ServiceLoader.load(Driver.class); Iterator&lt;Driver&gt; driversIterator = loadedDrivers.iterator(); try{     while(driversIterator.hasNext()) {         // 这里的迭代器，会在next方法中对文件中的每一行调用Class.forName进行反射加载到JVM中         driversIterator.next();     } } catch(Throwable t) { // Do nothing } return null;</code></pre></li><li>所以利用Java的SPI可以这样做：<ul><li>定义一个接口，用来扩展组件中的一些功能</li><li>在组建中，可以使用<code>ServiceLoader#load</code>来加载使用者扩展的功能</li><li>使用方在扩展该组件时，在<code>classpath*:META-INF/services/</code>下以组件接口全路径创建文件</li><li>然后将自己扩展的实现该接口的类全路径写入上面的文件中，多个的话，一行一个</li><li>应用启动后，就可以将使用方扩展的功能通过SPI的方式加载到JVM中了</li></ul></li><li>已经被弃用的<code>xny-mybatis</code>中就使用了Java的SPI来扩展新的接口，可参考</li></ol><h3 id="Spring的SpringFactoriesLoader"><a href="#Spring的SpringFactoriesLoader" class="headerlink" title="Spring的SpringFactoriesLoader"></a>Spring的<code>SpringFactoriesLoader</code></h3><p>这个主要还是用在<code>spring-boot-starter</code>的开发中，只需要引入对应的starter，就可以直接开发了，省去配置的过程（特指JavaConfig的配置），步骤如下：</p><ol><li><p>工程启动类上的注解<code>@SpringBootApplication</code></p></li><li><p>该注解上的注解<code>@EnableAutoConfiguration</code></p></li><li><p>这个注解上的注解<code>@Import(AutoConfigurationImportSelector.class)</code></p></li><li><p>直接调用这里的类的<code>selectImports</code>方法</p></li><li><p>上面的方法中会调用<code>org.springframework.boot.autoconfigure.AutoConfigurationImportSelector#getCandidateConfigurations</code></p></li><li><p>这时候会有如下一段代码：</p><pre class=" language-java"><code class="language-java"> <span class="token keyword">protected</span> List<span class="token operator">&lt;</span>String<span class="token operator">></span> <span class="token function">getCandidateConfigurations</span><span class="token punctuation">(</span>AnnotationMetadata metadata<span class="token punctuation">,</span>         AnnotationAttributes attributes<span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token comment" spellcheck="true">// 通过SpringFactoriesLoader去获取外部定义的配置类</span>     List<span class="token operator">&lt;</span>String<span class="token operator">></span> configurations <span class="token operator">=</span> SpringFactoriesLoader<span class="token punctuation">.</span><span class="token function">loadFactoryNames</span><span class="token punctuation">(</span>             <span class="token function">getSpringFactoriesLoaderFactoryClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">getBeanClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     Assert<span class="token punctuation">.</span><span class="token function">notEmpty</span><span class="token punctuation">(</span>configurations<span class="token punctuation">,</span>             <span class="token string">"No auto configuration classes found in META-INF/spring.factories. If you "</span>                     <span class="token operator">+</span> <span class="token string">"are using a custom packaging, make sure that file is correct."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">return</span> configurations<span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token keyword">protected</span> Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> <span class="token function">getSpringFactoriesLoaderFactoryClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token keyword">return</span> EnableAutoConfiguration<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre></li><li><p><code>SpringFactoriesLoader</code>与Java的<code>SPI</code>区别在于</p><ul><li>spring的外部定义文件名是<code>spring.factories</code>，而Java的是接口全路径</li><li>spring的文件其实是一个properties文件，而Java的是文本文件</li><li>spring的话，可以在一个文件中定义多个功能的扩展，而Java就需要N个文件了</li></ul></li></ol><h2 id="从spring-boot的自动配置衍生出平台SDK的架构"><a href="#从spring-boot的自动配置衍生出平台SDK的架构" class="headerlink" title="从spring-boot的自动配置衍生出平台SDK的架构"></a>从spring-boot的自动配置衍生出平台SDK的架构</h2><ol><li>首先有各个中心的SDK【后面以任务调度中心<code>platform-tsc-sdk</code>举例】</li><li>另外有一个<code>platform-sdk-starter</code>，在这个组件中依赖了各个中心的SDK，只不过都是optional的<pre class=" language-groovy"><code class="language-groovy"> <span class="token comment" spellcheck="true">// sdk</span> <span class="token comment" spellcheck="true">// 消息中心sdk</span> <span class="token function">compileOnly</span><span class="token punctuation">(</span><span class="token string">"com.yezi.platform:platform-mc-sdk:${platform_mc_sdk_version}"</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 流程中心</span> <span class="token function">compileOnly</span><span class="token punctuation">(</span><span class="token string">"com.yezi.platform:platform-pc-sdk:${platform_pc_sdk_version}"</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 任务调度中心</span> <span class="token function">compileOnly</span><span class="token punctuation">(</span><span class="token string">"com.yezi.platform:platform-tsc-sdk:${platform_tsc_sdk_version}"</span><span class="token punctuation">)</span></code></pre></li><li>然后定义各个中心的自动配置类，如<code>TaskSchedulingCenterAutoConfiguration</code><pre class=" language-java"><code class="language-java"> <span class="token annotation punctuation">@Configuration</span> <span class="token annotation punctuation">@Import</span><span class="token punctuation">(</span>ThreadPoolConfiguration<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token annotation punctuation">@ConditionalOnClass</span><span class="token punctuation">(</span>JobExecuteClient<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TaskSchedulingCenterAutoConfiguration</span> <span class="token punctuation">{</span>     <span class="token comment" spellcheck="true">// ...</span> <span class="token punctuation">}</span></code></pre></li><li>注意上面的<code>@ConditionalOnClass(JobExecuteClient.class)</code>，通过对上面spring-boot中的@ConditionalOnXXX的了解，可以判断出这句的意思是：只有当JVM中存在JobExecuteClient这个类的情况下，改配置才会被加载到spring上下文中</li><li>而这个类是任务调度中心SDK中特有的一个类</li><li>又因为这个SDK在<code>build.gradle</code>是<code>compileOnly</code>的</li><li>所以只有当应用方在他的<code>build.gradle</code>中显式的依赖了<code>com.yezi.platform:platform-tsc-sdk</code>，任务调度中心的功能才会被启用。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XXL-JOB几个关键线程、队列的分析</title>
      <link href="/2020/02/28/hou-duan/xxl-job-ji-ge-guan-jian-xian-cheng-dui-lie-de-fen-xi/"/>
      <url>/2020/02/28/hou-duan/xxl-job-ji-ge-guan-jian-xian-cheng-dui-lie-de-fen-xi/</url>
      
        <content type="html"><![CDATA[<h1 id="XXL-JOB几个关键线程、队列的分析"><a href="#XXL-JOB几个关键线程、队列的分析" class="headerlink" title="XXL-JOB几个关键线程、队列的分析"></a>XXL-JOB几个关键线程、队列的分析</h1><blockquote><p>XXL-JOB在初始化时，会执行一系列的方法，这些方法启动了一系列的线程，还创建了一些队列，这些线程、队列对于整个任务调度来说都是至关重要的，现在就来分析一下这些线程、队列。</p></blockquote><a id="more"></a><h2 id="调度中心的初始化"><a href="#调度中心的初始化" class="headerlink" title="调度中心的初始化"></a>调度中心的初始化</h2><ol><li><p>调度中心启动时，会先执行 <code>com.xxl.job.admin.core.conf.XxlJobAdminConfig#afterPropertiesSet</code> 这个方法（因为这个类是实现 <code>org.springframework.beans.factory.InitializingBean</code> 接口的）</p></li><li><p>这个方法的代码</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">afterPropertiesSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span> adminConfig <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span> xxlJobScheduler <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">XxlJobScheduler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> xxlJobScheduler<span class="token punctuation">.</span><span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>关键在于执行了， <code>xxlJobScheduler.init()</code> 。再来看看这个方法的内容（通过添加一些注释）：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 初始化i18n信息</span> <span class="token function">initI18n</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 调度中心监听执行器的注册</span> <span class="token comment" spellcheck="true">// 这里主要是监听自动注册的执行器，并且实时更新其状态</span> <span class="token comment" spellcheck="true">// 线程分析见4</span> JobRegistryMonitorHelper<span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 调度中心监控失败的调度</span> <span class="token comment" spellcheck="true">// 首先进行重试，重试的次数为页面配置，每次减1</span> <span class="token comment" spellcheck="true">// 发送失败告警邮件</span> JobFailMonitorHelper<span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 调度中心调度监控</span> <span class="token comment" spellcheck="true">// 源码分析见5</span> JobTriggerPoolHelper<span class="token punctuation">.</span><span class="token function">toStart</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 调度中心的日志整理</span> JobLogReportHelper<span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 调度线程</span> <span class="token comment" spellcheck="true">// 用于扫描即将要执行的任务（当前时间+5000毫秒）</span> <span class="token comment" spellcheck="true">// 源码分析可见https://www.cnblogs.com/jiangyang/p/11576931.html</span> JobScheduleHelper<span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> logger<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">">>>>>>>>> init xxl-job admin success."</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>调度中心监听执行器的注册</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 创建一个线程，该线程用来监听库中新增的自动注册的执行器</span> registryThread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token annotation punctuation">@Override</span>     <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token comment" spellcheck="true">// 该线程中运行着一个while死循环</span>         <span class="token comment" spellcheck="true">// 当且仅当调用stop方法，将toStop设置为true，死循环结束，也就是监听结束</span>         <span class="token comment" spellcheck="true">// 基本上每个监听线程都是在这么做的</span>         <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>toStop<span class="token punctuation">)</span> <span class="token punctuation">{</span>             <span class="token comment" spellcheck="true">// ...........</span>             <span class="token comment" spellcheck="true">// 这里设置线程休眠30s，意味着30s检测一次执行器的状态</span>             <span class="token keyword">try</span> <span class="token punctuation">{</span>                 TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span>RegistryConfig<span class="token punctuation">.</span>BEAT_TIMEOUT<span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                 <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>toStop<span class="token punctuation">)</span> <span class="token punctuation">{</span>                     logger<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">">>>>>>>>>>> xxl-job, job registry monitor thread error:{}"</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token punctuation">}</span>             <span class="token punctuation">}</span>         <span class="token punctuation">}</span>         logger<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">">>>>>>>>>>> xxl-job, job registry monitor thread stop"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 设置线程相关参数</span> registryThread<span class="token punctuation">.</span><span class="token function">setDaemon</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span> registryThread<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"xxl-job, admin JobRegistryMonitorHelper"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> registryThread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>调度中心调度监控<br>这里启动了两个线程池： <code>fastTriggerPool</code> 和 <code>slowTriggerPool</code> ，当一个job的执行时间超过500毫秒时，将会被放入 <code>slowTriggerPool</code> 线程池来运行</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> xxl-job </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XXL-JOB日志获取分析</title>
      <link href="/2020/02/28/hou-duan/xxl-job-ri-zhi-huo-qu-fen-xi/"/>
      <url>/2020/02/28/hou-duan/xxl-job-ri-zhi-huo-qu-fen-xi/</url>
      
        <content type="html"><![CDATA[<h1 id="XXL-JOB日志获取分析"><a href="#XXL-JOB日志获取分析" class="headerlink" title="XXL-JOB日志获取分析"></a>XXL-JOB日志获取分析</h1><h2 id="现状"><a href="#现状" class="headerlink" title="现状"></a>现状</h2><p>xxl-job在任务执行时，可以看到日志，并且是实时、一行一行的展示出来。起初我认为是执行器在执行时，在每一个关键步骤向调度中心输出日志，而调度中心展示的日志也是实时接收到执行器返回的，后来在跟代码时，发现我的认知是错误的！其实是间隔一段时间(3s)就去执行器读取执行器服务器本地的日志文件！</p><a id="more"></a><h2 id="获取执行器日志的时序图"><a href="#获取执行器日志的时序图" class="headerlink" title="获取执行器日志的时序图"></a>获取执行器日志的时序图</h2><p><img src="/imgs/xxl-job/2.png" alt="xxl-job实时获取执行器日志的时序图.png"></p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> xxl-job </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>模拟任务阻塞处理策略</title>
      <link href="/2020/02/28/hou-duan/mo-ni-ren-wu-zu-sai-chu-li-ce-lue/"/>
      <url>/2020/02/28/hou-duan/mo-ni-ren-wu-zu-sai-chu-li-ce-lue/</url>
      
        <content type="html"><![CDATA[<h1 id="模拟任务阻塞处理策略"><a href="#模拟任务阻塞处理策略" class="headerlink" title="模拟任务阻塞处理策略"></a>模拟任务阻塞处理策略</h1><h2 id="官方描述"><a href="#官方描述" class="headerlink" title="官方描述"></a>官方描述</h2><blockquote><p>阻塞处理策略：调度过于密集执行器来不及处理时的处理策略；</p></blockquote><ol><li>单机串行（默认）：调度请求进入单机执行器后，调度请求进入FIFO队列并以串行方式运行；</li><li>丢弃后续调度：调度请求进入单机执行器后，发现执行器存在运行的调度任务，本次请求将会被丢弃并标记为失败；</li><li>覆盖之前调度：调度请求进入单机执行器后，发现执行器存在运行的调度任务，将会终止运行中的调度任务并清空队列，然后运行本地调度任务；</li></ol><p>为了验证并且更加熟悉XXL-JOB这一块的功能，遂做了如下的实验：</p><a id="more"></a><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><h3 id="编写3个任务执行方法"><a href="#编写3个任务执行方法" class="headerlink" title="编写3个任务执行方法"></a>编写3个任务执行方法</h3><ol><li><p>模拟【阻塞处理策略】为 <code>单机串行</code> </p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@XxlJob</span><span class="token punctuation">(</span><span class="token string">"serialExecutionJobHandler"</span><span class="token punctuation">)</span><span class="token keyword">public</span> ReturnT<span class="token operator">&lt;</span>String<span class="token operator">></span> <span class="token function">serialExecutionJobHandler</span><span class="token punctuation">(</span>String param<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span> XxlJobLogger<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"XXL-JOB, serialExecutionJobHandler."</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 休眠1分钟，模拟执行时间特别长</span> TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">60</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">return</span> ReturnT<span class="token punctuation">.</span>SUCCESS<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>模拟【阻塞处理策略】为 <code>丢弃后续调度</code> </p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@XxlJob</span><span class="token punctuation">(</span><span class="token string">"discardLaterJobHandler"</span><span class="token punctuation">)</span><span class="token keyword">public</span> ReturnT<span class="token operator">&lt;</span>String<span class="token operator">></span> <span class="token function">discardLaterJobHandler</span><span class="token punctuation">(</span>String param<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span> XxlJobLogger<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"XXL-JOB, discardLaterJobHandler."</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 休眠1分钟，模拟执行时间特别长</span> TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">60</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">return</span> ReturnT<span class="token punctuation">.</span>SUCCESS<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>模拟【阻塞处理策略】为 <code>覆盖之前调度</code> </p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@XxlJob</span><span class="token punctuation">(</span><span class="token string">"coverEarlyJobHandler"</span><span class="token punctuation">)</span><span class="token keyword">public</span> ReturnT<span class="token operator">&lt;</span>String<span class="token operator">></span> <span class="token function">coverEarlyJobHandler</span><span class="token punctuation">(</span>String param<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span> XxlJobLogger<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"XXL-JOB, coverEarlyJobHandler."</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 休眠1分钟，模拟执行时间特别长</span> TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">60</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">return</span> ReturnT<span class="token punctuation">.</span>SUCCESS<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol><h3 id="在调度中心页面创建3个任务，分别对应3种阻塞处理策略"><a href="#在调度中心页面创建3个任务，分别对应3种阻塞处理策略" class="headerlink" title="在调度中心页面创建3个任务，分别对应3种阻塞处理策略"></a>在调度中心页面创建3个任务，分别对应3种阻塞处理策略</h3><ol><li><p>任务配置</p><p> <img src="/imgs/xxl-job/3.png" alt="image.png"></p></li><li><p>对每个任务，使用调度中心页面上的 <code>执行一次</code> 按钮  触发  （第一次触发是为了第二次任务进行时存在阻塞的任务）</p></li><li><p>观察每个任务的日志：</p><ul><li><p>单机串行【任务id为3】</p><p>  <img src="/imgs/xxl-job/4.png" alt="image.png"><br /><img src="/imgs/xxl-job/5.png" alt="image.png"><br />可见两次调度都是成功的，但是第二个任务一直在等待第一个任务执行完成，才会被执行。</p></li><li><p>丢弃后续调度任务【任务id为4】</p><p>  <img src="/imgs/xxl-job/6.png" alt="image.png"><br />可见因为这个任务有一次调度正在被执行中，并且阻塞处理策略为【丢弃后续调度任务】，所以第二次调度结果直接为失败！</p></li><li><p>覆盖之前调度任务【任务id为5】</p><p>  <img src="/imgs/xxl-job/7.png" alt="image.png"><br />可见该任务第二次被调度时，发现已经有调度正在被执行（第一次调度结果为成功），由于阻塞策略设置为【覆盖之前调度任务】，所以执行器会将第一次调度kill掉，然后开始执行第二次调度。</p></li></ul></li></ol><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><ol><li>执行阻塞策略是在执行器中判断、执行的</li><li>调度中心在调度任务时，会将任务配置的阻塞策略通过RPC传给执行器</li><li>执行器在执行时，调用的是 <code>com.xxl.job.core.biz.impl.ExecutorBizImpl#run</code> 方法</li><li>该方法最后一段就是在根据阻塞策略进行一些判断，如下<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 阻塞策略判断</span><span class="token keyword">if</span> <span class="token punctuation">(</span>jobThread <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 进入这个判断，则表示当前执行任务的线程中有正在运行的</span> <span class="token comment" spellcheck="true">// 所以需要根据阻塞策略决定是否执行本次调度</span> ExecutorBlockStrategyEnum blockStrategy <span class="token operator">=</span> ExecutorBlockStrategyEnum<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>triggerParam<span class="token punctuation">.</span><span class="token function">getExecutorBlockStrategy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>ExecutorBlockStrategyEnum<span class="token punctuation">.</span>DISCARD_LATER <span class="token operator">==</span> blockStrategy<span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token comment" spellcheck="true">// 因为上一次的调度正在线程池中跑，需要再次判断</span>     <span class="token keyword">if</span> <span class="token punctuation">(</span>jobThread<span class="token punctuation">.</span><span class="token function">isRunningOrHasQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token comment" spellcheck="true">// 丢弃后续调度</span>         <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ReturnT</span><span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">(</span>ReturnT<span class="token punctuation">.</span>FAIL_CODE<span class="token punctuation">,</span> <span class="token string">"block strategy effect："</span><span class="token operator">+</span>ExecutorBlockStrategyEnum<span class="token punctuation">.</span>DISCARD_LATER<span class="token punctuation">.</span><span class="token function">getTitle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span> <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>ExecutorBlockStrategyEnum<span class="token punctuation">.</span>COVER_EARLY <span class="token operator">==</span> blockStrategy<span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token comment" spellcheck="true">// kill running jobThread</span>     <span class="token comment" spellcheck="true">// 覆盖之前调度</span>     <span class="token keyword">if</span> <span class="token punctuation">(</span>jobThread<span class="token punctuation">.</span><span class="token function">isRunningOrHasQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>         removeOldReason <span class="token operator">=</span> <span class="token string">"block strategy effect："</span> <span class="token operator">+</span> ExecutorBlockStrategyEnum<span class="token punctuation">.</span>COVER_EARLY<span class="token punctuation">.</span><span class="token function">getTitle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         jobThread <span class="token operator">=</span> null<span class="token punctuation">;</span>     <span class="token punctuation">}</span> <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>     <span class="token comment" spellcheck="true">// just queue trigger</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 其实这里才是 覆盖之前调度 正在在执行本次调度</span><span class="token comment" spellcheck="true">// replace thread (new or exists invalid)</span><span class="token keyword">if</span> <span class="token punctuation">(</span>jobThread <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span> jobThread <span class="token operator">=</span> XxlJobExecutor<span class="token punctuation">.</span><span class="token function">registJobThread</span><span class="token punctuation">(</span>triggerParam<span class="token punctuation">.</span><span class="token function">getJobId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> jobHandler<span class="token punctuation">,</span> removeOldReason<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> xxl-job </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XXL-JOB调研</title>
      <link href="/2020/02/24/hou-duan/xxl-job-diao-yan/"/>
      <url>/2020/02/24/hou-duan/xxl-job-diao-yan/</url>
      
        <content type="html"><![CDATA[<h1 id="架构图"><a href="#架构图" class="headerlink" title="架构图"></a>架构图</h1><p><img src="/imgs/xxl-job/1.png" alt=""></p><a id="more"></a><h1 id="xxl-job的jar包"><a href="#xxl-job的jar包" class="headerlink" title="xxl-job的jar包"></a>xxl-job的jar包</h1><ol><li>xxl-job-admin: 调度中心（包含了前端html）</li><li>xxl-job-core：公共组件包（调用中心、执行器都会依赖这个包）</li></ol><h1 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h1><h2 id="调度中心部署注意的点"><a href="#调度中心部署注意的点" class="headerlink" title="调度中心部署注意的点"></a>调度中心部署注意的点</h2><ol><li>DB配置要保持一致</li><li>集群机器时钟要一致（需要做时间同步）</li><li>使用nginx做负载均衡</li><li>如何是用docker在k8s中部署的话，只需要部署一个deployment，然后扩容成多份即可</li></ol><h2 id="执行器部署"><a href="#执行器部署" class="headerlink" title="执行器部署"></a>执行器部署</h2><ol><li>执行器我的理解，应该是每个项目组有一个执行器这个微服务工程，然后在这个工程里去写各种的定时任务的handler，这些handler再通过feign调用改项目组其他微服务</li><li>执行器工程需要依赖<code>xxl-job-core</code></li><li>配置调度中心的地址</li><li>配置appName(xxl-job中，如果不配置此name，则执行器不会自动注册到调度中心)</li><li>配置执行器的ip（一般会在多网卡的情况下配置）</li><li>配置执行器的port（这两个配置是给调度中心通知执行器去执行的）</li><li>配置token（可选）</li><li>配置日志路径（执行器的日志路径，后面可以考虑换成我们的ELK）</li><li>配置日志保存的天数（如果换成ELK的话，可以不用这个配置了）</li></ol><h1 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h1><h2 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h2><ol><li>执行器应该是以项目为维度划分的，一个项目有一个执行器</li><li>一个执行器有多个任务</li></ol><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><ol><li>任务关联在执行器上</li></ol><h2 id="任务路由策略"><a href="#任务路由策略" class="headerlink" title="任务路由策略"></a>任务路由策略</h2><ol><li>FIRST（第一个）：固定选择第一个机器；</li><li>LAST（最后一个）：固定选择最后一个机器；</li><li>ROUND（轮询）：；</li><li>RANDOM（随机）：随机选择在线的机器；</li><li>CONSISTENT_HASH（一致性HASH）：每个任务按照Hash算法固定选择某一台机器，且所有任务均匀散列在不同机器上。</li><li>LEAST_FREQUENTLY_USED（最不经常使用）：使用频率最低的机器优先被选举；</li><li>LEAST_RECENTLY_USED（最近最久未使用）：最久为使用的机器优先被选举；</li><li>FAILOVER（故障转移）：按照顺序依次进行心跳检测，第一个心跳检测成功的机器选定为目标执行器并发起调度；</li><li>BUSYOVER（忙碌转移）：按照顺序依次进行空闲检测，第一个空闲检测成功的机器选定为目标执行器并发起调度；</li><li>SHARDING_BROADCAST(分片广播)：广播触发对应集群中所有机器执行一次任务，同时系统自动传递分片参数；可根据分片参数开发分片任务；</li></ol><h2 id="任务的运行模式"><a href="#任务的运行模式" class="headerlink" title="任务的运行模式"></a>任务的运行模式</h2><ol><li>BEAN模式：任务以JobHandler方式维护在执行器端；需要结合 “JobHandler” 属性匹配执行器中任务；</li><li>GLUE模式(Java)：任务以源码方式维护在调度中心；该模式的任务实际上是一段继承自IJobHandler的Java类代码并 “groovy” 源码方式维护，它在执行器项目中运行，可使用@Resource/@Autowire注入执行器里中的其他服务；</li><li>GLUE模式(Shell)：任务以源码方式维护在调度中心；该模式的任务实际上是一段 “shell” 脚本；</li><li>GLUE模式(Python)：任务以源码方式维护在调度中心；该模式的任务实际上是一段 “python” 脚本；</li><li>GLUE模式(PHP)：任务以源码方式维护在调度中心；该模式的任务实际上是一段 “php” 脚本；</li><li>GLUE模式(NodeJS)：任务以源码方式维护在调度中心；该模式的任务实际上是一段 “nodejs” 脚本；</li><li>GLUE模式(PowerShell)：任务以源码方式维护在调度中心；该模式的任务实际上是一段 “PowerShell” 脚本；</li></ol><h2 id="阻塞处理策略"><a href="#阻塞处理策略" class="headerlink" title="阻塞处理策略"></a>阻塞处理策略</h2><ol><li>单机串行（默认）：调度请求进入单机执行器后，调度请求进入FIFO队列并以串行方式运行；</li><li>丢弃后续调度：调度请求进入单机执行器后，发现执行器存在运行的调度任务，本次请求将会被丢弃并标记为失败；</li><li>覆盖之前调度：调度请求进入单机执行器后，发现执行器存在运行的调度任务，将会终止运行中的调度任务并清空队列，然后运行本地调度任务；</li></ol><h1 id="二次开发"><a href="#二次开发" class="headerlink" title="二次开发"></a>二次开发</h1><h2 id="选择在xxl-job的V2-1-2版本上进行开发"><a href="#选择在xxl-job的V2-1-2版本上进行开发" class="headerlink" title="选择在xxl-job的V2.1.2版本上进行开发"></a>选择在xxl-job的V2.1.2版本上进行开发</h2><p>该版本的jobHandler写法比较方便<br />由原来基于JobHandler类任务开发方式，优化为支持基于方法的任务开发方式</p><h2 id="ui的修改"><a href="#ui的修改" class="headerlink" title="ui的修改"></a>ui的修改</h2><ol><li>目前xxl-job的调度中心的界面需要重写</li></ol><h2 id="SDK"><a href="#SDK" class="headerlink" title="SDK"></a>SDK</h2><ol><li>现阶段，SDK中应该只需要提供自动注册、通知执行器等功能</li><li>后期可以提供方法：让业务方能查询到某个任务在某一次的执行状态等等方法</li></ol><h2 id="痛点"><a href="#痛点" class="headerlink" title="痛点"></a>痛点</h2><ol><li>xxl-job的代码规范有点乱</li><li>xxl-job-core的职责不清晰，调度中心、执行器都会依赖这个jar包，我们需要进行拆分</li><li>需要重写xxl-job的前端</li><li>日志的查看</li><li>sdk包的职责定义</li><li>配置如何与nacos进行集成</li><li>改造后的任务调度中心如果对xxl-job进行升级</li></ol>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> xxl-job </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记一次MySQL启动失败原因的分析</title>
      <link href="/2020/02/12/yun-wei/failed-to-start-mysql/"/>
      <url>/2020/02/12/yun-wei/failed-to-start-mysql/</url>
      
        <content type="html"><![CDATA[<blockquote><p>今天在我的Windows电脑上准备启动MySQL服务，测试一点东西，但是发现每次都启动不成功，所以就引出本次的分析</p></blockquote><a id="more"></a><h2 id="排查启动失败的原因"><a href="#排查启动失败的原因" class="headerlink" title="排查启动失败的原因"></a>排查启动失败的原因</h2><ol><li><p>首先，我的MySQL服务已经注册到windows的服务中了，所以需要查看windows服务的启动日志</p></li><li><p>打开windows的<code>事件查看器</code>(windows开始图标上右键-事件查看器)</p></li><li><p>左边菜单树上选择<code>Windows 日志 - 应用程序</code><br><img src="/imgs/mysql/1.png" alt=""></p></li><li><p>右边操作栏选择<code>筛选当前日志...</code>，设置事件级别为<code>错误</code>如下图：<br><img src="/imgs/mysql/2.png" alt=""></p></li><li><p>通过筛选查看，可以发现如下信息，MySQL的端口被占用了<br><img src="/imgs/mysql/3.png" alt=""></p></li></ol><h2 id="排查端口占用情况"><a href="#排查端口占用情况" class="headerlink" title="排查端口占用情况"></a>排查端口占用情况</h2><ol><li><p>在Windows下查看端口被占用的情况（被哪个进程占用了）</p><pre><code> C:\Users\sunha&gt;netstat -ano|findstr 3306   TCP    0.0.0.0:3306           0.0.0.0:0              LISTENING       4564</code></pre></li><li><p>记住最右一列的值，此处是<code>4564</code>，这个就是占用进程的<code>pid</code></p></li><li><p>根据上面pid查改进程跑的是哪个应用程序</p><pre><code> C:\Users\sunha&gt;tasklist|findstr 4564vmnat.exe                     4564 Services                   0      5,364 K</code></pre></li><li><p>到此时已经查到哪个应用程序在作祟，就是<code>vmnat.exe</code></p></li><li><p>这个到底是什么玩意？根据名称<code>vm</code>大概能猜到是虚拟机，再根据<code>nat</code>能猜到网络</p></li><li><p>所以此处应该是我电脑里安装的虚拟机网络造成的</p></li></ol><h2 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h2><ol><li><p>此时我已经回忆起来了，我电脑里安装了<code>VMware</code></p></li><li><p>而且我的网络策略是<code>nat模式</code></p></li><li><p>为了将虚拟机里的MySQL给同事使用，就做了一个映射出来</p></li><li><p>一查，果然是的了<br><img src="/imgs/mysql/4.png" alt=""></p></li><li><p>删除这个配置，Windows上的MySQL就可以顺利启动了。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Helm学习</title>
      <link href="/2019/11/22/yun-wei/helm-yong-fa/"/>
      <url>/2019/11/22/yun-wei/helm-yong-fa/</url>
      
        <content type="html"><![CDATA[<ol><li><p>安装helm</p><pre><code> # 官方一键安装脚本 curl https://raw.githubusercontent.com/helm/helm/master/scripts/get &gt; get_helm.sh $ chmod 700 get_helm.sh $ ./get_helm.sh</code></pre><a id="more"></a>    </li><li><p>安装Tiller</p><ol><li><p>先在 K8S 集群上每个节点安装 socat 软件(yum install -y socat)，否则会报错</p><pre><code> E0522 22:22:15.492436   24409 portforward.go:331] an error occurred forwarding 38398 -&gt; 44134: error forwarding port 44134 to pod dc6da4ab99ad9c497c0cef1776b9dd18e0a612d507e2746ed63d36ef40f30174, uid : unable to do port forwarding: socat not found. Error: cannot connect to Tiller</code></pre></li><li><p>国内安装使用阿里云的镜像，Google被墙</p><pre><code> helm init --service-account tiller --upgrade -i registry.cn-hangzhou.aliyuncs.com/google_containers/tiller:v2.13.1</code></pre></li><li><p>查看所有的仓库</p><pre><code> [root@k8s-master home]# helm repo list NAME         URL                                              stable       https://kubernetes-charts.storage.googleapis.com local        http://127.0.0.1:8879/charts</code></pre></li><li><p>添加harbor的charts仓库</p><pre><code> helm repo add --username helm --password Helm12345 home-helm http://home.lodsve.com:9013/chartrepo/helm</code></pre></li><li><p>更新仓库</p><pre><code> helm repo update</code></pre></li><li><p>给 Tiller 授权</p><ol><li><p>创建service account</p><pre><code> kubectl create serviceaccount --namespace kube-system tiller kubectl create clusterrolebinding tiller-cluster-rule --clusterrole=cluster-admin --serviceaccount=kube-system:tiller</code></pre></li><li><p>授权</p><pre><code> kubectl patch deploy --namespace kube-system tiller-deploy -p &#39;{&quot;spec&quot;:{&quot;template&quot;:{&quot;spec&quot;:{&quot;serviceAccount&quot;:&quot;tiller&quot;}}}}&#39;</code></pre></li><li><p>验证是否成功</p><pre><code> [root@k8s-master home]# kubectl get deploy --namespace kube-system tiller-deploy --output yaml | grep serviceAccount       serviceAccount: tiller       serviceAccountName: tiller</code></pre></li></ol></li><li><p>卸载</p><pre><code> helm reset或者helm reset --force</code></pre></li></ol></li><li><p>创建charts</p><ol><li><p>创建名为csc-fmis-config-server的chart</p><pre><code> helm create csc-fmis-config-server</code></pre></li><li><p>编辑各种文件：</p><pre><code> [root@k8s-master workspace]# tree csc-fmis-config-server/ csc-fmis-config-server/ ├── Chart.yaml                      # Chart本身的版本和配置信息 ├── charts                          # 依赖的chart ├── README.md                       # readme ├── templates                       # 配置模板目录 │   ├── NOTES.txt                   # helm提示信息 │   ├── _helpers.tpl                # 用于修改kubernetes objcet配置的模板 │   ├── deployment.yaml             # k8s的部署yaml │   └── service.yaml                # k8s的服务yaml └── values.yaml                     # 上面模板中使用到的值 2 directory, 7 files</code></pre></li><li><p>使用go的template语法</p></li><li><p>检查配置和模板是否有效</p><pre><code> helm install --dry-run --debug csc-fmis-config-server -f custom.yaml</code></pre></li><li><p>可以使用外部yaml文件覆盖charts内部的values.yaml中的值，类似spring-boot中的application.yml一样</p></li></ol></li><li><p>推送到远端helm charts repo</p><ol><li><p>安装helm插件，以支持helm push</p><pre><code> helm plugin install https://github.com/chartmuseum/helm-push</code></pre></li><li><p>helm push </p><pre><code> helm push csc-fmis-config-server/ --version=&quot;0.1.2&quot; home-helm</code></pre></li><li><p>push语法</p><pre><code> $ helm push mychart-0.1.0.tgz chartmuseum       # push .tgz from &quot;helm package&quot; $ helm push . chartmuseum                       # package and push chart directory $ helm push . --version=&quot;7c4d121&quot; chartmuseum   # override version in Chart.yaml $ helm push . https://my.chart.repo.com         # push directly to chart repo URL</code></pre></li></ol></li><li><p>安装到k8s中</p><ol><li><code>helm install csc-fmis-config-server</code></li><li><code>helm install csc-fmis-config-server -f custom.yaml</code></li><li><code>helm install csc-fmis-config-server --set foo=bar --set foo=newbar</code></li><li><code>helm install --help</code>查看其它用法</li><li><code>helm list</code></li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> DevOps </tag>
            
            <tag> k8s </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用PowerMockito+MockServer测试外部服务</title>
      <link href="/2019/10/10/hou-duan/shi-yong-powermockito-mockserver-ce-shi-wai-bu-fu-wu/"/>
      <url>/2019/10/10/hou-duan/shi-yong-powermockito-mockserver-ce-shi-wai-bu-fu-wu/</url>
      
        <content type="html"><![CDATA[<blockquote><p>前言</p><p>&nbsp;&nbsp;&nbsp;&nbsp;我们在项目开发中，很有可能会与第三方服务进行通讯，比如发短信、导入账单等等，这些服务写好后，如何能保证是OK的？这就需要进行<strong><code>单元测试</code></strong>，但是每次跑<strong><code>持续集成</code></strong>时，不可能真实的去调用这些发送短信、导入账单的真实接口，所以这里就需要用到强大的mock来模拟这些接口，以实现这些接口。<br>&nbsp;&nbsp;&nbsp;&nbsp;所以这里我们用到了powermock和mockserver两个强大的工具。</p><p>powermockito和mockito的区别：</p></blockquote><ol><li>mockito用代理实现mock，而powermockito是直接去修改字节码实现更强大的mock。</li><li>所以说powermockito是mockito的一个更加强大的扩展。</li><li>mockito不能mock静态、final、私有方法等。</li><li>powermockito号称是<strong>无所不能的PowerMock</strong>,上面mockito的缺陷都可以很好的弥补掉。</li></ol><a id="more"></a><h1 id="调用外部服务分两种情况"><a href="#调用外部服务分两种情况" class="headerlink" title="调用外部服务分两种情况"></a>调用外部服务分两种情况</h1><ol><li>第三方给我们client包</li><li>直接向第三方提供的url发送post/get请求</li></ol><h1 id="两种情况的具体测试方式"><a href="#两种情况的具体测试方式" class="headerlink" title="两种情况的具体测试方式"></a>两种情况的具体测试方式</h1><ol><li><p>client</p><ul><li><p>第三方提供给我们client包，其实他们是将具体请求的url封装在这个jar包中，这时候我们没办法去修改请求的url，那我们应该如何去做呢？</p></li><li><p>我们可以认为第三方给我们的client是经过他们自己的测试，完全可以保证其的正确性，所以那我们可以直接把这个client给mock掉，那就从client的入口处开始mock吧</p></li><li><p>这里需要用到powermock（<strong>无所不能的PowerMock</strong>）去mock私有方法或者静态方法，关于powermock的介绍请参考<a href="http://blog.csdn.net/jackiehff/article/details/14000779" target="_blank" rel="noopener" title="powermock">powermock</a>。</p></li><li><p>pom.xml的配置</p><pre><code>  &lt;!-- mock --&gt;  &lt;dependency&gt;      &lt;groupId&gt;org.powermock&lt;/groupId&gt;      &lt;artifactId&gt;powermock-api-mockito&lt;/artifactId&gt;      &lt;version&gt;1.5.5&lt;/version&gt;      &lt;scope&gt;test&lt;/scope&gt;  &lt;/dependency&gt;  &lt;dependency&gt;      &lt;groupId&gt;org.powermock&lt;/groupId&gt;      &lt;artifactId&gt;powermock-module-junit4&lt;/artifactId&gt;      &lt;version&gt;1.5.5&lt;/version&gt;      &lt;scope&gt;test&lt;/scope&gt;  &lt;/dependency&gt;  &lt;dependency&gt;      &lt;groupId&gt;org.powermock&lt;/groupId&gt;      &lt;artifactId&gt;powermock-module-junit4-rule-agent&lt;/artifactId&gt;      &lt;version&gt;1.5.5&lt;/version&gt;      &lt;scope&gt;test&lt;/scope&gt;  &lt;/dependency&gt;</code></pre></li><li><p>unit-test代码</p><ul><li>具体请参考<code>sharing\labs\powermock</code>和<code>coral.mashup.push</code></li></ul></li></ul></li><li><p>url</p><ul><li><p>直接用url，我们可以将url换成我们自己的url，然后自己创建一个对应的虚拟服务，这个服务将按照指定的请求地址以及参数返回指定的数据格式。如果去创建这个服务？这里我们就用到了MockServer这个工具。</p></li><li><p>如何去使用：</p><ol><li><p>pom.xml的配置</p><pre><code> &lt;!-- mock server --&gt; &lt;dependency&gt;     &lt;groupId&gt;org.mock-server&lt;/groupId&gt;     &lt;artifactId&gt;mockserver-netty&lt;/artifactId&gt;     &lt;version&gt;3.4&lt;/version&gt;     &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt;     &lt;groupId&gt;org.mock-server&lt;/groupId&gt;     &lt;artifactId&gt;mockserver-client-java&lt;/artifactId&gt;     &lt;version&gt;3.4&lt;/version&gt;     &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt;     &lt;groupId&gt;org.mock-server&lt;/groupId&gt;     &lt;artifactId&gt;mockserver-core&lt;/artifactId&gt;     &lt;version&gt;3.4&lt;/version&gt;     &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt;</code></pre></li><li><p>unit-test代码</p><ul><li>具体请参考<code>coral.mashup.sms</code></li><li>这里需要注意一下，如何去替换url。我们url一般都会写在properties中，然后通过SystemConfig这个工具类去获取，所以这里想替换url，只需将SystemConfig工具类相应的方法给mock掉，调用方法的条件是传入对应的key，返回值就是你想要的value即可！</li></ul></li></ol></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单元测试 </tag>
            
            <tag> mock </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用mockito进行单元测试</title>
      <link href="/2019/10/10/hou-duan/shi-yong-mockito-jin-xing-dan-yuan-ce-shi/"/>
      <url>/2019/10/10/hou-duan/shi-yong-mockito-jin-xing-dan-yuan-ce-shi/</url>
      
        <content type="html"><![CDATA[<p>写这篇文档的原因：<br>现在项目中的mock单元测试配置有一点问题:</p><ol><li>单元测试很慢，测试类继承BaseTest，每次测试时都会去加载xml文件到spring容器中，而这个是没有必要，因为mock测试就是用于模拟 被测试类 所调用的其他类的方法，设定这些方法的返回值（即打桩），因此，不需要加载任何spring文件，除非你要调用真实方法操作数据库或者dubbo服务等接口。</li><li>代码中既使用了注解@mock,又使用了spring的配置方式，产生了冗余配置。基于上面问题，说明使用者对mockito的使用并不是很了解，所以在这边简单介绍一下。</li></ol><a id="more"></a><h1 id="使用注解自动生成mock类"><a href="#使用注解自动生成mock类" class="headerlink" title="使用注解自动生成mock类"></a>使用注解自动生成mock类</h1><p>在需要Mock的属性上标记@Mock注解或者@Spy注解，然后@RunWith(MockitoJUnitRunner.class)或者在setUp()方法中显示调用MockitoAnnotations.initMocks(this);生成Mock类即可。</p><blockquote><p>关于@Mock和@Spy注解的区别：</p></blockquote><p>使用@Mock注解的属性会被mock化，而使用@Spy的属性不会被mock化，即如果不打桩默认都会执行真实的方法，如果打桩则返回桩实现。<br>（注：使用@Mock的属性如果想调用真实方法可以使用doCallRealMethod()方法或thenCallRealMethod()，使用@Spy的属性打桩是需要使用doReturn而不要使用thenReturn，使用thenReturn即使返回打桩实现，也会去掉真实方法，这应该是一个mockito的一个bug。)</p><h1 id="自动注入Mock类到被测试类"><a href="#自动注入Mock类到被测试类" class="headerlink" title="自动注入Mock类到被测试类"></a>自动注入Mock类到被测试类</h1><p>只要在被测试类上标记@InjectMocks，Mockito就会自动将标记@Mock、@Spy等注解的属性值注入到被测试类中。  </p><h1 id="完整例子："><a href="#完整例子：" class="headerlink" title="完整例子："></a>完整例子：</h1><p>  测试类</p><pre><code>public class ServiceTest{@Mockprivate Dao mockDao;//@Spy//private Dao spyDao = new Dao();@InjectMocksprivate Service service = new Service();@Beforepublic void setup(){MockitoAnnotations.initMocks(this);}@Testpublic void mockCallRealMethod(){/*调用真实方法*///  doCallRealMethod().when(mockDao).getName(Mockito.anyString());//  doCallRealMethod().when(mockDao).getSex(Mockito.anyString());    when(mockDao.getName(Mockito.anyString())).thenCallRealMethod();    when(mockDao.getSex(Mockito.anyString())).thenCallRealMethod();    String[] userInfos = service.getUserInfos(&quot;1&quot;);    System.out.println(&quot;name:&quot;+userInfos[0]);    System.out.println(&quot;sex:&quot;+userInfos[1]);}@Testpublic void spyTest(){/*使用thenReturn方式打桩，依旧会调用真实方法*///  when(spyDao.getName(&quot;1&quot;)).thenReturn(&quot;zhangsan&quot;);//  when(spyDao.getSex(&quot;1&quot;)).thenReturn(&quot;famle&quot;);/*使用doReturn方式打桩，则不会调用真实方法*///  doReturn(&quot;zhangsan&quot;).when(spyDao).getName(Mockito.anyString());//  doReturn(&quot;famle&quot;).when(spyDao).getSex(Mockito.anyString());    String[] userInfos = service.getUserInfos(&quot;1&quot;);    System.out.println(&quot;name:&quot;+userInfos[0]);    System.out.println(&quot;sex:&quot;+userInfos[1]);}}</code></pre><p>被调用类，即被mock的类：<br>    public class Dao {</p><pre><code>public String getName(String id){    if(StringUtils.isEmpty(id)){        return &quot;no this people&quot;;    }    System.out.println(&quot;id:&quot;+id+&quot; --- name:dengzhi&quot;);    return &quot;dengzhi&quot;;}public String getSex(String id){    if(StringUtils.isEmpty(id)){        return &quot;no this people&quot;;    }    System.out.println(&quot;id:&quot;+id+&quot; --- sex:male&quot;);    return &quot;male&quot;;}}</code></pre><p>被测试类：</p><pre><code>public class Service {Dao dao = new Dao();public String[] getUserInfos(String id){    String[] userInfos = new String[2];    userInfos[0] = dao.getName(id);    userInfos[1] = dao.getSex(id);    return  userInfos;}}</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>从上面的例子可以看出，使用@Mock和@Spy都属性是不再需要spring配置文件的注入的，如果要使用spring注入，则结合@Autowired使用。如下：</p><pre><code>正常的bean声明     &lt;bean id=”dao” class=”Dao”&gt;mock     &lt;bean id=&quot;dao1&quot;  class=&quot;org.mockito.Mockito&quot; factory-method=&quot;mock&quot;&gt;        &lt;constructor-arg value=&quot;DaoInterface&quot;&gt;&lt;/constructor-arg&gt;        &lt;/bean&gt;         请注意到svc不变化，mock将自动注入进入。这是因为spring的bean容器，如果id一样，后声明的bean会覆盖前面的bean。spy     &lt;bean id=&quot;daoInst&quot;  class=&quot;Dao&quot;&gt;&lt;/bean&gt;        &lt;bean id=&quot;dao2&quot;  class=&quot;org.mockito.Mockito&quot; factory-method=&quot;spy&quot;&gt;        &lt;constructor-arg ref=&quot;daoInst&quot;&gt;&lt;/constructor-arg&gt;        &lt;/bean&gt;         同样svc不变化，直接注入。请注意spy需要获得一个实例。</code></pre><p>因此，建议项目中的mock测试去掉mock_service.xml配置文件，去掉继承BaseTest。这样做即去掉冗余配置，又加快测试速度。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单元测试 </tag>
            
            <tag> mock </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git中的后悔药</title>
      <link href="/2019/01/27/gong-ju/git-zhong-de-hou-hui-yao/"/>
      <url>/2019/01/27/gong-ju/git-zhong-de-hou-hui-yao/</url>
      
        <content type="html"><![CDATA[<blockquote><p>当git提交上去一些错误代码或者一些敏感信息时，这时候你需要回滚，但是还是能在git的日志找到蛛丝马迹，这时候我们就需要后悔药了！</p></blockquote><a id="more"></a><ol><li><p>首先，我们需要找到我们需要回滚到的提交点的hash，即<code>commit id</code></p><ul><li><p>在git shell中进入我们的项目目录</p></li><li><p>使用git log命令获取提交的历史找到需要回滚到的提交点(#是我添加的)</p><pre><code>  [sunhao@sunhaode-MacBook-Pro docker-templates]$ git log  # 这次提交包含了敏感信息，需要吃点后悔药  commit 17449b6201cdf2429217dc056d1d66dbeb11f488 (HEAD -&gt; master, origin/master, origin/HEAD)  Author: 孙昊 &lt;sunhao.java@gmail.com&gt;  Date:   Sun Jan 27 01:11:06 2019 +0800      yapi  # 需要回滚到这次提交  commit bcb9f25c09b6cac68bff3f95ccbb2d8df9192414  Author: 孙昊 &lt;sunhao.java@gmail.com&gt;  Date:   Fri Jan 25 18:24:28 2019 +0800      jenkins  commit c9098ba3ec2745ad1107b64bea6e0a5f417d131b  Author: 孙昊 &lt;sunhao.java@gmail.com&gt;  Date:   Fri Jan 25 12:27:09 2019 +0800      owncloud</code></pre></li></ul></li><li><p>复制你需要回滚的commit id，输入复制commit id值，使用<code>git reset --hard commit_id</code></p><pre><code> [sunhao@sunhaode-MacBook-Pro docker-templates]$ git reset --hard bcb9f25c09b6cac68bff3f95ccbb2d8df9192414 HEAD is now at bcb9f25 jenkins</code></pre></li><li><p>然后只要强制提交就行了</p><pre><code> # --force 慎用，会使用你本地的代码仓库直接覆盖远端仓库 git push origin HEAD --force</code></pre></li><li><p>将事先备份好的文件中的敏感信息去掉，再正常操作即可</p><pre><code> git add . git commit -m &quot;yapi&quot; git push</code></pre></li><li><p>这样远端仓库中的敏感信息就去掉了，并且在commit log中也看不见了，达到了“毁尸灭迹”的效果了</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Docker安装YApi</title>
      <link href="/2019/01/23/gong-ju/shi-yong-docker-an-zhuang-yapi/"/>
      <url>/2019/01/23/gong-ju/shi-yong-docker-an-zhuang-yapi/</url>
      
        <content type="html"><![CDATA[<p><code>YApi</code>是<code>去哪儿网大前端技术中心（YMFE）</code>开发并开源的一款<code>高效、易用、功能强大的API管理平台</code>。支持<code>项目管理</code>、<code>接口管理</code>、<code>MockServer</code>、<code>文档管理</code>等等实用功能。</p><h1 id="关于YApi"><a href="#关于YApi" class="headerlink" title="关于YApi"></a>关于<code>YApi</code></h1><ol><li>源码：<a href="https://github.com/YMFE/yapi" target="_blank" rel="noopener">https://github.com/YMFE/yapi</a></li><li>使用教程：<a href="https://yapi.ymfe.org/documents/index.html" target="_blank" rel="noopener">https://yapi.ymfe.org/documents/index.html</a></li><li>在线Demo：<a href="http://yapi.demo.qunar.com/" target="_blank" rel="noopener">http://yapi.demo.qunar.com/</a></li><li>最新版本：<a href="https://github.com/YMFE/yapi/releases" target="_blank" rel="noopener">https://github.com/YMFE/yapi/releases</a></li><li>版本记录：<a href="https://yapi.ymfe.org/documents/CHANGELOG.html" target="_blank" rel="noopener">https://yapi.ymfe.org/documents/CHANGELOG.html</a><a id="more"></a>    <h1 id="创建镜像"><a href="#创建镜像" class="headerlink" title="创建镜像"></a>创建镜像</h1></li><li>编写<code>Dockerfile</code>文件，文件太长，直接查看<a href="https://github.com/sunhao-java/docker-templates/blob/master/yapi/Dockerfile" target="_blank" rel="noopener">Github</a>上的文件</li><li>下载好<code>yapi-1.4.4.tar.gz</code></li><li>可以直接先构建镜像，或者使用<code>docker-compose</code>来构建，推荐使用后者</li></ol><h1 id="创建docker-compose-yml文件"><a href="#创建docker-compose-yml文件" class="headerlink" title="创建docker-compose.yml文件"></a>创建<code>docker-compose.yml</code>文件</h1><ol><li>文件太长了，请直接查看<a href="https://github.com/sunhao-java/docker-templates/blob/master/yapi/docker-compose.yml" target="_blank" rel="noopener">Github</a>上的文件</li><li>可以自定义几处用户名密码，下面的<code>YApi</code>配置文件会使用到</li></ol><h1 id="创建YApi的配置文件"><a href="#创建YApi的配置文件" class="headerlink" title="创建YApi的配置文件"></a>创建<code>YApi</code>的配置文件</h1><ol><li><p><code>mkdir config</code></p></li><li><p><code>vim config.json</code></p><pre><code> {   &quot;port&quot;: &quot;3000&quot;,   &quot;adminAccount&quot;: &quot;sunhao@lodsve.com&quot;,   &quot;db&quot;: {     &quot;servername&quot;: &quot;yapi-mongo&quot;,     &quot;port&quot;: 27017,     &quot;DATABASE&quot;: &quot;yapi&quot;,     &quot;user&quot;: &quot;admin&quot;,     &quot;pass&quot;: &quot;admin123&quot;,     &quot;authSource&quot;: &quot;admin&quot;   },   &quot;mail&quot;: {     &quot;enable&quot;: true,     &quot;host&quot;: &quot;smtp.qiye.aliyun.com&quot;,     &quot;port&quot;: 25,     &quot;from&quot;: &quot;sunhao@lodsve.com&quot;,     &quot;auth&quot;: {       &quot;user&quot;: &quot;sunhao@lodsve.com&quot;,       &quot;pass&quot;: &quot;xxxxxxxxx&quot;     }   } }</code></pre></li></ol><h1 id="启动YApi"><a href="#启动YApi" class="headerlink" title="启动YApi"></a>启动<code>YApi</code></h1><ol><li><code>docker-compose up -d</code></li></ol><h1 id="访问地址："><a href="#访问地址：" class="headerlink" title="访问地址："></a>访问地址：</h1><ol><li><p>YApi</p><pre><code> url: http://your_yapi_server_ip:3000 # 用户名在yapi的配置文件config.json中设置的，密码是默认初始密码 username: sunhao@lodsve.com password: ymfe.org</code></pre></li><li><p>mongo-express        </p><pre><code> url: http://your_yapi_server_ip:8081 # 用户名密码在docker-compose.yml中设置的 username: root password: root123</code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> yapi </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搭建Harbor企业级docker仓库</title>
      <link href="/2019/01/18/yun-wei/da-jian-harbor-qi-ye-ji-docker-cang-ku/"/>
      <url>/2019/01/18/yun-wei/da-jian-harbor-qi-ye-ji-docker-cang-ku/</url>
      
        <content type="html"><![CDATA[<h1 id="下载harbor安装文件"><a href="#下载harbor安装文件" class="headerlink" title="下载harbor安装文件"></a>下载harbor安装文件</h1><ol><li><p><a href="https://storage.googleapis.com/harbor-releases/release-1.7.0/harbor-online-installer-v1.7.1.tgz" target="_blank" rel="noopener" title="harbor-online-installer-v1.7.1.tgz">harbor-online-installer-v1.7.1.tgz</a></p></li><li><p>放置在<code>/opt</code>目录下</p></li><li><p>解压</p></li><li><p><code>cd /opt/harbor</code></p><a id="more"></a><h1 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h1></li><li><p>修改配置文件<code>/opt/harbor/harbor.cfg</code></p><pre><code> vim /opt/harbor/harbor.cfg # 主机名，后面用这个地址来访问 hostname = harbor.lodsve.com # 邮箱配置 email_server = smtp.qiye.aliyun.com email_server_port = 25 email_username = harbor@lodsve.com email_password = XXXXXXXXXXX email_from = Harbor &lt;harbor@lodsve.com&gt; email_ssl = false email_insecure = false # 禁止用户注册 self_registration = off # 设置只有管理员可以创建项目 project_creation_restriction = adminonly</code></pre></li></ol><h1 id="执行安装脚本"><a href="#执行安装脚本" class="headerlink" title="执行安装脚本"></a>执行安装脚本</h1><pre><code>/opt/harbor/install.sh</code></pre><p>执行过程：</p><pre><code>[Step 0]: checking installation environment ...Note: docker version: 18.09.0Note: docker-compose version: 1.23.1[Step 1]: preparing environment ...Generated and saved secret to file: /data/secretkeyGenerated configuration file: ./common/config/nginx/nginx.confGenerated configuration file: ./common/config/adminserver/envGenerated configuration file: ./common/config/core/envGenerated configuration file: ./common/config/registry/config.ymlGenerated configuration file: ./common/config/db/envGenerated configuration file: ./common/config/jobservice/envGenerated configuration file: ./common/config/jobservice/config.ymlGenerated configuration file: ./common/config/log/logrotate.confGenerated configuration file: ./common/config/registryctl/envGenerated configuration file: ./common/config/core/app.confGenerated certificate, key file: ./common/config/core/private_key.pem, cert file: ./common/config/registry/root.crtThe configuration files are ready, please use docker-compose to start the service.[Step 2]: checking existing instance of Harbor ...[Step 3]: starting Harbor ...Creating network &quot;harbor_harbor&quot; with the default driverPulling log (goharbor/harbor-log:v1.7.1)...v1.7.1: Pulling from goharbor/harbor-log321a8da5ee1f: Pull completee58cb02d4a79: Pull completeb1addcae27cf: Pull complete0add5fe71c61: Pull complete701d7cb4751e: Pull completeae052802ba8f: Pull complete474572a6c946: Pull completePulling registry (goharbor/registry-photon:v2.6.2-v1.7.1)...v2.6.2-v1.7.1: Pulling from goharbor/registry-photon321a8da5ee1f: Already exists427e471dc5bb: Pull complete79d644c380a9: Pull completed1ee69ba441f: Pull complete13ee399ae5e6: Pull complete52da6cf3d71f: Pull completee6dfe8d3336d: Pull complete2261e5dd4591: Pull completePulling registryctl (goharbor/harbor-registryctl:v1.7.1)...v1.7.1: Pulling from goharbor/harbor-registryctl321a8da5ee1f: Already exists60ab2a220157: Pull complete685cb36a4aa6: Pull complete6ab9cbb7c05b: Pull completed66f51b51c32: Pull complete152d893b8817: Pull completePulling postgresql (goharbor/harbor-db:v1.7.1)...v1.7.1: Pulling from goharbor/harbor-db321a8da5ee1f: Already exists3b62caa7690c: Pull complete0c0b8f8af809: Pull complete68db7c777555: Pull complete810390407c8c: Pull completed99f5e0b551e: Pull complete0dedd5da1f5d: Pull complete5e156cfb841f: Pull complete0433d5b9e1ad: Pull completePulling adminserver (goharbor/harbor-adminserver:v1.7.1)...v1.7.1: Pulling from goharbor/harbor-adminserver321a8da5ee1f: Already exists3235adc5dfba: Pull complete36df358268ae: Pull completef07cf44733c3: Pull complete153223fc88f2: Pull completePulling core (goharbor/harbor-core:v1.7.1)...v1.7.1: Pulling from goharbor/harbor-core321a8da5ee1f: Already exists95d433145bab: Pull complete49d3e2a9635a: Pull complete6a4cbc768efe: Pull complete7e7d30cebeb5: Pull completePulling portal (goharbor/harbor-portal:v1.7.1)...v1.7.1: Pulling from goharbor/harbor-portal321a8da5ee1f: Already exists0c2edbea17ee: Pull complete35f0e6ee2803: Pull complete815b36cabaa4: Pull completePulling redis (goharbor/redis-photon:v1.7.1)...v1.7.1: Pulling from goharbor/redis-photon321a8da5ee1f: Already existse37a237fdce1: Pull completea533db83c439: Pull complete60f1956f70fa: Pull completec7eecf8b746b: Pull completePulling jobservice (goharbor/harbor-jobservice:v1.7.1)...v1.7.1: Pulling from goharbor/harbor-jobservice321a8da5ee1f: Already exists4809bd624b7e: Pull complete889c696c8f56: Pull complete72d181b0302b: Pull completePulling proxy (goharbor/nginx-photon:v1.7.1)...v1.7.1: Pulling from goharbor/nginx-photon321a8da5ee1f: Already exists044755eb163c: Pull completeDigest: sha256:9ec5644c667e87bf051e581ce74b2933d3ed469b27862534ba60ccf17b4ff57aStatus: Downloaded newer image for vmware/nginx-photon:1.11.13Creating harbor-log ... doneCreating harbor-log ... doneCreating harbor-db ... doneCreating harbor-adminserver ... doneCreating registry ... doneCreating harbor-db ... doneCreating registry ... doneCreating registry ... doneCreating harbor-ui ... doneCreating harbor-ui ... doneCreating nginx ... doneCreating harbor-jobservice ... doneCreating harbor-jobservice ... doneCreating nginx ... done✔ ----Harbor has been installed and started successfully.----Now you should be able to visit the admin portal at http://harbor.lodsve.com. For more details, please visit https://github.com/vmware/harbor .</code></pre><h1 id="Harbor启动和停止"><a href="#Harbor启动和停止" class="headerlink" title="Harbor启动和停止"></a>Harbor启动和停止</h1><ol><li><p>Harbor 的日常运维管理是通过docker-compose来完成的，Harbor本身有多个服务进程，都放在docker容器之中运行，我们可以通过docker ps命令查看。</p><pre><code> [root@localhost harbor]# docker ps CONTAINER ID        IMAGE                                        COMMAND                  CREATED             STATUS                 PORTS                                                                              NAMES 3c69bd72f85d        goharbor/nginx-photon:v1.7.1                 &quot;nginx -g &#39;daemon of…&quot;   6 hours ago         Up 6 hours (healthy)   0.0.0.0:80-&gt;80/tcp, 0.0.0.0:443-&gt;443/tcp, 0.0.0.0:4443-&gt;4443/tcp                   nginx a88dcf21cd32        goharbor/harbor-portal:v1.7.1                &quot;nginx -g &#39;daemon of…&quot;   6 hours ago         Up 6 hours (healthy)   80/tcp                                                                             harbor-portal 92523370eeb3        goharbor/harbor-jobservice:v1.7.1            &quot;/harbor/start.sh&quot;       6 hours ago         Up 6 hours                                                                                                harbor-jobservice 3963d6efe445        goharbor/harbor-core:v1.7.1                  &quot;/harbor/start.sh&quot;       6 hours ago         Up 6 hours (healthy)                                                                                      harbor-core cb96daa8cfd8        goharbor/harbor-registryctl:v1.7.1           &quot;/harbor/start.sh&quot;       6 hours ago         Up 6 hours (healthy)                                                                                      registryctl e0c704663b1b        goharbor/harbor-db:v1.7.1                    &quot;/entrypoint.sh post…&quot;   6 hours ago         Up 6 hours (healthy)   5432/tcp                                                                           harbor-db 277d48e55a01        goharbor/redis-photon:v1.7.1                 &quot;docker-entrypoint.s…&quot;   6 hours ago         Up 6 hours             6379/tcp                                                                           redis a1881948c75d        goharbor/registry-photon:v2.6.2-v1.7.1       &quot;/entrypoint.sh /etc…&quot;   6 hours ago         Up 6 hours (healthy)   5000/tcp                                                                           registry 1a412be89d98        goharbor/harbor-adminserver:v1.7.1           &quot;/harbor/start.sh&quot;       6 hours ago         Up 6 hours (healthy)                                                                                      harbor-adminserver 5a162a3252a8        goharbor/harbor-log:v1.7.1                   &quot;/bin/sh -c /usr/loc…&quot;   6 hours ago         Up 6 hours (healthy)   127.0.0.1:1514-&gt;10514/tcp                                                          harbor-log</code></pre></li><li><p>或者使用docker-compose 来查看</p><pre><code> [root@localhost harbor]# cd /opt/harbor/ [root@localhost harbor]# docker-compose ps        Name                     Command                  State                                    Ports                               ------------------------------------------------------------------------------------------------------------------------------------- harbor-adminserver   /harbor/start.sh                 Up (healthy)                                                                    harbor-core          /harbor/start.sh                 Up (healthy)                                                                    harbor-db            /entrypoint.sh postgres          Up (healthy)   5432/tcp                                                         harbor-jobservice    /harbor/start.sh                 Up                                                                              harbor-log           /bin/sh -c /usr/local/bin/ ...   Up (healthy)   127.0.0.1:1514-&gt;10514/tcp                                        harbor-portal        nginx -g daemon off;             Up (healthy)   80/tcp                                                           nginx                nginx -g daemon off;             Up (healthy)   0.0.0.0:443-&gt;443/tcp, 0.0.0.0:4443-&gt;4443/tcp, 0.0.0.0:80-&gt;80/tcp redis                docker-entrypoint.sh redis ...   Up             6379/tcp                                                         registry             /entrypoint.sh /etc/regist ...   Up (healthy)   5000/tcp                                                         registryctl          /harbor/start.sh                 Up (healthy)                </code></pre></li><li><p>Harbor的启动和停止</p><pre><code> 启动Harbor # docker-compose start 停止Harbor # docker-comose stop 重启Harbor # docker-compose restart             </code></pre></li></ol><h1 id="访问测试"><a href="#访问测试" class="headerlink" title="访问测试"></a>访问测试</h1><ol><li><p>配置hosts</p><pre><code> 10.20.2.152     harbor.lodsve.com </code></pre></li><li><p>访问<code>http://harbor.lodsve.com</code>                </p></li><li><p>默认用户名密码：<code>admin</code>/<code>Harbor12345</code></p></li></ol><h1 id="测试上传和下载镜像"><a href="#测试上传和下载镜像" class="headerlink" title="测试上传和下载镜像"></a>测试上传和下载镜像</h1><ol><li><p>修改各docker client配置</p><pre><code> [root@localhost harbor]# vim /usr/lib/systemd/system/docker.service ExecStart=/usr/bin/dockerd --insecure-registry harbor.lodsve.com systemctl daemon-reload systemctl  restart docker</code></pre></li><li><p>或者创建<code>/etc/docker/daemon.json</code>文件，在文件中指定仓库地址</p><pre><code> [root@localhost harbor]# sudo tee /etc/docker/daemon.json &lt;&lt;-&#39;EOF&#39; {   &quot;insecure-registries&quot;: [&quot;harbor.lodsve.com&quot;] } EOF sudo systemctl daemon-reload sudo systemctl restart docker</code></pre></li><li><p>创建Dockerfile</p><pre><code> [root@localhost harbor]# vim Dockerfile  FROM centos:centos7.1.1503 ENV TZ &quot;Asia/Shanghai&quot;</code></pre></li><li><p>创建镜像</p><pre><code> [root@localhost harbor]# docker build -t harbor.lodsve.com/library/centos7.1:0.1 .</code></pre></li><li><p>把镜像push到Harbor</p><pre><code> [root@localhost harbor]# docker login harbor.lodsve.com [root@localhost harbor]# docker push harbor.lodsve.com/library/centos7.1:0.1</code></pre></li></ol><h1 id="TODO-Harbor配置TLS证书"><a href="#TODO-Harbor配置TLS证书" class="headerlink" title="[TODO]Harbor配置TLS证书"></a>[TODO]Harbor配置TLS证书</h1>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> DevOps </tag>
            
            <tag> k8s </tag>
            
            <tag> Harbor </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安装kubernetes</title>
      <link href="/2019/01/10/yun-wei/an-zhuang-kubernetes/"/>
      <url>/2019/01/10/yun-wei/an-zhuang-kubernetes/</url>
      
        <content type="html"><![CDATA[<ol><li><p>安装好3台虚拟机</p><ol><li>10.20.2.194[k8s-master]</li><li>10.20.2.44[k8s-node1]</li><li>10.20.2.37[k8s-node2]<a id="more"></a></li></ol></li><li><p>基本配置，master和各个node都需要配置</p><ul><li><p>修改hostname</p><pre><code>  vim /etc/hostname   hostnamectl set-hostname k8s-master|k8s-node1|k8s-node2|...|k8s-noden</code></pre></li><li><p>关闭selinux</p><pre><code>  vi /etc/sysconfig/selinux  SELINUX=disabled</code></pre></li><li><p>直接关闭防火墙</p><pre><code>  systemctl stop firewalld.service #停止firewall  systemctl disable firewalld.service #禁止firewall开机启动</code></pre></li><li><p>永久关闭swap—避免重启服务器后kubectl服务无法启动的问题</p><pre><code>  在/etc/fstab 里面找的 带有swap的一行，把他注释或者删除都可以，注释安全些。  vim /etc/fstab  修改后保存退出</code></pre></li><li><p>关闭swap命令</p><pre><code>  swapoff -a</code></pre></li><li><p>安装docker-ce仓库</p><pre><code>  sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo</code></pre></li><li><p>安装docker相关，并且版本号为17.12.0.ce，匹配使用的kubernetes </p><pre><code>  yum install net-tools nfs-utils telnet vim  docker-ce-17.12.0.ce-1.el7.centos -y  systemctl start docker &amp;&amp; systemctl enable docker</code></pre></li><li><p>验证</p><pre><code>  [root@k8s-master shell]# docker version  Client:   Version:    17.12.0-ce   API version:    1.35   Go version:    go1.9.2   Git commit:    c97c6d6   Built:    Wed Dec 27 20:10:14 2017   OS/Arch:    linux/amd64  Server:   Engine:    Version:    17.12.0-ce    API version:    1.35 (minimum version 1.12)    Go version:    go1.9.2    Git commit:    c97c6d6    Built:    Wed Dec 27 20:12:46 2017    OS/Arch:    linux/amd64    Experimental:    false</code></pre></li><li><p>上传所需要的kubernetes文件，到/opt下，并解压</p></li></ul></li><li><p>master上执行（到上传的kubernetes文件解压后的文件夹第一层中）</p><pre><code> cd shell &amp;&amp; sh init.sh &amp;&amp; sh master.sh</code></pre><ul><li>一般来说会成功的</li><li>继续执行以下命令<pre><code>  mkdir -p $HOME/.kube  sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config  sudo chown $(id -u):$(id -g) $HOME/.kube/config</code></pre></li><li>记住安装完输出的一条命令：<pre><code>  kubeadm join 10.20.2.194:6443 --token xie4h6.ariunlewb0qypf5v --discovery-token-ca-cert-hash sha256:4e9c3197ccf30d47cdf70afb975b8b7d0d0a77630a26c1fcd673c49c8739e143</code></pre></li><li>至此，master节点安装完成！</li></ul></li><li><p>在每一个node节点上执行（到上传的kubernetes文件解压后的文件夹第一层中）</p><pre><code> cd shell &amp;&amp; sh init.sh</code></pre><ul><li>一般来说会成功的</li><li>继续执行之前在master节点得到的join命令<pre><code>  kubeadm join 10.20.2.194:6443 --token xie4h6.ariunlewb0qypf5v --discovery-token-ca-cert-hash sha256:4e9c3197ccf30d47cdf70afb975b8b7d0d0a77630a26c1fcd673c49c8739e143</code></pre></li><li>完事之后，到master节点上执行kubectl get nodes，即可看到已注册的node节点<pre><code>  [root@k8s-master shell]# kubectl get nodes  NAME         STATUS     ROLES     AGE       VERSION  k8s-master   Ready      master    7m        v1.11.3  k8s-node1    Ready      &lt;none&gt;    30s       v1.11.3  k8s-node2    Ready      &lt;none&gt;    4s        v1.11.3</code></pre></li></ul></li><li><p>至此整个集群搭建完毕</p></li><li><p>使用https访问master的32000端口，使用令牌的方式登录</p><pre><code> https://10.20.2.194:32000</code></pre></li><li><p>为dashboard创建用户，并生成令牌 </p><ul><li><p>创建dashboard管理用户</p><pre><code>  kubectl create serviceaccount dashboard-admin -n kube-system</code></pre></li><li><p>绑定用户为集群管理用户</p><pre><code>  kubectl create clusterrolebinding dashboard-cluster-admin --clusterrole=cluster-admin --serviceaccount=kube-system:dashboard-admin</code></pre></li><li><p>获取tocken</p><pre><code>  kubectl describe secret -n kube-system dashboard-admin</code></pre></li><li><p>效果如下：</p><pre><code>  [root@k8s-master dashboard]# kubectl create serviceaccount dashboard-admin -n kube-system  serviceaccount/dashboard-admin created  [root@k8s-master dashboard]# kubectl create clusterrolebinding dashboard-cluster-admin --clusterrole=cluster-admin --serviceaccount=kube-system:dashboard-admin  clusterrolebinding.rbac.authorization.k8s.io/dashboard-cluster-admin created  [root@k8s-master dashboard]# kubectl describe secret -n kube-system dashboard-admin-token-l7kpn  Error from server (NotFound): secrets &quot;dashboard-admin-token-l7kpn&quot; not found  [root@k8s-master dashboard]# kubectl describe secret -n kube-system dashboard-admin  Name:         dashboard-admin-token-ltcr7  Namespace:    kube-system  Labels:       &lt;none&gt;  Annotations:  kubernetes.io/service-account.name=dashboard-admin                kubernetes.io/service-account.uid=002635bb-1106-11e9-a723-000c29023ca2  Type:  kubernetes.io/service-account-token  Data  ====  ca.crt:     1025 bytes  namespace:  11 bytes  token:      eyJhbGciOiJSUzI1NiIsImtpZCI6IiJ9.eyJpc3MiOiJrdWJlcm5ldGVzL3NlcnZpY2VhY2NvdW50Iiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9uYW1lc3BhY2UiOiJrdWJlLXN5c3RlbSIsImt1YmVybmV0ZXMuaW8vc2VydmljZWFjY291bnQvc2VjcmV0Lm5hbWUiOiJkYXNoYm9hcmQtYWRtaW4tdG9rZW4tbHRjcjciLCJrdWJlcm5ldGVzLmlvL3NlcnZpY2VhY2NvdW50L3NlcnZpY2UtYWNjb3VudC5uYW1lIjoiZGFzaGJvYXJkLWFkbWluIiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9zZXJ2aWNlLWFjY291bnQudWlkIjoiMDAyNjM1YmItMTEwNi0xMWU5LWE3MjMtMDAwYzI5MDIzY2EyIiwic3ViIjoic3lzdGVtOnNlcnZpY2VhY2NvdW50Omt1YmUtc3lzdGVtOmRhc2hib2FyZC1hZG1pbiJ9.FzeJOWlH5ugUDqPUErLWfbW_vqq-3wuBeY77v74Bm6Wl4a1Fv_2pMJoB7mQomVfvXegmg6_ISvrrm0mJ4f2DZC8SSUTMDEDLhgnrLAdHeuLJ82ZX04Oh7Pu9uFEVhHJc2rHBWX6tqyQ-rVLyGJsxM7R7L0FntXZ25uUWujwktegRzRXcMG30tnopsEQTx1fzb_47IygXRbGoiy2p1mGpOHlElqoGRvy6le5eLl38CPpuxQJbRUWFbpLsQV1Umcy4WPy1aifD2_q-l81eSRi4D0oxM1yuPksEq3ZdaYN4SYao1zdx_8D_CQwzESZ9-w4njGVbT5lkQbL4xkN2X4pP7g</code></pre></li><li><p>使用上面的token登录即可 </p></li></ul></li><li><p>忘记node节点join到master节点的命令怎么办？</p><ul><li>基本命令<pre><code>  kubeadm join --token &lt;token&gt; &lt;master-ip&gt;:&lt;master-port&gt; --discovery-token-ca-cert-hash sha256:&lt;hash&gt;</code></pre><ol><li>&lt;master-ip&gt;:&lt;master-port&gt; ，本文这里对应得是10.20.2.194:6443</li><li>token，一般token两天就过期了，如果过期了你需要重新创建（查看token命令是kubeadm token list，创建token命令是kubeadm token create)<pre><code> [root@k8s-master ~]# kubeadm token list TOKEN                     TTL       EXPIRES                     USAGES                   DESCRIPTION   EXTRA GROUPS xie4h6.ariunlewb0qypf5v   23h       2019-01-07T00:05:01+08:00   authentication,signing   &lt;none&gt;        system:bootstrappers:kubeadm:default-node-token [root@k8s-master ~]# kubeadm token create 5w6qwh.8n0ektfrjdct3ib4</code></pre></li><li>–discovery-token-ca-cert-hash，通过如下命令就可以得到<pre><code> [root@k8s-master ~]# openssl x509 -pubkey -in /etc/kubernetes/pki/ca.crt | openssl rsa -pubin -outform der 2&gt;/dev/null | openssl dgst -sha256 -hex | sed &#39;s/^.* //&#39; 4e9c3197ccf30d47cdf70afb975b8b7d0d0a77630a26c1fcd673c49c8739e143</code></pre></li><li>这样就可以组成join命令了 </li></ol></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> DevOps </tag>
            
            <tag> k8s </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>通过Travis来自动构建博客</title>
      <link href="/2018/12/13/gong-ju/build-blog-on-travis/"/>
      <url>/2018/12/13/gong-ju/build-blog-on-travis/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文基于熟练搭建基于github+hexo搭建博客的基础上，并且对github简单操作，并且会使用通过ssh的方式提交代码到github上。<br>PS：如果你只有Windows电脑，那请放弃！或者选择使用Linux、macOS系统!</p></blockquote><a id="more"></a><h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><ol><li>通过github账号登录Travis</li><li>并且启用已经在github上创建好的博客项目，如下图<br><img src="/imgs/build_blog_by_travis/1.png" alt=""></li><li>点击右侧的<code>Setting</code>，按下图配置（红框处，暂时可以不管）<br><img src="/imgs/build_blog_by_travis/2.png" alt=""></li></ol><h1 id="修改原来的博客项目"><a href="#修改原来的博客项目" class="headerlink" title="修改原来的博客项目"></a>修改原来的博客项目</h1><ol><li>在根目录增加<code>.travis.yml</code>文件和<code>.travis</code>文件夹</li><li>修改<code>.travis.yml</code>文件，内容如下<pre><code> language: node_js node_js: stable install:   - npm install script:   - hexo d -g</code></pre></li><li>我们用<code>hexo deploy</code>去发布博客，会发现Travis后台提示说没有权限</li><li>这是因为我们用<code>git@github.com:[Your name]/[Your project].git</code>的方式去拉取代码的，并且在hexo的配置文件中，我们也是这样配置使用ssh方式拉取、推送代码的</li><li>而Travis环境中没有对应的ssh key，所以不能推送代码。</li></ol><h1 id="为Travis创建SSH"><a href="#为Travis创建SSH" class="headerlink" title="为Travis创建SSH"></a>为Travis创建SSH</h1><ol><li><p>首先使用你已经生成好的ssh key私钥/公钥文件</p></li><li><p>将公钥上传到github上</p></li><li><p>将秘钥复制到博客目录下（有.git文件夹的那一层），并改名为<code>id_rsa_github</code>[随意]</p></li><li><p>安装Travis Client</p></li><li><p>首先确保已经安装了Ruby，并且大于等于2.0.0版本</p><pre><code> [sunhao@sunhaode-MacBook-Pro blog]$ ruby -v ruby 2.3.7p456 (2018-03-28 revision 63024) [universal.x86_64-darwin18]</code></pre></li><li><p>安装Travis Client</p><pre><code> # 如果是Mac或者Linux，需要加sudo gem install travis</code></pre></li><li><p>简称是否正确安装</p><pre><code> [sunhao@sunhaode-MacBook-Pro blog]$ travis version 1.8.9</code></pre></li><li><p>开始加密SSH key</p><pre><code> # 如果是github项目，先用travis login登录，如图</code></pre><p><img src="/imgs/build_blog_by_travis/3.png" alt=""></p><pre><code> # 通过命令travis encrypt-file id_rsa_github -add加密私钥 [sunhao@sunhaode-MacBook-Pro blog_hexo]$ travis encrypt-file id_rsa_github -add encrypting id_rsa_github for sunhao-java/blog_hexo storing result as id_rsa_github.enc storing secure env variables for decryption Make sure to add id_rsa_github.enc to the git repository. Make sure not to add id_rsa_github to the git repository. Commit all changes to your .travis.yml.</code></pre></li><li><p>这个时候，Travis会自动把一些参数上传到Travis的网站上了，就是第二张图展示的<code>暂时不需要关注的红框内容</code>，记住前面的key，下文需要用到</p></li><li><p>然后复制生成的<code>enc</code>文件到<code>.travis</code>文件夹下</p></li><li><p>并且删除原来的<code>id_rsa_github</code>文件</p></li></ol><h1 id="修改-travis-yml"><a href="#修改-travis-yml" class="headerlink" title="修改.travis.yml"></a>修改<code>.travis.yml</code></h1><ol><li>修改前面创建的<code>.travis.yml</code>文件</li><li>这个文件里有可能有一段话，大概如下，可以删掉，是因为前面使用了–add参数<pre><code> openssl aes-256-cbc -K $encrypted_65cc9ea56965_key -iv $encrypted_65cc9ea56965_iv -in .travis/id_rsa_github.enc -out ~/.ssh/id_rsa_github -d</code></pre></li><li>在这个文件的末尾加上如下的命令：<pre><code> before_install:   - openssl aes-256-cbc -K $encrypted_65cc9ea56965_key -iv $encrypted_65cc9ea56965_iv   -in .travis/id_rsa_github.enc -out ~/.ssh/id_rsa_github -d   - chmod 600 ~/.ssh/id_rsa_github   - eval $(ssh-agent)   - ssh-add ~/.ssh/id_rsa_github   - cp .travis/ssh_config ~/.ssh/config   - git config --global user.name \&#39;Your Name\&#39;   - git config --global user.email \&#39;Your Email\&#39;</code></pre></li><li>附上上面的<code>.travis/ssh_config</code>文件内容：<pre><code> Host github.com     User git     StrictHostKeyChecking no     IdentityFile ~/.ssh/id_rsa_github     IdentitiesOnly yes</code></pre></li></ol><h1 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h1><ol><li>至此，配置以及全部OK了</li><li>可以写一篇博客，并push到github上</li><li>然后到Travis的控制台观察,一次构建就被触发了</li><li>稍等片刻就可以在博客上看到你刚刚写的文章了</li></ol><h1 id="Tks，安利一下我写的东西"><a href="#Tks，安利一下我写的东西" class="headerlink" title="Tks，安利一下我写的东西"></a>Tks，安利一下我写的东西</h1><ul><li>博客：<a href="https://www.crazy-coder.cn/">https://www.crazy-coder.cn/</a></li><li>开源的代码：<a href="https://github.com/lodsve/lodsve-framework" target="_blank" rel="noopener">https://github.com/lodsve/lodsve-framework</a></li><li>欢迎提Issue和PR</li></ul>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 站务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring-cloud各组件</title>
      <link href="/2018/09/04/hou-duan/spring-cloud-components/"/>
      <url>/2018/09/04/hou-duan/spring-cloud-components/</url>
      
        <content type="html"><![CDATA[<h1 id="spring-cloud各组件"><a href="#spring-cloud各组件" class="headerlink" title="spring-cloud各组件"></a>spring-cloud各组件</h1><a id="more"></a><ol><li><code>Ribbon</code>，客户端负载均衡，特性有区域亲和、重试机制。</li><li><code>Eureka</code>，服务注册中心，特性有失效剔除、服务保护。</li><li><code>Hystrix</code>，客户端容错保护，特性有服务降级、服务熔断、请求缓存、请求合并、依赖隔离。</li><li><code>Dashboard</code>，<code>Hystrix</code>仪表盘，监控集群模式和单点模式，其中集群模式需要收集器<code>Turbine</code>配合。</li><li><code>Feign</code>，声明式服务调用，本质上就是<code>Ribbon+Hystrix</code></li><li><code>Zuul</code>，API服务网关，功能有路由分发和过滤</li><li><code>Config</code>，分布式配置中心，支持本地仓库、SVN、Git、Jar包内配置等模式，</li><li><code>Bus</code>，消息总线，配合Config仓库修改的一种Stream实现，</li><li><code>Stream</code>，消息驱动，有Sink、Source、Processor三种通道，特性有订阅发布、消费组、消息分区。</li><li><code>Sleuth</code>，分布式服务追踪，需要搞清楚TraceID和SpanID以及抽样，如何与ELK整合。</li></ol><p>独挑大梁，独自启动不需要依赖其它组件。</p><blockquote><ol><li><code>Eureka</code></li><li><code>Dashboard</code></li><li><code>Zuul</code></li><li><code>Config</code></li></ol></blockquote><h1 id="含义、依赖"><a href="#含义、依赖" class="headerlink" title="含义、依赖"></a>含义、依赖</h1><ol><li><code>Eureka</code>和<code>Ribbon</code>，是最基础的组件，一个注册服务，一个消费服务。</li><li><code>Hystrix</code>为了优化<code>Ribbon</code>、防止整个微服务架构因为某个服务节点的问题导致崩溃，是个<strong>保险丝</strong>的作用。</li><li><code>Dashboard</code>给<code>Hystrix</code>统计和展示用的，而且监控服务节点的整体压力和健康情况。</li><li><code>Turbine</code>是集群收集器，服务于<code>Dashboard</code>的。</li><li><code>Feign</code>是方便我们程序员些更优美的代码的。</li><li><code>Zuul</code>是加在整个微服务最前沿的防火墙和代理器，隐藏微服务结点IP端口信息，加强安全保护的。</li><li><code>Config</code>是为了解决所有微服务各自维护各自的配置，设置一个同意的配置中心，方便修改配置的。</li><li><code>Bus</code>是因为<code>Config</code>修改完配置后各个结点都要refresh才能生效实在太麻烦，所以交给bus来通知服务节点刷新配置的。</li><li><code>Stream</code>是为了简化研发人员对MQ使用的复杂度，弱化MQ的差异性，达到程序和MQ松耦合。</li><li><code>Sleuth</code>是因为单次请求在微服务节点中跳转无法追溯，解决任务链日志追踪问题的。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
            <tag> spring-cloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>keepalived + nginx 实现高可用集群方案</title>
      <link href="/2017/06/05/zhong-jian-jian/nginx-keepalived-cluster/"/>
      <url>/2017/06/05/zhong-jian-jian/nginx-keepalived-cluster/</url>
      
        <content type="html"><![CDATA[<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ol><li>两台虚拟机如：<ul><li>10.211.55.8</li><li>10.211.55.10</li></ul></li><li>准备安装文件<ul><li>nginx-1.13.1.tar.gz</li><li>pcre-8.36.zip</li><li>keepalived-1.2.22.tar.gz</li></ul></li></ol><a id="more"></a><h2 id="安装nginx"><a href="#安装nginx" class="headerlink" title="安装nginx"></a>安装<code>nginx</code></h2><ol><li><p>参考<a href="http://www.crazy-coder.cn/2016/03/15/linux_ubuntu_install_nginx/">安装Linux</a>一文，在两台服务器安装nginx</p><p> <code>10.211.55.8</code> 称为 <code>nginx1</code><br/><br> <code>10.211.55.10</code> 称为 <code>nginx2</code></p></li></ol><h2 id="安装keepalived"><a href="#安装keepalived" class="headerlink" title="安装keepalived"></a>安装<code>keepalived</code></h2><ol><li><p>解压文件</p><pre><code> cd /opt/software tar -zxvf keepalived-1.2.22.tar.gz cd keepalived-1.2.22</code></pre></li><li><p>安装</p><pre><code> ./configure --prefix=/opt/keepalived make &amp;&amp; make install</code></pre></li><li><p>处理配置文件和可执行文件</p><pre><code> cp /opt/keepalived/etc/rc.d/init.d/keepalived /etc/init.d/ cp /opt/keepalived/etc/sysconfig/keepalived /etc/sysconfig/ mkdir /etc/keepalived cp /opt/keepalived/etc/keepalived/keepalived.conf /etc/keepalived ln -s /opt/keepalived/sbin/keepalived /usr/sbin/</code></pre></li><li><p>启动服务</p><pre><code> /etc/init.d/keepalived start</code></pre></li><li><p>按照相同的步骤在另一台服务器安装<code>keepalived</code></p></li></ol><h2 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h2><p><code>vim /etc/keepalived/keepalived.conf</code></p><pre><code>! Configuration File for keepalivedglobal_defs {   # keepalived 自带的邮件提醒需要开启 sendmail 服务。建议用独立的监控或第三方 SMTP,也可配置邮件发送   router_id 10.211.55.8}vrrp_script chk_nginx {    # 运行脚本，脚本内容下面有，就是起到一个nginx宕机以后，自动开启服务    script &quot;/opt/shell/nginx_check.sh&quot;    # 检测时间间隔    interval 2    # 如果条件成立的话，则权重 -20    weight -20}# 定义虚拟路由，VI_1 为虚拟路由的标示符，自己定义名称vrrp_instance VI_1 {    # 来决定主从(从：BACKUP)    state MASTER    # 绑定虚拟 IP 的网络接口，根据自己的机器填写    interface eth0    # 虚拟路由的 ID 号， 两个节点设置必须一样    virtual_router_id 121    # 填写本机ip    mcast_src_ip 10.211.55.10    # 节点优先级,主节点比从节点优先级高    priority 100    # 优先级高的设置 nopreempt 解决异常恢复后再次抢占的问题    nopreempt    # 组播信息发送间隔，两个节点设置必须一样，默认 1s    advert_int 1    authentication {        auth_type PASS        auth_pass 1111    }    # 将 track_script 块加入 instance 配置块    track_script {        #执行 Nginx 监控的服务        chk_nginx    }    virtual_ipaddress {        # 虚拟ip,也就是解决写死程序的ip怎么能切换的ip,也可扩展，用途广泛。可配置多个。        10.211.55.100    }}</code></pre><p>以上配置为主节点配置，从节点类似，有区别的已经标明。下面是监控服务脚本内容</p><pre><code>#!/bin/bashA=`ps -C nginx --no-header |wc -l`if [ $A -eq 0 ];then    /opt/nginx/sbin/nginx    sleep 2    if [ `ps -C nginx --no-header |wc -l` -eq 0 ];then        killall keepalived    fifi</code></pre><p>定义变量，此变量为检查nginx进程脚本，如果进程为0，则启动nginx服务，再次检查nginx服务，如果仍没启动 ，杀掉所有keepalived的进程。</p><h2 id="测试高可用"><a href="#测试高可用" class="headerlink" title="测试高可用"></a>测试高可用</h2><ol><li><p>打开浏览器，输入虚拟ip <code>10.211.55.100</code></p></li><li><p>显示的是<code>nginx1</code>的页面</p></li><li><p>此时可以停掉一台nginx服务器</p><pre><code> /opt/nginx/sbin/nginx -s stop</code></pre></li><li><p>这时候，单独访问这台服务器，发现还是可以的，也就是说，<code>keepalived</code>监控到<code>nginx</code>服务down掉了，然后自动重启这台机器了。</p></li><li><p>这时再停掉一台<code>keepalived</code>服务器</p><pre><code> /etc/init.d/keepalived stop</code></pre></li><li><p>刷新浏览器，显示的将是另外一台<code>nginx</code></p></li><li><p>这时就可以证明已经实现<strong><code>高可用</code></strong></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FastDFS之集群部署</title>
      <link href="/2017/06/05/zhong-jian-jian/install-fastdfs-cluster/"/>
      <url>/2017/06/05/zhong-jian-jian/install-fastdfs-cluster/</url>
      
        <content type="html"><![CDATA[<h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><ol><li>tracker：192.168.20.116</li><li>storage：<ul><li>group1：192.168.20.117</li><li>group2：192.168.20.118</li></ul></li><li>准备好安装文件<ul><li>fastdfs-5.05.zip</li><li>fastdfs-nginx-module.zip</li><li>libfastcommon-1.0.7.zip</li><li>nginx-1.8.1.tar.gz</li><li>ngx_cache_purge-2.3.tar.gz</li><li>pcre-8.36.zip</li><li>zlib-1.2.8.tar.gz</li></ul></li></ol><a id="more"></a><h2 id="安装tracker"><a href="#安装tracker" class="headerlink" title="安装tracker"></a><span id="install_tracker">安装tracker</span></h2><ol><li><p>安装依赖libfastcommon</p><pre><code> unzip libfastcommon-1.0.7.zip cd libfastcommon-1.0.7 ./make.sh  ./make.sh  install</code></pre></li><li><p>安装FastDFS</p><pre><code> unzip fastdfs-5.05.zip cd fastdfs-5.05 ./make.sh  ./make.sh install</code></pre><p> 默认安装目录：<code>/usr/bin</code></p><p> 配置文件在：<code>/etc/fdfs</code>，需要重命名吧<code>.sample</code>去掉</p></li><li><p>配置</p><p> 编辑配置文件目录下的<code>tracker.conf</code>，一般只需改动以下几个参数即可：</p><pre><code> disabled=false            #启用配置文件 port=22122                #设置tracker的端口号 base_path=/opt/fastdfs   #设置tracker的数据文件和日志目录（需预先创建） http.server_port=8080     #设置http端口号</code></pre></li><li><p>创建数据存储文件夹 </p><pre><code> mkdir /opt/fastdfs</code></pre></li><li><p>启动</p><pre><code> fdfs_trackerd /etc/fdfs/tracker.conf</code></pre></li><li><p>安装tracker代理nginx</p><p> 在tracker上安装的nginx主要为了提供http访问的反向代理、负载均衡以及缓存服务。</p><ol><li><p>安装nginx（具体参考<a href="http://www.crazy-coder.cn/2016/03/15/linux_ubuntu_install_nginx/">安装Nginx</a>）</p><pre><code> tar -zxvf nginx-1.8.1.tar.gz  tar -zxvf ngx_cache_purge-2.3.tar.gz  cd nginx-1.8.1 ./configure --prefix=/opt/nginx --add-module=/opt/software/ngx_cache_purge-2.3 --without-http_gzip_module make  make install</code></pre><p> 如果提示错误，可能缺少依赖的软件包，需先安装依赖包，再次运行./configure。nginx以及nginx cache purge插件模块安装完成，安装目录/opt/nginx。</p></li><li><p>配置nginx</p><pre><code> #user  nobody; worker_processes  1; error_log  logs/error.log  info; events {     worker_connections  1024; } http {     include       mime.types;     default_type  application/octet-stream;     #设置缓存参数     server_names_hash_bucket_size 128;     client_header_buffer_size 32k;     large_client_header_buffers 4 32k;     client_max_body_size 300m;     sendfile        on;     tcp_nopush     on;     proxy_redirect off;     proxy_set_header Host $http_host;     proxy_set_header X-Real-IP $remote_addr;     proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;     proxy_connect_timeout 90;     proxy_send_timeout 90;     proxy_read_timeout 90;     proxy_buffer_size 16k;     proxy_buffers 4 64k;     proxy_busy_buffers_size 128k;     proxy_temp_file_write_size 128k;     # 设置缓存存储路径、存储方式、分配内存大小、磁盘最大空间、缓存期限     proxy_cache_path /var/cache/nginx/proxy_cache levels=1:2 keys_zone=http-cache:500m max_size=10g inactive=30d;     proxy_temp_path /var/cache/nginx/proxy_cache/tmp;     keepalive_timeout  65;     #设置group服务器     upstream fdfs_group1 {         server 192.168.20.117:8090 weight=1 max_fails=2 fail_timeout=30s;     }     upstream fdfs_group2 {         server 192.168.20.118:8090 weight=1 max_fails=2 fail_timeout=30s;     }     server {         listen       80;         server_name  localhost;         charset utf-8;         location /group1/M00 {                 proxy_next_upstream http_502 http_504 error timeout invalid_header;                 proxy_cache http-cache;                 proxy_cache_valid  200 304 12h;                 proxy_cache_key $uri$is_args$args;                 proxy_pass http://fdfs_group1;                 expires 30d;         }         location /group2/M00 {                 proxy_next_upstream http_502 http_504 error timeout invalid_header;                 proxy_cache http-cache;                 proxy_cache_valid  200 304 12h;                 proxy_cache_key $uri$is_args$args;                 proxy_pass http://fdfs_group2;                 expires 30d;         }         #设置清除缓存的访问权限         location ~ /purge(/.*) {                 allow 127.0.0.1;                 allow 192.168.72.0/24;                 deny all;                 proxy_cache_purge http-cache  $1$is_args$args;         }     } }</code></pre><p> 创建缓存目录：/var/cache/nginx/proxy_cache/tmp</p></li><li><p>启动nginx</p><pre><code> /opt/nginx/sbin/nginx</code></pre></li></ol></li></ol><h2 id="安装storage"><a href="#安装storage" class="headerlink" title="安装storage"></a>安装storage</h2><ol><li><p>安装</p><p> 参考<a href="#install_tracker">安装tracker</a>前2步骤。</p></li><li><p>配置</p><p> 编辑配置文件目录下的storage.conf，只需改动以下几个参数即可：</p><pre><code> disabled=false     #启用配置文件 group_name=group1 #组名，根据实际情况修改 port=23000 #设置storage的端口号 base_path=/opt/fastdfs #设置storage的日志目录（需预先创建） store_path_count=1 #存储路径个数，需要和store_path个数匹配 store_path0=/opt/fastdfs#存储路径 tracker_server=192.168.20.116:22122#tracker服务器的IP地址和端口号 http.server_port=8080   #设置http端口号</code></pre></li><li><p>创建存储目录</p><pre><code> mkdir /opt/fastdfs</code></pre></li><li><p>运行</p><pre><code> fdfs_storaged /etc/fdfs/storage.conf</code></pre></li><li><p>按照同样的配置在<code>192.168.20.118</code>上创建<code>storage2</code>，做相应的调整（ip等）</p><p> 另外每个group中所有storage的端口号必须一致。</p></li><li><p>在storage上安装nginx</p><p> 在storage上安装的nginx主要为了提供http的访问服务，同时解决group中storage服务器的同步延迟问题。</p><ol><li><p>解压<code>fastdfs-nginx-module.zip</code>插件</p><pre><code> unzip  fastdfs-nginx-module.zip</code></pre></li><li><p>安装nginx（具体参考<a href="http://blog.crazy-coder.cn/2016/03/15/linux_ubuntu_install_nginx/" target="_blank" rel="noopener">安装Nginx</a>）</p><pre><code> tar -zxvf nginx-1.8.1.tar.gz  cd nginx-1.8.1 ./configure --prefix=/usr/local/nginx --add-module=../fastdfs-nginx-module/src --without-http_gzip_module make  make install</code></pre></li><li><p>配置</p><ul><li><p>配置FastDFS的nginx插件</p><p>  将FastDFS的nginx插件模块的配置文件copy到FastDFS配置文件目录</p><pre><code>  cp /opt/fastdfs-nginx-module/src/mod_fastdfs.conf /etc/fdfs/</code></pre><p>  编辑/etc/fdfs配置文件目录下的mod_fastdfs.conf，设置storage信息并保存。<br>一般只需改动以下几个参数即可：</p><pre><code>  base_path=/opt/fastdfs #保存日志目录  tracker_server=192.168.20.116:22122 #tracker服务器的IP地址以及端口号  storage_server_port=23000     #storage服务器的端口号  group_name=group1  #当前服务器的group名  url_have_group_name = true        #文件url中是否有group名  store_path_count=1                #存储路径个数，需要和store_path个数匹配  store_path0=/opt/fastdfs         #存储路径</code></pre><p>  在末尾增加2个组的具体信息：</p><pre><code>  [group1]  group_name=group1  storage_server_port=23000  store_path_count=1  store_path0=/opt/fastdfs  [group2]  group_name=group2  storage_server_port=23000  store_path_count=1  store_path0=/opt/fastdfs</code></pre></li><li><p>建立M00至存储目录的符号连接：</p><pre><code>  ln -s /opt/fastdfs/data /opt/fastdfs/data/M00</code></pre></li><li><p>配置nginx</p><pre><code>  vi nginx.conf  # 在server中添加如下location  location ~/group[1-3]/M00 {      root /home/fastdfs/data;      ngx_fastdfs_module;  }</code></pre></li><li><p>启动</p><pre><code>  /usr/local/nginx/sbin/nginx</code></pre></li></ul></li></ol></li></ol><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>配置/etc/fdfs/client.conf</p><pre><code>base_path=/opt/fastdfs #日志存放路径tracker_server=192.168.20.116:22122 #tracker服务器IP地址和端口号http.tracker_server_port=8080           #tracker服务器的http端口号</code></pre><p>通过fdfs_upload_file上传一个文件到FastDFS，程序会自动返回文件的URL</p><pre><code>[root@localhost /opt/]#fdfs_upload_file /etc/fdfs/client.conf test group1/M00/00/00/wKgUdVk1drmARcxsAAAOGgU8nEQ0713851</code></pre><p>然后使用浏览器访问，访问正常<code>http://192.168.20.116/group1/M00/00/00/wKgUdVk1drmARcxsAAAOGgU8nEQ0713851</code></p><h2 id="监控"><a href="#监控" class="headerlink" title="监控"></a>监控</h2><p>可以使用fdfs_monitor查看tracker和所有group的运行情况</p><pre><code>[root@localhost /opt/nginx/conf]#fdfs_monitor /etc/fdfs/client.conf   [2017-06-05 23:21:50] DEBUG - base_path=/opt/fastdfs, connect_timeout=30, network_timeout=60, tracker_server_count=1, anti_steal_token=0, anti_steal_secret_key length=0, use_connection_pool=0, g_connection_pool_max_idle_time=3600s, use_storage_id=0, storage server id count: 0server_count=1, server_index=0tracker server is 192.168.20.116:22122group count: 2Group 1:group name = group1disk total space = 35660 MBdisk free space = 29390 MBtrunk free space = 0 MBstorage server count = 1active server count = 1storage server port = 23000storage HTTP port = 8080store path count = 1subdir count per path = 256current write server index = 0current trunk file id = 0        Storage 1:                id = 192.168.20.117                ip_addr = 192.168.20.117  ACTIVE                http domain =                 version = 5.05                join time = 2017-06-05 19:59:44                up time = 2017-06-05 19:59:44                total storage = 35660 MB                free storage = 29390 MB                upload priority = 10                store_path_count = 1                subdir_count_per_path = 256                storage_port = 23000                storage_http_port = 8080                current_write_path = 0                source storage id =                 if_trunk_server = 0                connection.alloc_count = 256                connection.current_count = 0                connection.max_count = 1                total_upload_count = 3                success_upload_count = 3                total_append_count = 0                success_append_count = 0                total_modify_count = 0                success_modify_count = 0                total_truncate_count = 0                success_truncate_count = 0                total_set_meta_count = 0                success_set_meta_count = 0                total_delete_count = 0                success_delete_count = 0                total_download_count = 0                success_download_count = 0                total_get_meta_count = 0                success_get_meta_count = 0                total_create_link_count = 0                success_create_link_count = 0                total_delete_link_count = 0                success_delete_link_count = 0                total_upload_bytes = 7429                success_upload_bytes = 7429                total_append_bytes = 0                success_append_bytes = 0                total_modify_bytes = 0                success_modify_bytes = 0                stotal_download_bytes = 0                success_download_bytes = 0                total_sync_in_bytes = 0                success_sync_in_bytes = 0                total_sync_out_bytes = 0                success_sync_out_bytes = 0                total_file_open_count = 3                success_file_open_count = 3                total_file_read_count = 0                success_file_read_count = 0                total_file_write_count = 3                success_file_write_count = 3                last_heart_beat_time = 2017-06-05 23:21:47                last_source_update = 2017-06-05 23:20:24                last_sync_update = 1970-01-01 08:00:00                last_synced_timestamp = 1970-01-01 08:00:00 Group 2:group name = group2disk total space = 35660 MBdisk free space = 29390 MBtrunk free space = 0 MBstorage server count = 1active server count = 1storage server port = 23000storage HTTP port = 8080store path count = 1subdir count per path = 256current write server index = 0current trunk file id = 0        Storage 1:                id = 192.168.20.118                ip_addr = 192.168.20.118  ACTIVE                http domain =                 version = 5.05                join time = 2017-06-05 20:05:35                up time = 2017-06-05 20:05:35                total storage = 35660 MB                free storage = 29390 MB                upload priority = 10                store_path_count = 1                subdir_count_per_path = 256                storage_port = 23000                storage_http_port = 8080                current_write_path = 0                source storage id =                 if_trunk_server = 0                connection.alloc_count = 256                connection.current_count = 0                connection.max_count = 1                total_upload_count = 1                success_upload_count = 1                total_append_count = 0                success_append_count = 0                total_modify_count = 0                success_modify_count = 0                total_truncate_count = 0                success_truncate_count = 0                total_set_meta_count = 0                success_set_meta_count = 0                total_delete_count = 0                success_delete_count = 0                total_download_count = 0                success_download_count = 0                total_get_meta_count = 0                success_get_meta_count = 0                total_create_link_count = 0                success_create_link_count = 0                total_delete_link_count = 0                success_delete_link_count = 0                total_upload_bytes = 833473                success_upload_bytes = 833473                total_append_bytes = 0                success_append_bytes = 0                total_modify_bytes = 0                success_modify_bytes = 0                stotal_download_bytes = 0                success_download_bytes = 0                total_sync_in_bytes = 0                success_sync_in_bytes = 0                total_sync_out_bytes = 0                success_sync_out_bytes = 0                total_file_open_count = 1                success_file_open_count = 1                total_file_read_count = 0                success_file_read_count = 0                total_file_write_count = 4                success_file_write_count = 4                last_heart_beat_time = 2017-06-05 23:21:37                last_source_update = 2017-06-05 22:26:05                last_sync_update = 1970-01-01 08:00:00                last_synced_timestamp = 1970-01-01 08:00:00</code></pre>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FastDFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安装配置FastDFS</title>
      <link href="/2017/05/26/zhong-jian-jian/fastdfs-install/"/>
      <url>/2017/05/26/zhong-jian-jian/fastdfs-install/</url>
      
        <content type="html"><![CDATA[<blockquote><p>在新的服务器上安装了FastDFS_v5.05，相比较FastDFSV3.02还是有很多变化，现将安装配置过程记录下，供大家参考，出于安全考虑，其中涉及到IP地址的地方，随意用了一个IP202.98.27.31，在访问量不大情况下，将tracker和storage都部署在同一台服务器上，后期根据业务需要进行扩展：</p></blockquote><a id="more"></a><ol><li><p>软件下载：</p><pre><code> wget https://github.com/happyfish100/libfastcommon/archive/V1.0.7.tar.gz wget http://jaist.dl.sourceforge.net/project/fastdfs/FastDFS%20Nginx%20Module%20Source%20Code/fastdfs-nginx-module_v1.16.tar.gz wget https://github.com/happyfish100/fastdfs/archive/V5.05.tar.gz wget http://nginx.org/download/nginx-1.8.0.tar.gz wget ftp://ftp.csx.cam.ac.uk/pub/software/programming/pcre/pcre-8.36.tar.gz wget http://zlib.net/zlib-1.2.8.tar.gz</code></pre></li><li><p>libfastcommon安装：</p><pre><code> cp V1.0.7.tar.gz /usr/local/ tar -zxvf V1.0.7.tar.gz cd libfastcommon-1.0.7 ./make.sh ./make.sh install</code></pre><p>  libfastcommon.so默认安装到了/usr/lib64/libfastcommon.so，而FastDFS主程序设置的lib目录是/usr/local/lib，所以设置软连接</p><pre><code>   ln -s /usr/lib64/libfastcommon.so /usr/local/lib/libfastcommon.so  ln -s /usr/lib64/libfastcommon.so /usr/lib/libfastcommon.so  ln -s /usr/lib64/libfdfsclient.so /usr/local/lib/libfdfsclient.so  ln -s /usr/lib64/libfdfsclient.so /usr/lib/libfdfsclient.so</code></pre></li><li><p>安装FastDFS</p><ul><li><p>解压安装</p><pre><code>  tar -zxvf V5.05.tar.gz -C /usr/local  cd /usr/local/fastdfs-5.05/  ./make.sh  ./make.sh install</code></pre></li><li><p>配置文件修改</p><pre><code>  cd /etc/fdfs  cp tracker.conf.sample tracker.conf  cp storage.conf.sample storage.conf  cp client.conf.sample client.conf</code></pre><p>  详细设置见附件</p><ul><li><p>附件1:</p><pre><code>  tracker.conf配置中要修改的几个项：  bind_addr=202.98.27.31  port=22122  http.server_port=8080</code></pre></li><li><p>附件2：</p><pre><code>  storage.conf配置中要修改的几个项：  group_name=group1  bind_addr=202.98.27.31  port=23000  base_path=/usrdata/fastdfs  store_path0=/usrdata/fastdfs  tracker_server=202.98.27.31:22122  http.server_port=8888</code></pre></li></ul></li><li><p>启动</p><pre><code>  启动tracker storage  fdfs_trackerd /etc/fdfs/tracker.conf  fdfs_storaged /etc/fdfs/storage.conf</code></pre></li></ul></li><li><p>安装nginx插件</p><ul><li><p>安装</p><pre><code>  tar -zxvf fastdfs-nginx-module_v1.16.tar.gz  cd fastdfs-nginx-module/src/</code></pre></li><li><p><code>config</code>文件修改</p><pre><code>  vi config  修改如下配置，我这里原来是  CORE_INCS=&quot;$CORE_INCS /usr/local/include/fastdfs /usr/local/include/fastcommon/&quot;  改成  CORE_INCS=&quot;$CORE_INCS /usr/include/fastdfs /usr/include/fastcommon/&quot;</code></pre></li><li><p>修改配置</p><pre><code>  cp  mod_fastdfs.conf /etc/fdfs  修改配置  group_name=group1  tracker_server=202.98.27.31:22122  store_path0=/usrdata/fastdfs  base_path=/usrdata/fastdfs  url_have_group_name = true</code></pre></li><li><p>配置文件服务器的软连接</p><pre><code>  ln -s /usrdata/fastdfs/data /usrdata/fastdfs/data/M00  (配置文件中stoage存放数据的路径)</code></pre></li><li><p>同时将以下两个文件复制到<code>/etc/fdfs/</code></p><pre><code>  cp /usr/local/fastdfs-5.05/http.conf /etc/fdfs/  cp /usr/local/fastdfs-5.05/mime.types /etc/fdfs/</code></pre></li></ul></li><li><p>nginx安装：</p><p> 在每个Storage服务器上安装Nginx</p><ul><li><p>pcre安装：</p><pre><code>  tar -zxvf pcre-8.36.tar.gz  cd pcre-8.36  ./configure  make &amp;&amp; make install  cd ../  ln -s /usr/local/lib/libpcre.so.1 /lib64/</code></pre></li><li><p>zlib安装：</p><pre><code>  tar -zxvf zlib-1.2.8.tar.gz  cd zlib-1.2.8  ./configure  make &amp;&amp; make install  cd ../</code></pre></li><li><p>nginx安装：</p><pre><code>  tar -zxvf nginx-1.8.0.tar.gz  cd nginx-1.8.0  ./configure --prefix=/usr/local/nginx --add-module=/home/yq/fastdfs-nginx-module/src  make  make install</code></pre></li><li><p>nginx配置</p><pre><code>  cd /usr/local/nginx/conf  vi nginx.conf</code></pre><p>  在server中添加</p><pre><code>  location /group1/M00{      root /usrdata/fastdfs/data;      ngx_fastdfs_module;  }</code></pre></li><li><p>启动：</p><pre><code>  /usr/local/nginx/sbin/nginx</code></pre></li></ul></li><li><p>测试文件上传：</p><pre><code> /usr/bin/fdfs_test /etc/fdfs/client.conf upload benz.jpg</code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FastDFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mongodb高可用集群搭建</title>
      <link href="/2017/05/26/zhong-jian-jian/mongodb-high-availability-cluster/"/>
      <url>/2017/05/26/zhong-jian-jian/mongodb-high-availability-cluster/</url>
      
        <content type="html"><![CDATA[<blockquote><p>最近公司项目要求Mongodb集群且高可用，在查询了一系列文章，再结合项目实际情况，所以采用了这一套高可用集群方案</p></blockquote><a id="more"></a><h2 id="方案选项"><a href="#方案选项" class="headerlink" title="方案选项"></a>方案选项</h2><p>Mongodb的三种集群方式的搭建：Replica Set / Sharding / Master-Slaver。</p><ol><li><p>Replica Set（副本集）</p><p> 其实简单来说就是集群当中包含了多份数据，保证主节点挂掉了，备节点能继续提供数据服务，提供的前提就是数据需要和主节点一致。</p><p> <img src="http://img.my.csdn.net/uploads/201301/13/1358056331_2790.png" alt=""></p><p> Mongodb(M)表示主节点，Mongodb(S)表示备节点，Mongodb(A)表示仲裁节点。主备节点存储数据，仲裁节点不存储数据。客户端同时连接主节点与备节点，不连接仲裁节点。</p><p> 默认设置下，主节点提供所有增删查改服务，备节点不提供任何服务。但是可以通过设置使备节点提供查询服务，这样就可以减少主节点的压力，当客户端进行数据查询时，请求自动转到备节点上。这个设置叫做Read Preference Modes，同时Java客户端提供了简单的配置方式，可以不必直接对数据库进行操作。</p><p> 仲裁节点是一种特殊的节点，它本身并不存储数据，主要的作用是决定哪一个备节点在主节点挂掉之后提升为主节点，所以客户端不需要连接此节点。这里虽然只有一个备节点，但是仍然需要一个仲裁节点来提升备节点级别。我开始也不相信必须要有仲裁节点，但是自己也试过没仲裁节点的话，主节点挂了备节点还是备节点，所以咱们还是需要它的。</p></li><li><p>Sharding</p><p> 和Replica Set类似，都需要一个仲裁节点，但是Sharding还需要配置节点和路由节点。就三种集群搭建方式来说，这种是最复杂的。部署图如下：</p><p> <img src="http://img.my.csdn.net/uploads/201301/13/1358091861_1772.png" alt=""></p></li><li><p>Master-Slaver</p><p> 这个是最简答的集群搭建，不过准确说也不能算是集群，只能说是主备。并且官方已经不推荐这种方式。</p></li><li><p>综述</p><ul><li><code>Master-Slaver</code>官方已经不推荐这种方式了。不采用！</li><li><code>Sharding</code>过于复杂，考虑项目情况，也不采用！</li><li><code>Replica Set</code>集群、高可用，部署也简单，采用这种情况，下面介绍这种情况的部署！</li></ul></li></ol><h2 id="基于Replica-Set的方式进行部署"><a href="#基于Replica-Set的方式进行部署" class="headerlink" title="基于Replica Set的方式进行部署"></a>基于<code>Replica Set</code>的方式进行部署</h2><ol><li><p>准备</p><p> 由于是在本机虚拟机部署，所以只采用一台机器（10.211.55.10），开启4个端口（master：27017，slaver：27018、27019，arbiter：27020）</p></li><li><p>配置文件(mongodb配置文件具体属性解释请参考附录1)</p><ul><li><p>master</p><pre><code>  # master.conf  dbpath=/opt/mongodb/data/master  logpath=/opt/mongodb/logs/master.log  pidfilepath=/opt/mongodb/logs/master.pid  directoryperdb=true  logappend=true  replSet=ynzw  bind_ip=10.211.55.10  port=27017  oplogSize=10000  fork=true  noprealloc=true</code></pre></li><li><p>slaver1</p><pre><code>  # slaver1.conf  dbpath=/opt/mongodb/data/slaver1  logpath=/opt/mongodb/logs/slaver1.log  pidfilepath=/opt/mongodb/logs/slaver1.pid  directoryperdb=true  logappend=true  replSet=ynzw  bind_ip=10.211.55.10  port=27018  oplogSize=10000  fork=true  noprealloc=true</code></pre></li><li><p>slaver2</p><pre><code>  # slaver2.conf  dbpath=/opt/mongodb/data/slaver2  logpath=/opt/mongodb/logs/slaver2.log  pidfilepath=/opt/mongodb/logs/slaver2.pid  directoryperdb=true  logappend=true  replSet=ynzw  bind_ip=10.211.55.10  port=27019  oplogSize=10000  fork=true  noprealloc=true</code></pre></li><li><p>arbiter</p><pre><code>  # arbiter.conf  dbpath=/opt/mongodb/data/arbiter  logpath=/opt/mongodb/logs/arbiter.log  pidfilepath=/opt/mongodb/logs/arbiter.pid  directoryperdb=true  logappend=true  replSet=ynzw  bind_ip=10.211.55.10  port=27020  oplogSize=10000  fork=true  noprealloc=true</code></pre></li></ul></li><li><p>启动4个节点</p><pre><code> /opt/mongodb/bin/mongod -f /opt/mongodb/conf/master.conf /opt/mongodb/bin/mongod -f /opt/mongodb/conf/slaver1.conf /opt/mongodb/bin/mongod -f /opt/mongodb/conf/slaver2.conf /opt/mongodb/bin/mongod -f /opt/mongodb/conf/arbiter.conf</code></pre></li><li><p>配置主，备，仲裁节点</p><ul><li><p>客户端连接master、slaver中任意一个节点mongodb</p><pre><code>  /opt/mongodb/bin/mongo 10.211.55.10:27017</code></pre></li><li><p>开始配置</p><pre><code>  &gt; use admin  &gt; cfg = {    _id: &quot;ynzw&quot;,    members: [      {        _id: 0,        host: &#39;10.211.55.10:27017&#39;,        priority: 3      },      {        _id: 1,        host: &#39;10.211.55.10:27018&#39;,        priority: 2      },      {        _id: 2,        host: &#39;10.211.55.10:27019&#39;,        priority: 1      },      {        _id: 3,        host: &#39;10.211.55.10:27020&#39;,        arbiterOnly: true      }    ]  };  &gt; rs.initiate(cfg)</code></pre><p>  cfg是可以任意的名字，当然最好不要是mongodb的关键字，conf，config都可以。最外层的_id表示replica set的名字，members里包含的是所有节点的地址以及优先级。优先级最高的即成为主节点，即这里的10.211.55.10:27017。特别注意的是，对于仲裁节点，需要有个特别的配置——arbiterOnly:true。这个千万不能少了，不然主备模式就不能生效。</p></li><li><p>检验</p><p>  配置的生效时间根据不同的机器配置会有长有短，配置不错的话基本上十几秒内就能生效，有的配置需要一两分钟。如果生效了，执行rs.status()命令会看到如下信息：</p><pre><code>  ynzw:SECONDARY&gt; rs.status()  {          &quot;set&quot; : &quot;ynzw&quot;,          &quot;date&quot; : ISODate(&quot;2017-05-26T06:47:32.069Z&quot;),          &quot;myState&quot; : 1,          &quot;term&quot; : NumberLong(8),          &quot;heartbeatIntervalMillis&quot; : NumberLong(2000),          &quot;members&quot; : [                  {                          &quot;_id&quot; : 0,                          &quot;name&quot; : &quot;10.211.55.10:27017&quot;,                          &quot;health&quot; : 1,                          &quot;state&quot; : 1,                          &quot;stateStr&quot; : &quot;PRIMARY&quot;,                          &quot;uptime&quot; : 24,                          &quot;optime&quot; : {                                  &quot;ts&quot; : Timestamp(1495781239, 2),                                  &quot;t&quot; : NumberLong(8)                          },                          &quot;optimeDate&quot; : ISODate(&quot;2017-05-26T06:47:19Z&quot;),                          &quot;electionTime&quot; : Timestamp(1495781239, 1),                          &quot;electionDate&quot; : ISODate(&quot;2017-05-26T06:47:19Z&quot;),                          &quot;configVersion&quot; : 1,                          &quot;self&quot; : true                  },                  {                          &quot;_id&quot; : 1,                          &quot;name&quot; : &quot;10.211.55.10:27018&quot;,                          &quot;health&quot; : 1,                          &quot;state&quot; : 2,                          &quot;stateStr&quot; : &quot;SECONDARY&quot;,                          &quot;uptime&quot; : 18,                          &quot;optime&quot; : {                                  &quot;ts&quot; : Timestamp(1495781239, 2),                                  &quot;t&quot; : NumberLong(8)                          },                          &quot;optimeDate&quot; : ISODate(&quot;2017-05-26T06:47:19Z&quot;),                          &quot;lastHeartbeat&quot; : ISODate(&quot;2017-05-26T06:47:31.424Z&quot;),                          &quot;lastHeartbeatRecv&quot; : ISODate(&quot;2017-05-26T06:47:31.247Z&quot;),                          &quot;pingMs&quot; : NumberLong(0),                          &quot;syncingTo&quot; : &quot;10.211.55.10:27017&quot;,                          &quot;configVersion&quot; : 1                  },                  {                          &quot;_id&quot; : 2,                          &quot;name&quot; : &quot;10.211.55.10:27019&quot;,                          &quot;health&quot; : 1,                          &quot;state&quot; : 2,                          &quot;stateStr&quot; : &quot;SECONDARY&quot;,                          &quot;uptime&quot; : 18,                          &quot;optime&quot; : {                                  &quot;ts&quot; : Timestamp(1495781239, 2),                                  &quot;t&quot; : NumberLong(8)                          },                          &quot;optimeDate&quot; : ISODate(&quot;2017-05-26T06:47:19Z&quot;),                          &quot;lastHeartbeat&quot; : ISODate(&quot;2017-05-26T06:47:31.424Z&quot;),                          &quot;lastHeartbeatRecv&quot; : ISODate(&quot;2017-05-26T06:47:31.734Z&quot;),                          &quot;pingMs&quot; : NumberLong(0),                          &quot;syncingTo&quot; : &quot;10.211.55.10:27018&quot;,                          &quot;configVersion&quot; : 1                  },                  {                          &quot;_id&quot; : 3,                          &quot;name&quot; : &quot;10.211.55.10:27020&quot;,                          &quot;health&quot; : 1,                          &quot;state&quot; : 7,                          &quot;stateStr&quot; : &quot;ARBITER&quot;,                          &quot;uptime&quot; : 18,                          &quot;lastHeartbeat&quot; : ISODate(&quot;2017-05-26T06:47:31.424Z&quot;),                          &quot;lastHeartbeatRecv&quot; : ISODate(&quot;2017-05-26T06:47:30.437Z&quot;),                          &quot;pingMs&quot; : NumberLong(0),                          &quot;configVersion&quot; : 1                  }          ],          &quot;ok&quot; : 1  }  ynzw:PRIMARY&gt; </code></pre><p>  如果配置正在生效，其中会包含如下信息：<code>&quot;stateStr&quot; : &quot;RECOVERING&quot;</code></p></li></ul></li></ol><h2 id="客户端连接"><a href="#客户端连接" class="headerlink" title="客户端连接"></a>客户端连接</h2><ol><li><p>使用<code>spring-data-mongodb</code>+<code>mongo-java-driver</code>操作mongodb</p></li><li><p><code>10.211.55.10:27017</code>、<code>10.211.55.10:27018</code>、<code>10.211.55.10:27019</code>是主从节点，由于仲裁节点不存储数据，所以不需要连接</p></li><li><p>代码</p><pre><code> List&lt;ServerAddress&gt; servers = new ArrayList&lt;&gt;(addresses.size()); for (String address : addresses) {     String host = address.split(&quot;:&quot;)[0];     Integer port = Integer.valueOf(address.split(&quot;:&quot;)[1]);     servers.add(new ServerAddress(host, port)); } MongoClient client = new MongoClient(servers); MongoDatabase db = client.getDatabase(mongoName);</code></pre></li></ol><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><ol><li><p>mongodb配置文件具体属性解释</p><pre><code> dbpath：数据存放目录 logpath：日志存放路径 pidfilepath：进程文件，方便停止mongodb directoryperdb：为每一个数据库按照数据库名建立文件夹存放 logappend：以追加的方式记录日志 replSet：replica set的名字 bind_ip：mongodb所绑定的ip地址 port：mongodb进程所使用的端口号，默认为27017 oplogSize：mongodb操作日志文件的最大大小。单位为Mb，默认为硬盘剩余空间的5% fork：以后台方式运行进程 noprealloc：不预先分配存储</code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mongodb </tag>
            
            <tag> database </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis高可用集群搭建</title>
      <link href="/2017/05/24/zhong-jian-jian/redis-high-availability-cluster/"/>
      <url>/2017/05/24/zhong-jian-jian/redis-high-availability-cluster/</url>
      
        <content type="html"><![CDATA[<blockquote><p>最近公司项目要求Redis集群且高可用，在查询了一系列文章，再结合项目实际情况，所以采用了这一套高可用集群方案</p></blockquote><a id="more"></a><h2 id="方案选型"><a href="#方案选型" class="headerlink" title="方案选型"></a>方案选型</h2><p>Redis集群有三种方案实现：</p><ol><li><p>Redis官方集群方案 Redis Cluster</p><p> 这种方案是redis官方提供的，采用slot的概念，一共分成16384个槽。对key的值进行散列，分配到这16384个slot中的某一个中。但是这个Redis集群，要保证16384个槽对应的node都正常工作，如果某个node发生故障，那它负责的slots也就失效，整个集群将不能工作。这不符合我们的要求：<strong>高可用</strong>。</p></li><li><p>利用代理中间件实现大规模Redis集群</p><p> 过于复杂，并且我们redis的使用量不是很大，只需要保证稳定即可（高可用）。所以这个方案也没有采纳。</p></li></ol><ol start="3"><li><p>Redis Sentinel主从高可用方案</p><p> 部署redis主从服务（1个master，多个salve），然后通过redis官方的监控工具Sentinel（哨兵），对每个节点进行监控，实现自动故障迁移，即master死掉，将salve升级为master。基本原理是：心跳机制+投票裁决。</p></li></ol><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><ol><li>下载redis源码包。<a href="http://download.redis.io/releases/redis-3.2.9.tar.gz" target="_blank" rel="noopener">地址</a></li><li>准备1台服务器（按照部署情况，共有5个端口）</li><li>5个端口中，1个master(6379)，2个slave(6380,6381)，2个sentinel（哨兵）(63791, 63792)</li></ol><h2 id="sentinel配置-参数配置查看附录1"><a href="#sentinel配置-参数配置查看附录1" class="headerlink" title="sentinel配置(参数配置查看附录1)"></a>sentinel配置(参数配置查看附录1)</h2><ol><li><p>配置文件_63791(<code>sentinel_63791.conf</code>)</p><pre><code> # 端口 port 63791 daemonize yes # 很重要，见附录2 protected-mode no # 日志文件 logfile &quot;/opt/redis-cluster/logs/sentinel_63791.log&quot; #master-1 # 监控master # sentinel monitor master_name ip port quorum # quorum是一个数字，指明当有多少个sentinel认为一个master失效时，master才算真正失效。 sentinel monitor master-1 10.211.55.10 6381 1 # 这个配置项指定了需要多少失效时间，一个master才会被这个sentinel主观地认为是不可用的。 单位是毫秒，默认为30秒 sentinel down-after-milliseconds master-1 5000 sentinel failover-timeout master-1 18000 # 设置连接master和slave时的密码,master和slave用户名密码要一致 sentinel auth-pass master-1 test123 sentinel parallel-syncs master-1 1</code></pre></li><li><p>配置文件_63792(<code>sentinel_63792.conf</code>)</p><pre><code> port 63792 daemonize yes protected-mode no logfile &quot;/opt/redis-cluster/logs/sentinel_63792.log&quot; #master-1 sentinel monitor master-1 10.211.55.10 6381 1 sentinel down-after-milliseconds master-1 5000 sentinel failover-timeout master-1 18000 sentinel auth-pass master-1 test123 sentinel parallel-syncs master-1 1</code></pre></li></ol><h2 id="Master节点配置"><a href="#Master节点配置" class="headerlink" title="Master节点配置"></a>Master节点配置</h2><p><code>redis_master_6379.conf</code> 配置：</p><pre><code>port 6379daemonize yesrequirepass test123masterauth test123</code></pre><h2 id="两个slave节点配置"><a href="#两个slave节点配置" class="headerlink" title="两个slave节点配置"></a>两个slave节点配置</h2><ol><li><p><code>redis_slave_6380.conf</code></p><pre><code> port 6380 daemonize yes requirepass &quot;test123&quot; slaveof 10.211.55.10 6379 masterauth &quot;sunhao123&quot; bind 0.0.0.0</code></pre></li><li><p><code>redis_slave_6381.conf</code> </p><pre><code> port 6381 daemonize yes requirepass &quot;test123&quot; slaveof 10.211.55.10 6379 masterauth &quot;sunhao123&quot; bind 0.0.0.0</code></pre></li></ol><h2 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h2><p>按如下顺序依次启动服务：</p><pre><code>redis-server /opt/redis-cluster/redis_master_6379.conf redis-server /opt/redis-cluster/redis_slave_6380.conf redis-server /opt/redis-cluster/redis_slave_6381.conf redis-sentinel /opt/redis-cluster/sentinel_63791.conf redis-sentinel /opt/redis-cluster/sentinel_63792.conf </code></pre><h2 id="查看各个节点的状态"><a href="#查看各个节点的状态" class="headerlink" title="查看各个节点的状态"></a>查看各个节点的状态</h2><ol><li><p>查看全部节点状态</p><pre><code> [root@CentOS-3 redis-cluster]# ps aux | grep redis root      1782  0.0  0.0 103252   824 pts/4    S+   21:36   0:00 grep redis root     25331  0.1  0.3 133528  7648 ?        Ssl  18:06   0:20 redis-server 0.0.0.0:6380                             root     25336  0.1  0.5 135576  9720 ?        Ssl  18:06   0:21 redis-server 0.0.0.0:6381                             root     29303  0.2  0.4 133524  7700 ?        Ssl  18:27   0:32 redis-sentinel *:63791 [sentinel]                     root     29308  0.2  0.4 133524  7704 ?        Ssl  18:27   0:33 redis-sentinel *:63792 [sentinel]                     root     29486  0.1  0.3 133528  7648 ?        Ssl  18:28   0:18 redis-server 0.0.0.0:6379</code></pre></li><li><p>查看master状态</p><pre><code> [root@CentOS-3 redis-cluster]# redis-cli -h 10.211.55.10 -p 6379 10.211.55.10:6379&gt; auth test123 OK 10.211.55.10:6379&gt; info replication # Replication role:master connected_slaves:2 slave0:ip=10.211.55.10,port=6380,state=online,offset=1568095,lag=1 slave1:ip=10.211.55.10,port=6381,state=online,offset=1568095,lag=1 master_repl_offset:1568095 repl_backlog_active:1 repl_backlog_size:1048576 repl_backlog_first_byte_offset:519520 repl_backlog_histlen:1048576 10.211.55.10:6379&gt; </code></pre></li><li><p>查看slave的状态：</p><pre><code> [root@CentOS-3 redis-cluster]# redis-cli -h 10.211.55.10 -p 6380 10.211.55.10:6380&gt; auth test123 OK 10.211.55.10:6380&gt; info replication # Replication role:slave master_host:10.211.55.10 master_port:6379 master_link_status:up master_last_io_seconds_ago:1 master_sync_in_progress:0 slave_repl_offset:1578354 slave_priority:100 slave_read_only:1 connected_slaves:0 master_repl_offset:0 repl_backlog_active:0 repl_backlog_size:1048576 repl_backlog_first_byte_offset:0 repl_backlog_histlen:0 10.211.55.10:6380&gt; </code></pre></li><li><p>查看sentinel的状态：</p><pre><code> [root@CentOS-3 redis-cluster]# redis-cli -h 10.211.55.10 -p 63791 10.211.55.10:63791&gt; info sentinel # Sentinel sentinel_masters:1 sentinel_tilt:0 sentinel_running_scripts:0 sentinel_scripts_queue_length:0 sentinel_simulate_failure_flags:0 master0:name=master-1,status=ok,address=10.211.55.10:6379,slaves=2,sentinels=2 10.211.55.10:63791&gt; </code></pre></li></ol><h2 id="验证redis-sentinel的主从切换："><a href="#验证redis-sentinel的主从切换：" class="headerlink" title="验证redis sentinel的主从切换："></a>验证redis sentinel的主从切换：</h2><ol><li><p>首先关闭master节点，即kill掉master进程</p></li><li><p>查看sentinel服务，发现端口6381升级为master节点，这时sentinel完成故障自动切换。</p><pre><code> [root@CentOS-3 redis-cluster]# redis-cli -h 10.211.55.10 -p 63791 10.211.55.10:63791&gt; info sentinel # Sentinel sentinel_masters:1 sentinel_tilt:0 sentinel_running_scripts:0 sentinel_scripts_queue_length:0 sentinel_simulate_failure_flags:0 master0:name=master-1,status=ok,address=10.211.55.10:6381,slaves=2,sentinels=2 10.211.55.10:63791&gt; </code></pre></li><li><p>启动刚才被shutdown的6379服务并查看，发现它变成了slave服务。</p><pre><code> [root@CentOS-3 redis-cluster]# redis-cli -h 10.211.55.10 -p 6379 10.211.55.10:6379&gt; auth test123 OK 10.211.55.10:6379&gt; info replication # Replication role:slave master_host:10.211.55.10 master_port:6381 master_link_status:up master_last_io_seconds_ago:2 master_sync_in_progress:0 slave_repl_offset:15074 slave_priority:100 slave_read_only:1 connected_slaves:0 master_repl_offset:0 repl_backlog_active:0 repl_backlog_size:1048576 repl_backlog_first_byte_offset:0 repl_backlog_histlen:0 10.211.55.10:6379&gt; </code></pre></li></ol><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><ol><li><p>Redis搭建sentinel,无法主从自动切换,一直卡在-sdown sentinel</p><p> redis-sentinel有保护模式，所以要将这个模块关闭！</p><pre><code> protected-mode no</code></pre></li><li><p>redis-sentinel配置项详细说明</p><p> 参考<a href="http://blog.csdn.net/a1282379904/article/details/52335051" target="_blank" rel="noopener">链接</a></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> database </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>通过Atlas实现MySQL读写分离</title>
      <link href="/2017/05/23/shu-ju-ku/atlas-mysql/"/>
      <url>/2017/05/23/shu-ju-ku/atlas-mysql/</url>
      
        <content type="html"><![CDATA[<blockquote><p>最近公司项目要求MySQL高可用，加上以前公司听过QiHoo360的Atlas，所以就尝试搭建了一个MySQL读写分离，并且高可用的。</p></blockquote><a id="more"></a><h2 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h2><ol><li>准备4台机器，系统为<code>CentOS release 6.6</code></li><li>Ip分别为<code>192.168.20.121</code>、<code>192.168.20.122</code>、<code>192.168.20.123</code>、<code>192.168.20.124</code></li><li>4台机器分别作为<code>Atlas代理服务</code>，<code>master MySQL</code>，<code>slave MySQL 1</code>，<code>slave MySQL 2</code></li><li>下载QiHoo360的Atlas <a href="https://github.com/Qihoo360/Atlas/releases" target="_blank" rel="noopener">地址</a></li></ol><h2 id="安装Atlas"><a href="#安装Atlas" class="headerlink" title="安装Atlas"></a>安装Atlas</h2><ol><li><p>下载得到<code>Atlas-XX.el6.x86_64.rpm</code>安装文件</p></li><li><p><code>sudo rpm –i Atlas-XX.el6.x86_64.rpm</code>安装</p></li><li><p>安装在<code>/usr/local/mysql-proxy</code></p></li><li><p>安装目录分析</p><ul><li><code>bin</code><ul><li>可执行文件</li><li><code>encrypt</code>用来加密密码，后面会用到</li><li><code>mysql-proxy</code>是MySQL自己的读写分离代理</li><li><code>mysql-proxyd</code>操作Atlas</li><li><code>VERSION</code></li></ul></li><li><code>conf</code><ul><li><code>test.cnf</code>配置文件</li><li>一个文件为一个实例，实例名即文件名，启动需要带上这个实例名</li></ul></li><li><code>lib</code>依赖包</li><li><code>log</code>记录日志</li></ul></li><li><p>启动命令：<code>/usr/local/mysql-proxy/bin/mysql-proxyd [实例名] start</code></p></li><li><p>停止命令：<code>/usr/local/mysql-proxy/bin/mysql-proxyd [实例名] stop</code></p></li><li><p>同理，<code>restart</code>为重启，<code>status</code>为查看状态</p></li><li><p>配置文件解释</p><p> 请查看<a href="https://github.com/Qihoo360/Atlas/wiki/Atlas%E7%9A%84%E5%AE%89%E8%A3%85" target="_blank" rel="noopener">官方文档</a></p></li></ol><h2 id="数据库配置"><a href="#数据库配置" class="headerlink" title="数据库配置"></a>数据库配置</h2><ol><li><p>1台master2台slave，都要配置相同的用户名密码，且都要可以远程访问</p></li><li><p>分别进入3台服务器，创建相同的用户名密码，创建数据库<code>test</code>，设置权限</p><pre><code> CREATE USER &#39;test&#39;@&#39;%&#39; IDENTIFIED BY &#39;test123&#39;; CREATE USER &#39;test&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;test123&#39;; grant all privileges on test.* to &#39;test&#39;@&#39;%&#39; identified by &#39;test123&#39;; grant all privileges on test.* to &#39;test&#39;@&#39;localhost&#39; identified by &#39;test123&#39;; flush privileges;</code></pre></li><li><p>主从数据库配置</p><ol><li><p>配置master服务器</p><ul><li><p>找到MySQL配置文件<code>my.cnf</code>，一般在<code>etc</code>目录下</p></li><li><p>修改配置文件</p><pre><code>  [mysqld]  # 一些其他配置  ...   #主从复制配置    innodb_flush_log_at_trx_commit=1    sync_binlog=1    #需要备份的数据库  binlog-do-db=test  #不需要备份的数据库  binlog-ignore-db=mysql    #启动二进制文件    log-bin=mysql-bin    #服务器ID    server-id=1    # Disabling symbolic-links is recommended to prevent assorted security risks    symbolic-links=0</code></pre></li><li><p>重启数据库<code>service mysql restart</code></p></li><li><p>进入数据库，配置主从复制的权限</p><pre><code>  mysql -uroot -p123456  grant replication slave on *.* to &#39;test&#39;@&#39;127.0.0.1&#39; identified by &#39;test123&#39;;</code></pre></li><li><p>查看主数据库信息，记住下面的<code>File</code>与<code>Position</code>的信息，它们是用来配置从数据库的关键信息。</p><pre><code>  mysql&gt; show master status;  +------------------+----------+--------------+------------------+  | File             | Position | Binlog_Do_DB | Binlog_Ignore_DB |  +------------------+----------+--------------+------------------+  | mysql-bin.000002 | 17620976 | test         | mysql            |  +------------------+----------+--------------+------------------+  1 row in set (0.00 sec)</code></pre></li></ul></li><li><p>配置两台salve服务器</p><ul><li><p>找到配置文件<code>my.cnf</code></p></li><li><p>修改配置文件如下</p><pre><code>  [mysqld]  # 一些其他配置  ...   # 几台服务器不能一样  server-id=2  # Disabling symbolic-links is recommended to prevent assorted security risks  symbolic-links=0</code></pre></li><li><p>进入数据库，配置从数据库的信息，这里输入刚才记录下来的<code>File</code>与<code>Position</code>的信息，并且在从服务器上执行：</p><pre><code>          # master数据库的ip  mysql&gt; change master to master_host=&#39;192.168.20.122&#39;,          # master的用户名      -&gt; master_user=&#39;buck&#39;,          # 密码      -&gt; master_password=&#39;hello&#39;,          # 端口      -&gt; master_port=3306,          # master数据库的`File `      -&gt; master_log_file=&#39;mysql-bin.000002&#39;,          # master数据库的`Position`      -&gt; master_log_pos=17620976,      -&gt; master_connect_retry=10;</code></pre></li><li><p>启动进程</p><pre><code>  mysql&gt; start slave;  Query OK, 0 rows affected (0.00 sec)</code></pre></li><li><p>检查主从复制状态，要看到下列<code>Slave_IO_Running</code>、<code>Slave_SQL_Running</code>的信息中，两个都是<code>Yes</code>，才说明主从连接正确，如果有一个是No，需要重新确定刚才记录的日志信息，停掉“stop slave”重新进行配置主从连接。</p><pre><code>  mysql&gt; show slave status \G;  *************************** 1. row ***************************                 Slave_IO_State: Waiting for master to send event                    Master_Host: 192.168.246.134                    Master_User: buck                    Master_Port: 3306                  Connect_Retry: 10                Master_Log_File: mysql-bin.000002            Read_Master_Log_Pos: 17620976                 Relay_Log_File: mysqld-relay-bin.000002                  Relay_Log_Pos: 251          Relay_Master_Log_File: mysql-bin.000002               Slave_IO_Running: Yes              Slave_SQL_Running: Yes                Replicate_Do_DB:             Replicate_Ignore_DB:              Replicate_Do_Table:          Replicate_Ignore_Table:         Replicate_Wild_Do_Table:     Replicate_Wild_Ignore_Table:                      Last_Errno: 0                     Last_Error:                    Skip_Counter: 0            Exec_Master_Log_Pos: 17620976                Relay_Log_Space: 407                Until_Condition: None                 Until_Log_File:                   Until_Log_Pos: 0             Master_SSL_Allowed: No             Master_SSL_CA_File:              Master_SSL_CA_Path:                 Master_SSL_Cert:               Master_SSL_Cipher:                  Master_SSL_Key:           Seconds_Behind_Master: 0  Master_SSL_Verify_Server_Cert: No                  Last_IO_Errno: 0                  Last_IO_Error:                  Last_SQL_Errno: 0                 Last_SQL_Error:   1 row in set (0.00 sec)  ERROR:   No query specified</code></pre></li></ul></li></ol></li></ol><h2 id="Atlas配置"><a href="#Atlas配置" class="headerlink" title="Atlas配置"></a>Atlas配置</h2><ol><li><p>使用Atlas的加密工具对上面用户的密码进行加密</p><pre><code> /usr/local/mysql-proxy/bin/encrypt test123 29uENYYsKLo=</code></pre></li><li><p>配置atlas</p><ul><li><p>这是用来登录到Atlas的管理员的账号与密码，与之对应的是<code>Atlas监听的管理接口IP和端口</code>，也就是说需要设置管理员登录的端口，才能进入管理员界面，默认端口是<code>2345</code>，也可以指定IP登录，指定IP后，其他的IP无法访问管理员的命令界面。方便测试，我这里没有指定IP和端口登录。</p></li><li><p>配置主数据的地址与从数据库的地址，这里配置的主数据库是122，从数据库是123、124</p><pre><code>  #Atlas后端连接的MySQL主库的IP和端口，可设置多项，用逗号分隔  proxy-backend-addresses = 192.168.20.122:3306  #Atlas后端连接的MySQL从库的IP和端口，@后面的数字代表权重，用来作负载均衡，若省略则默认为1，可设置多项，用逗号分隔  proxy-read-only-backend-addresses = 192.168.20.123:3306@1,192.168.20.124:3306@2</code></pre></li><li><p>这个是用来配置MySQL的账户与密码的，就是上面创建的用户，用户名是<code>test</code>,密码是<code>test123</code>,刚刚使用Atlas提供的工具生成了对应的加密密码</p><pre><code>  pwds = buck:RePBqJ+5gI4=</code></pre></li></ul></li><li><p>启动Atlas</p><pre><code> [root@localhost /usr/local/mysql-proxy/bin]# ./mysql-proxyd test start OK: MySQL-Proxy of test is started</code></pre></li></ol><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><ol><li><p>进入atlas的管理界面</p><pre><code> [root@localhost ~]#mysql -h127.0.0.1 -P2345 -uuser -ppwd Welcome to the MySQL monitor.  Commands end with ; or \g. Your MySQL connection id is 1 Server version: 5.0.99-agent-admin Copyright (c) 2000, 2013, Oracle and/or its affiliates. All rights reserved. Oracle is a registered trademark of Oracle Corporation and/or its affiliates. Other names may be trademarks of their respective owners. Type &#39;help;&#39; or &#39;\h&#39; for help. Type &#39;\c&#39; to clear the current input statement. mysql&gt; select * from help; +----------------------------+---------------------------------------------------------+ | command                    | description                                             | +----------------------------+---------------------------------------------------------+ | SELECT * FROM help         | shows this help                                         | | SELECT * FROM backends     | lists the backends and their state                      | | SET OFFLINE $backend_id    | offline backend server, $backend_id is backend_ndx&#39;s id | | SET ONLINE $backend_id     | online backend server, ...                              | | ADD MASTER $backend        | example: &quot;add master 127.0.0.1:3306&quot;, ...               | | ADD SLAVE $backend         | example: &quot;add slave 127.0.0.1:3306&quot;, ...                | | REMOVE BACKEND $backend_id | example: &quot;remove backend 1&quot;, ...                        | | SELECT * FROM clients      | lists the clients                                       | | ADD CLIENT $client         | example: &quot;add client 192.168.1.2&quot;, ...                  | | REMOVE CLIENT $client      | example: &quot;remove client 192.168.1.2&quot;, ...               | | SELECT * FROM pwds         | lists the pwds                                          | | ADD PWD $pwd               | example: &quot;add pwd user:raw_password&quot;, ...               | | ADD ENPWD $pwd             | example: &quot;add enpwd user:encrypted_password&quot;, ...       | | REMOVE PWD $pwd            | example: &quot;remove pwd user&quot;, ...                         | | SAVE CONFIG                | save the backends to config file                        | | SELECT VERSION             | display the version of Atlas                            | +----------------------------+---------------------------------------------------------+ 16 rows in set (0.00 sec) mysql&gt; </code></pre></li><li><p>使用工作接口来访问</p><pre><code> [root@localhost ~]#mysql -h127.0.0.1 -P1234 -utest -ptest123 Welcome to the MySQL monitor.  Commands end with ; or \g. Your MySQL connection id is 34 Server version: 5.0.81-log MySQL Community Server (GPL) Copyright (c) 2000, 2013, Oracle and/or its affiliates. All rights reserved. Oracle is a registered trademark of Oracle Corporation and/or its affiliates. Other names may be trademarks of their respective owners. Type &#39;help;&#39; or &#39;\h&#39; for help. Type &#39;\c&#39; to clear the current input statement. mysql&gt; show databases; +--------------------+ | Database           | +--------------------+ | information_schema | | mysql              | | performance_schema | | test               | +--------------------+ 4 rows in set (0.00 sec) mysql&gt; </code></pre></li></ol><h2 id="使用可视化管理工具Navicat登录"><a href="#使用可视化管理工具Navicat登录" class="headerlink" title="使用可视化管理工具Navicat登录"></a>使用可视化管理工具<code>Navicat</code>登录</h2><p>使用用户名<code>test</code>、密码<code>test123</code>、端口<code>1234</code>、地址<code>192.168.20.121</code>正常登录。注意，这里登录的是atlas服务器，不再是任何一个MySQL服务器</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> database </tag>
            
            <tag> MySQL </tag>
            
            <tag> Atlas </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>周杰伦Jay所有专辑</title>
      <link href="/2016/08/30/qi-ta/jay/"/>
      <url>/2016/08/30/qi-ta/jay/</url>
      
        <content type="html"><![CDATA[<h2 id="Jay-2000"><a href="#Jay-2000" class="headerlink" title="Jay(2000)"></a>Jay(2000)</h2><ol><li><p>专辑简介：</p><p> 《Jay》是周杰伦jay的第一部专辑，由周杰伦制作、作曲，方文山、徐若瑄等人作词，收录了10首歌曲，2000年11月7日发行。</p></li><li><p>歌曲列表</p><ul><li>可爱女人</li><li>完美主义</li><li>星晴</li><li>娘子</li><li>斗牛</li><li>黑色幽默</li><li>伊斯坦堡</li><li>印地安老斑鸠</li><li>龙卷风</li><li>反方向的钟</li></ul></li></ol><a id="more"></a><h2 id="范特西-2001"><a href="#范特西-2001" class="headerlink" title="范特西(2001)"></a>范特西(2001)</h2><ol><li><p>专辑简介：</p><p> 《范特西》是周杰伦2001年发行的专辑，共收录了爱在西元前、爸我回来了、简单爱等10首歌曲，专辑的监制也由周杰伦jay担任。</p></li><li><p>歌曲列表</p><ul><li>爱在西元前<ul><li>爸我回来了</li><li>简单爱</li><li>忍者</li><li>开不了口</li><li>上海一九四三</li><li>对不起</li><li>威廉古堡</li><li>双截棍</li><li>安静</li></ul></li></ul></li></ol><h2 id="八度空间-2002"><a href="#八度空间-2002" class="headerlink" title="八度空间(2002)"></a>八度空间(2002)</h2><ol><li><p>专辑简介：</p><p> 《八度空间》是周杰伦发行的第3张专辑，由周杰伦作曲并担任制作人，方文山、许世昌、刘耕宏、周杰伦作词。专辑于2002年7月发行，共收录10首歌曲。</p></li><li><p>歌曲列表</p><ul><li>半兽人 <ul><li>半岛铁盒  </li><li>暗号  </li><li>龙拳  </li><li>火车叨位去   </li><li>分裂  </li><li>爷爷泡的茶   </li><li>回到过去  </li><li>米兰的小铁匠  </li><li>最后的战役</li></ul></li></ul></li></ol><h2 id="叶惠美-2003"><a href="#叶惠美-2003" class="headerlink" title="叶惠美(2003)"></a>叶惠美(2003)</h2><ol><li><p>专辑简介：</p><p> 《叶惠美》是周杰伦以他妈妈的名字命名的一张专辑。由于《叶惠美》之前的那张专辑市场反应不甚理想，周杰伦求新求变的音乐理念在这张专辑里显得异常清晰。周杰伦不仅为专辑的多首歌曲作词、作曲，更是担当起了专辑的制作人。专辑除了有周杰伦和好友方文山的创作之外，钟兴民、洪敬尧、林迈可、杨大纬等音乐人也参与的专辑的制作。</p></li><li><p>歌曲列表</p><ul><li>以父之名    </li><li>懦夫  </li><li>晴天  </li><li>三年二班    </li><li>东风破 </li><li>你听得到    </li><li>同一种调调   </li><li>她的睫毛    </li><li>爱情悬崖    </li><li>梯田  </li><li>双刀</li></ul></li></ol><h2 id="七里香-2004"><a href="#七里香-2004" class="headerlink" title="七里香(2004)"></a>七里香(2004)</h2><ol><li><p>专辑简介：</p><p> 《七里香》是周杰伦2004年发行的专辑，共收录了10首歌曲。专辑的监制由周杰伦担任。专辑中的歌曲全部由周杰伦作曲，作词由方文山、周杰伦等人完成。</p></li><li><p>歌曲列表</p><ul><li>我的地盘  </li><li>七里香   </li><li>借口    </li><li>外婆</li><li>将军</li><li>搁浅</li><li>乱舞春秋  </li><li>困兽之斗  </li><li>园游会</li><li>止战之殇</li></ul></li></ol><h2 id="十一月的萧邦-2005"><a href="#十一月的萧邦-2005" class="headerlink" title="十一月的萧邦(2005)"></a>十一月的萧邦(2005)</h2><ol><li><p>专辑简介：</p><p> 《十一月的萧邦》是周杰伦2005年11月发行的专辑。作曲人为周杰伦，作词人为周杰伦、方文山等人。</p></li><li><p>歌曲列表</p><ul><li>夜曲   </li><li>蓝色风暴</li><li>发如雪 </li><li>黑色毛衣</li><li>四面楚歌</li><li>枫     </li><li>浪漫手机</li><li>逆鳞   </li><li>麦芽糖 </li><li>珊瑚海 </li><li>飘移   </li><li>一路向北</li></ul></li></ol><h2 id="依然范特西-2006"><a href="#依然范特西-2006" class="headerlink" title="依然范特西(2006)"></a>依然范特西(2006)</h2><ol><li><p>专辑简介：</p><p> 《依然范特西》是周杰伦于2006年发行的专辑，共收录了10首歌曲。该专辑的制作人和音乐总监由周杰伦担任。</p></li><li><p>歌曲列表</p><ul><li>夜的第七章</li><li>听妈妈的话</li><li>千里之外</li><li>本草纲目</li><li>退后</li><li>红模仿</li><li>心雨</li><li>白色风车</li><li>迷迭香</li><li>菊花台</li></ul></li></ol><h2 id="我很忙-2007"><a href="#我很忙-2007" class="headerlink" title="我很忙(2007)"></a>我很忙(2007)</h2><ol><li><p>专辑简介：</p><p> 《我很忙》是周杰伦2007年11月2日发行的第八张专辑，共收录了10首歌曲，由周杰伦担任专辑的监制，全碟10首歌曲均由周杰伦作曲。作词方面，周杰伦负责其中2首，其余作词工作由方文山、黄俊郎完成。专辑取名《我很忙》，实际反映出他的生活状态，忙着电影宣传、演唱会、拍广告、新专辑等。</p></li><li><p>歌曲列表</p><ul><li>牛仔很忙</li><li>彩虹</li><li>青花瓷</li><li>阳光宅男</li><li>蒲公英的约定</li><li>无双</li><li>我不配</li><li>扯</li><li>甜甜的</li><li>最长的电影</li></ul></li></ol><h2 id="魔杰座-2008"><a href="#魔杰座-2008" class="headerlink" title="魔杰座(2008)"></a>魔杰座(2008)</h2><ol><li><p>专辑简介：</p><p> 《魔杰座》是周杰伦2008年发行的专辑。作词者包括方文山、周杰伦、黄俊郎等人，编曲者包括钟兴民、林迈可、黄雨勋等人。《魔杰座》专辑的名字取自周杰伦所属的摩羯座的谐音，主打歌《稻香》的灵感来自周杰伦小时候的回忆。</p></li><li><p>歌曲列表</p><ul><li>龙战骑士</li><li>给我一首歌的时间</li><li>蛇舞</li><li>花海</li><li>魔术先生</li><li>说好的幸福呢</li><li>兰亭序</li><li>流浪诗人</li><li>时光机</li><li>乔克叔叔</li><li>周杰伦</li><li>稻香</li></ul></li></ol><h2 id="跨時代-2010"><a href="#跨時代-2010" class="headerlink" title="跨時代(2010)"></a>跨時代(2010)</h2><ol><li><p>专辑简介：</p><p> 《跨时代》是周杰伦的专辑，主要由周杰伦负责全部作曲和制作，方文山、黄俊郎等人填词，收录了11首歌曲。周杰伦希望自己的音乐就像专辑封面的吸血鬼一样，跨越时代也超越世代，因此命名为《跨时代》。除了周杰伦，杨瑞代和巨炮也在专辑中友情献声。</p></li><li><p>歌曲列表</p><ul><li>跨时代</li><li>说了再见</li><li>烟花易冷</li><li>免费教学录影带</li><li>好久不见</li><li>雨下一整晚</li><li>嘻哈空姐</li><li>我落泪·情绪零碎</li><li>爱的飞行日记</li><li>自导自演</li><li>超人不会飞</li></ul></li></ol><h2 id="惊叹号-2011"><a href="#惊叹号-2011" class="headerlink" title="惊叹号(2011)"></a>惊叹号(2011)</h2><ol><li><p>专辑简介：</p><p> 《惊叹号》是周杰伦推出的第11张专辑，2011年11月11日发行，由周杰伦作曲，方文山、黄俊郎、唐从圣等作词，共收录11首歌曲。该专辑融合多种曲风，以及不同唱腔。卡通的专辑封面具有美式漫画风格，周杰伦化身为水手，驾驭“惊叹号”船舰，坐在船沿钓鱼，心想着钓到什么大鱼，原来背后有一只章鱼在抓弄他，这也是《惊叹号》的命名缘由。</p></li><li><p>歌曲列表</p><ul><li>惊叹号 </li><li>迷魂曲</li><li>Mine Mine  </li><li>公主病  </li><li>你好吗  </li><li>疗伤烧肉粽  </li><li>琴伤  </li><li>水手怕水  </li><li>世界未末日 </li><li>皮影戏 </li><li>超跑女神</li></ul></li></ol><h2 id="十二新作-2012"><a href="#十二新作-2012" class="headerlink" title="十二新作(2012)"></a>十二新作(2012)</h2><ol><li><p>专辑简介：</p><p> 《12新作》是周杰伦推出的第十二张个人专辑，专辑中收录了周杰伦的12首作品，于2012年12月28日发行。该专辑是周杰伦出道12年以来的第12张专辑，因此取名为《12新作》。</p></li><li><p>歌曲列表</p><ul><li>四季列车  </li><li>手语    </li><li>公公偏头痛 </li><li>明明就   </li><li>傻笑    </li><li>比较大的大提琴 </li><li>爱你没差 </li><li>红尘客栈  </li><li>梦想启动  </li><li>大笨钟   </li><li>哪里都是你 </li><li>乌克丽丽</li></ul></li></ol><h2 id="哎呦，不错哦-2014"><a href="#哎呦，不错哦-2014" class="headerlink" title="哎呦，不错哦(2014)"></a>哎呦，不错哦(2014)</h2><ol><li><p>专辑简介：</p><p> 《哎呦，不错哦》是周杰伦在2014年12月发行的一张数字音乐专辑，共收录了12首歌曲。该专辑于2014年12月24日在QQ音乐上首发，并于12月26日全球同步发行。</p></li><li><p>歌曲列表</p><ul><li>阳明山       </li><li>窃爱         </li><li>算什么男人    </li><li>天涯过客     </li><li>怎么了       </li><li>一口气全念对  </li><li>我要夏天     </li><li>手写的从前    </li><li>鞋子特大号    </li><li>听爸爸的话    </li><li>美人鱼       </li><li>听见下雨的声音</li></ul></li></ol><h2 id="周杰伦的床边故事"><a href="#周杰伦的床边故事" class="headerlink" title="周杰伦的床边故事"></a>周杰伦的床边故事</h2><ol><li><p>专辑简介：</p><p> 《周杰伦的床边故事》是中国台湾歌手周杰伦创作推出的第14张个人专辑，于2016年6月24日正式发行。[在中国大陆地区发行时的实体专辑名称为《周杰伦的睡前故事》，于2016年7月8日发行。]</p></li><li><p>歌曲列表</p><ul><li>床边故事</li><li>说走就走</li><li>一点点  </li><li>前世情人</li><li>英雄   </li><li>不该   </li><li>土耳其冰淇淋    </li><li>告白气球        </li><li>Now You See Me </li><li>爱情废柴        </li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客搭建过程</title>
      <link href="/2016/03/21/gong-ju/blog-create/"/>
      <url>/2016/03/21/gong-ju/blog-create/</url>
      
        <content type="html"><![CDATA[<h1 id="建站过程"><a href="#建站过程" class="headerlink" title="建站过程"></a>建站过程</h1><h2 id="选型"><a href="#选型" class="headerlink" title="选型"></a>选型</h2><ol><li><p>本人积累了4年左右的技术文档</p></li><li><p>苦于无处管理</p></li><li><p>原先想在<a href="http://www.oschina.net" target="_blank" rel="noopener">开源中国</a>上创建博客写写文章,并且也付之行动</p></li><li><p>后来发现将这么多文档转移到开源中国上得工作量实在太大了</p></li><li><p>N久之前想学习Node.JS</p></li><li><p>在同事的推荐下,知道了Hexo这个东西</p></li><li><p>而且有很多theme可以使用,<a href="http://www.zhihu.com/question/24422335" target="_blank" rel="noopener">有哪些好看的 Hexo 主题? - GitHub - 知乎</a></p></li><li><p>而且所有的文档都是用markdown去写的</p></li><li><p>markdown的语法很简单,很容易入门上手.<a href="http://www.appinn.com/markdown/" target="_blank" rel="noopener">Markdown 语法说明(简体中文版)</a></p></li><li><p>遂,选之.</p><p>PS: 文本文档转markdown的代价也大,但是值得!</p></li></ol><a id="more"></a><h2 id="环境搭建过程"><a href="#环境搭建过程" class="headerlink" title="环境搭建过程"></a>环境搭建过程</h2><ol><li><p>首先在本地搭建Node.JS开发环境</p><ul><li><p>去Node.JS<a href="http://nodejs.org/" target="_blank" rel="noopener">官网</a>下载最新版本Node.JS,<a href="https://nodejs.org/dist/v4.4.0/node-v4.4.0-darwin-x64.tar.gz" target="_blank" rel="noopener">下载地址</a></p></li><li><p>这个是免安装版本,解压后配置环境变量即可</p><pre><code>  vim ~/.bash_profile  export NODE_JS_HOME=/Users/sunhao/Documents/tools/node-v5.6.0  export PATH=$NODE_JS_HOME:$PATH</code></pre></li><li><p>然后执行:<code>source ~/.bash_profile</code></p></li><li><p>测试是否安装成功: <code>node -v</code></p><pre><code>  sunhaodeMacBook-Pro:~ sunhao$ node -v  v5.6.0  sunhaodeMacBook-Pro:~ sunhao$</code></pre></li></ul></li><li><p>npm相关</p><ul><li><p>很久以前的Node.JS安装后需要单独安装npm的</p></li><li><p>现在不需要了,可以直接使用了</p></li><li><p>由于我大天朝强大的GFW,npm的源在天朝局域网访问很不理想</p></li><li><p>所以,阿里的大神们给大伙提供了一个npm registry镜像</p></li><li><p>配置阿里npm镜像</p><pre><code>  npm config set registry https://registry.npm.taobao.org  npm config set disturl https://npm.taobao.org/dist</code></pre></li><li><p>这下npm的速度妥妥的</p></li><li><p>参考文档:</p><ul><li><a href="http://npm.taobao.org/" target="_blank" rel="noopener">淘宝 NPM 镜像</a></li><li><a href="http://www.jb51.net/article/50671.htm" target="_blank" rel="noopener">npm介绍</a></li></ul></li></ul></li><li><p>hexo相关</p><ul><li><p>前戏都做好了,我们就进入正事吧</p></li><li><p>由于hexo是经常使用的,所以需要全局安装</p><pre><code>  npm install hexo -g</code></pre></li><li><p>测试是否安装成功<br>  <img src="/imgs/hexo/1.png" alt=""></p></li></ul></li></ol><h2 id="开始搭建博客"><a href="#开始搭建博客" class="headerlink" title="开始搭建博客"></a>开始搭建博客</h2><ol><li><p>选择一个目录</p></li><li><p>进入之后执行<code>hexo init</code></p></li><li><p>等待步骤2下载一堆依赖后,即创建好基于Hexo的博客基本目录结构<br> <img src="/imgs/hexo/2.png" alt=""></p></li><li><p>简单应用</p><ul><li><p>直接在本机运行博客</p><pre><code>  sunhaodeMacBook-Pro:test sunhao$ hexo serve  INFO  Start processing  INFO  Hexo is running at http://0.0.0.0:4000/. Press Ctrl+C to stop.</code></pre><p>  这样在本机浏览器上直接访问<code>http://localhost:4000</code>即可以访问最简单的博客</p></li><li><p>hexo构建静态文件,可以放入nginx中直接访问(本人就是这种方式)</p><pre><code>  hexo generate</code></pre><p>  生成的文件放在<code>public</code>文件夹下</p></li></ul></li><li><p>自定义一些配置</p><ul><li>在<code>_config.yml</code>中进行配置</li><li>参考<a href="https://hexo.io/docs/configuration.html" target="_blank" rel="noopener">官方文档</a></li></ul></li><li><p>自定义主题</p><ul><li><p>主题请参考<a href="http://www.zhihu.com/question/24422335" target="_blank" rel="noopener">有哪些好看的 Hexo 主题? - GitHub - 知乎</a></p></li><li><p>主题放在<code>themes</code>文件夹下</p></li><li><p>选择主题,在<code>_config.yml</code>中设置</p><pre><code>   # Extensions   ## Plugins: https://hexo.io/plugins/   ## Themes: https://hexo.io/themes/   theme: landscape</code></pre><p>  即将<code>theme</code>设置为主题文件夹名</p></li><li><p>主题配置:在每个主题文件夹下的<code>_config.yml</code>文件中</p></li></ul></li><li><p>我的主题是基于<code>yelee</code>添加了一些修改,后面会把这个修改后的主题放到git上</p><ul><li>原生的<code>yelee</code>: <a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank" rel="noopener">yelee</a></li><li>我修改后的<code>yelee</code>: <code>敬请期待</code></li></ul></li></ol><h2 id="如何进行更新博客"><a href="#如何进行更新博客" class="headerlink" title="如何进行更新博客"></a>如何进行更新博客</h2><ol><li><p>将博客整个项目文件托管到Github或者Git@OSC中</p></li><li><p>利用git的push钩子进行更新</p></li><li><p>利用Node.JS在服务器的后台启用一个服务,去接收git钩子的请求,从而进行更新</p></li><li><p>我就是采用这个方法的,所以我买了一个域名和一个阿里云服务器并且将域名备案了</p></li><li><p>搭建过程</p><ul><li><p>将项目托管到git上,我选择的是Git@OSC,毕竟是天朝局域网直接互相访问,速度快<br>  <img src="/imgs/hexo/3.png" alt=""></p></li><li><p>配置git的push钩子<br>  <img src="/imgs/hexo/4.png" alt=""></p></li><li><p>在服务器上将Node.JS+Npm+Hexo的环境搭建好</p></li><li><p>在服务器上将git上得博客pull下来,路径如:<code>/opt/blog</code></p></li><li><p>在服务器上利用Node.JS起一个服务</p><pre><code>  var express = require(&#39;express&#39;);  var app = express();  var exec = require(&#39;child_process&#39;).exec;  app.post(&#39;/hexo&#39;, function(req, res){      // 打开目录,先执行git pull      // 再执行hexo clean      // 再重新生成public文件      exec(&#39;cd /opt/blog/ &amp;&amp; git pull &amp;&amp; hexo clean &amp;&amp; hexo generate&#39;, function (error, stdout, stderr) {          console.log(&#39;stdout: &#39; + stdout);          console.log(&#39;stderr: &#39; + stderr);          if (error !== null) {              console.log(&#39;exec error: &#39; + error);          }      });      res.send(&#39;ok&#39;);  });  // 在3000端口启动监听服务  var server = app.listen(3000, function() {      console.log(&#39;Listening on port %d&#39;, server.address().port);  });</code></pre></li><li><p>注意,要写一个<code>package.json</code>文件,写明此服务所以来的组件</p><pre><code>  {    &quot;name&quot;: &quot;gitlab-hexo-webhook&quot;,    &quot;version&quot;: &quot;1.0.0&quot;,    &quot;description&quot;: &quot;gitlab钩子&quot;,    &quot;main&quot;: &quot;hexo-webhook.js&quot;,    &quot;dependencies&quot;: {      &quot;debug&quot;: &quot;^2.0.0&quot;,      &quot;express&quot;: &quot;^3.0.6&quot;    },    &quot;devDependencies&quot;: {},    &quot;scripts&quot;: {      &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;    },    &quot;author&quot;: &quot;sunhao&quot;,    &quot;license&quot;: &quot;ISC&quot;  }</code></pre></li><li><p>利用Node.JS的<code>forever</code>在后台启动此服务</p><pre><code>  forever -a start /opt/shell/gitlab-hexo-webhook/hexo-webhook.js</code></pre></li><li><p>这样每次在本地用markdown写好博客后push到git上,push钩子就会执行,去请求服务器上的这个服务,这个服务就会将博客更新后,重新generate新的<code>public</code></p></li></ul></li></ol><h2 id="部署到nginx上"><a href="#部署到nginx上" class="headerlink" title="部署到nginx上"></a>部署到nginx上</h2><ol><li><p>在服务器上安装nginx</p></li><li><p>进行配置</p><pre><code> server {     listen       80;     # 您的域名     server_name  blog.izufang.me;     location / {         // 您的博客public文件夹绝对路径         root   /opt/blog/public;         index  index.html;         try_files $uri $uri/ /index.html;         expires -1;     } }</code></pre></li><li><p>在您的域名提供商设置域名解析即可</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 站务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux_Ubuntu下安装配置Svn+Apache服务器</title>
      <link href="/2016/03/18/zhong-jian-jian/linux-ubuntu-install-svn-apache/"/>
      <url>/2016/03/18/zhong-jian-jian/linux-ubuntu-install-svn-apache/</url>
      
        <content type="html"><![CDATA[<h2 id="安装-Subversion"><a href="#安装-Subversion" class="headerlink" title="安装 Subversion"></a>安装 Subversion</h2><ol><li><p>安装 Subversion</p><pre><code> sudo apt-get install subversion</code></pre><a id="more"></a></li><li><p>创建仓库</p><pre><code> svnadmin create /opt/svn/message</code></pre><p> <code>/opt/svn/message</code>为svn仓库所要创建到的目录，如创建目录的位置需要root权限，使用<code>sudo svnadmin</code></p></li><li><p>修改配置文件 </p><pre><code> sudo vi /opt/svn/message/conf/svnserve.conf #去掉#[general]前面的#号   [general]   #匿名访问的权限，可以是read,write,none,默认为read   anon-access = none #认证用户的权限，可以是read,write,none,默认为write   auth-access = write #密码数据库的路径，去掉前面的#   password-db = passwd</code></pre></li><li><p>修改配置文件<code>passwd</code></p><pre><code> [users]   admin = admin</code></pre><p> 一定要去掉[users]前面的#,否则svn只能以匿名用户登录，客户端不会出现登录窗口，除非你的anon不为none,否则将返回一个错误。这里的密码是没有加密的，后面在apache时，会讲到用htppasswd生成加密的密码。</p></li></ol><p>到这里，Svn服务器已经配置好了。一些命令:</p><pre><code>#停止Subversion服务器sudo killall svnserve#启动Subversion服务器svnserve -d -r /opt/svn/message其中-d表示在后台运行，-r指定服务器的根目录，这样访问服务器时就可以直接 用svn://服务器ip来访问了。</code></pre><h2 id="安装apache服务器-第34步骤可以省略"><a href="#安装apache服务器-第34步骤可以省略" class="headerlink" title="安装apache服务器(第34步骤可以省略)"></a>安装apache服务器(第34步骤可以省略)</h2><ol><li><p>安装Apache服务器</p><pre><code> sudo apt-get install libapache2-svn sudo apt-get install apache2</code></pre><p> 在<code>/etc/apache2/mods-available/dav_svn.load</code>最后一行加上一下一句话</p><pre><code> LoadModule authz_svn_module /usr/lib/apache2/modules/mod_authz_svn.so</code></pre></li><li><p>此时如果出现以下错误：</p><pre><code> sudo /etc/init.d/apache2 restart 时失败  提示：No apache MPM package installed </code></pre><p> 则还要下载一个文件,执行以下命令:</p><pre><code> sudo apt-get install apache2-mpm-worker</code></pre></li><li><p>添加subversion管理用户及svn组</p><pre><code> sudo adduser svn sudo addgroup svn svn</code></pre></li><li><p>版本仓库。</p><p> 版本仓库我们用第一步中所创建的，这时需要为它加一些用户权限<br/><br> 这里要为apache用到的www-data添加权限</p><pre><code> sudo chown -R root:svn /opt/svn/message sudo chown -R www-data:www-data /opt/svn/message</code></pre><p> 赋予组成员对所有新加入文件仓库拥有相应的权限</p><pre><code> sudo chmod -R g+rws /opt/svn/message</code></pre></li><li><p>添加用户并设置权限</p><p> 这里注意了,通过http访问的账号是Apachehttp验证的。<br> 通过svn://访问的账号是svn仓库conf目录下passwd指定的。两个是独立的认证方式。<br> 如果用同一个passwd文件 就会出现http跟svn只能有其中一个能访问<br> 因为htpasswd创建用户的密码是加密的,相反原始passwd文件里的用户是没加密的</p><p> 这里我们用htpasswd创建密码文件，取名pwdfile</p><pre><code> htpasswd -c /opt/svn/message/conf/pwdfile admin</code></pre><p> 执行上面语句后，创建admin账号，以及会要输入密码等东东，安提示完成就行了。<br> 如果要加第二个用户，要把 -c 参数去掉，否则会覆盖掉前面文件。</p></li><li><p>配置httpd.conf文件</p><pre><code> sudo vi /etc/apache2/mods-enabled/dav_svn.conf</code></pre><p> 在最后面添加下面内容</p><pre><code> &lt;Location /message&gt;     DAV svn     SVNPath /opt/svn/message     AuthType Basic     AuthName &quot;SVN 认证名称&quot;     AuthUserFile /opt/svn/message/conf/pwdfile     #&lt;LimitExcept GET PROPFIND OPTIONS REPORT&gt;         Require valid-user     #&lt;/LimitExcept&gt; &lt;/Location&gt;</code></pre></li></ol><pre><code>此时 AuthUserFile ，要指定pwdfile</code></pre><ol start="7"><li><p>重启apache和svn就可以了</p><pre><code> sudo /etc/init.d/apache2 restart sudo svnserve -d -r /opt/svn/message</code></pre></li></ol><ol start="8"><li>打开浏览器 访问: <code>http://sunhao-java.vicp.cc/message</code> 输入 admin 密码：admin 就可以进去了！</li><li>用svn客户端访问: <code>svn://sunhao-java.vicp.cc/</code>  输入用户名和密码就可以进去了！</li></ol><h2 id="dav-svn-conf文件"><a href="#dav-svn-conf文件" class="headerlink" title="dav_svn.conf文件"></a>dav_svn.conf文件</h2><pre><code>#demo for svn#&lt;Location /svn&gt;#    DAV svn#    SVNPath /opt/test/demo #    AuthType Basic#    AuthName &quot;SVN 认证名称&quot;#    AuthUserFile /opt/test/demo/conf/pwdfile#    #&lt;LimitExcept GET PROPFIND OPTIONS REPORT&gt;#        Require valid-user#    #&lt;/LimitExcept&gt;#&lt;/Location&gt;#message&lt;Location /message&gt;    DAV svn    SVNPath /opt/svn/message    AuthType Basic    AuthName &quot;SVN 认证名称&quot;    AuthUserFile /opt/svn/message/conf/pwdfile    #&lt;LimitExcept GET PROPFIND OPTIONS REPORT&gt;        Require valid-user    #&lt;/LimitExcept&gt;&lt;/Location&gt;#messageboard&lt;Location /messageboard&gt;    DAV svn    SVNPath /opt/svn/messageboard    AuthType Basic    AuthName &quot;SVN 认证名称&quot;    AuthUserFile /opt/svn/messageboard/conf/pwdfile    #&lt;LimitExcept GET PROPFIND OPTIONS REPORT&gt;        Require valid-user    #&lt;/LimitExcept&gt;&lt;/Location&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Ubuntu </tag>
            
            <tag> Svn </tag>
            
            <tag> Apache </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MongoDB_安装</title>
      <link href="/2016/03/18/zhong-jian-jian/mongodb-install/"/>
      <url>/2016/03/18/zhong-jian-jian/mongodb-install/</url>
      
        <content type="html"><![CDATA[<ol><li><p>已管理员身份运行命令行</p></li><li><p>输入命令</p><a id="more"></a><pre><code> mongod --dbpath &quot;F:\mongodb\data\db&quot; --logpath &quot;F:\mongodb\data\log\MongoDB.log&quot; --install --serviceName &quot;MongoDB&quot;</code></pre><p> 其中：</p><ul><li>dbpath: 数据库数据文件路径</li><li>logpath:    数据库日志文件路径</li><li>serviceName:    注册的服务名称</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MongoDB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nginx过滤url实现前台js的配置问题</title>
      <link href="/2016/03/18/zhong-jian-jian/nginx-url/"/>
      <url>/2016/03/18/zhong-jian-jian/nginx-url/</url>
      
        <content type="html"><![CDATA[<blockquote><p>我们在开发的过程中,可能需要一些配置,这些配置可能就是仅仅为了开发的方便,比方说,订单过期时间,生产环境需要半小时失效,但是真正开发时,我不可能等上个半小时,所以这个时间这个失效时间我们会写在配置文件中,这样开发环境和生产环境各一套配置,来回切换很方便的.</p></blockquote><a id="more"></a><ul><li><p>基于摘要里的,在Java后台实现很方便,只需要读取properties配置文件即可</p></li><li><p>但是在前台js,js是在浏览器里执行的,无法读取服务器上的配置,除非请求后台,但是每次的开销也是挺大的,所以这个想法被ps了</p></li><li><p>这时候可以利用nginx,前台静态页面是部署在nginx中,所以我们可以配置nginx过滤某个js的url,然后指向我们需要的文件</p></li><li><p>前台代码</p><pre><code>index.html&lt;!-- 即配置文件 --&gt;&lt;script src=&quot;/config.js&quot;&gt;&lt;/script&gt;&lt;!-- 动态加载js --&gt;&lt;script type=&quot;application/javascript&quot;&gt;  if (config.devMode == &#39;dev&#39;) {      loadJs(&quot;开发环境的js&quot;);  } else {      loadJs(&quot;开发环境的js&quot;);  }  function loadJs(url, callback) {      // 实现  }&lt;/script&gt;</code></pre></li><li><p>配置文件(生产环境配置和开发环境的配置在不同路径下,但是文件名同名)</p><pre><code>var config = {  // 或者 prd  devMode: &#39;dev&#39;,  // 还可以配置请求后台的url前缀  serverUrl: &#39;http://dev.company.com&#39;  // serverUrl: &#39;http://api.company.com&#39;}</code></pre></li><li><p>nginx的配置</p><pre><code>server {  listen       80;  server_name  www.company.com;  location / {      root /Users/sunhao/Documents/company/project;      index index.html;      try_files $uri $uri/ /index.html;      expires -1;  }}server {  listen       80;  server_name  debug.company.com;  location / {      root /Users/sunhao/Documents/company/project;      index index.html;      try_files $uri $uri/ /index.html;      expires -1;  }  location ~ .flower\.js$ {      root /Users/sunhao/Documents/company/project/js;  }}</code></pre><ul><li>前一个server配置的是生产环境,正常配置</li><li>后一个,过滤flower.js,定向到另外一个文件夹下</li></ul></li><li><p>访问<a href="http://www.company.com就是正式环境" target="_blank" rel="noopener">www.company.com就是正式环境</a></p></li><li><p>访问debug.company.com就是开发环境了</p></li><li><p>这样就可以实现配置的功能了</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> frontend </tag>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Solr删除数据的几种方式</title>
      <link href="/2016/03/18/zhong-jian-jian/solr-delete-index/"/>
      <url>/2016/03/18/zhong-jian-jian/solr-delete-index/</url>
      
        <content type="html"><![CDATA[<blockquote><p>有时候需要删除 Solr 中的数据（特别是不重做索引的系统中，在重做索引期间）。删除一些 Solr无效数据（或不合格数据）。</p></blockquote><a id="more"></a><h1 id="删除-solr-中的数据有几种方式："><a href="#删除-solr-中的数据有几种方式：" class="headerlink" title="删除 solr 中的数据有几种方式："></a>删除 solr 中的数据有几种方式：</h1><h2 id="先来看-curl-方式："><a href="#先来看-curl-方式：" class="headerlink" title="先来看 curl 方式："></a>先来看 curl 方式：</h2><pre><code>curl http://localhost:8080/solr/update --data-binary &quot;&lt;delete&gt;&lt;query&gt;title:abc&lt;/query&gt;&lt;/delete&gt;&quot; -H &#39;Content-type:text/xml; charset=utf-8&#39;  #删除完后，要提交  curl http://localhost:8080/solr/update --data-binary &quot;&lt;commit/&gt;&quot; -H &#39;Content-type:text/xml; charset=utf-8&#39;  </code></pre><h2 id="用自带的-post-jar，在-apache-solr-XXX-example-exampledocs-目录下："><a href="#用自带的-post-jar，在-apache-solr-XXX-example-exampledocs-目录下：" class="headerlink" title="用自带的 post.jar，在 apache-solr-XXX\example\exampledocs 目录下："></a>用自带的 post.jar，在 apache-solr-XXX\example\exampledocs 目录下：</h2><pre><code>java -Ddata=args  -jar post.jar &quot;&lt;delete&gt;&lt;id&gt;42&lt;/id&gt;&lt;/delete&gt;&quot;  #怎么使用 post.jar 查看帮助    java -jar post.jar -help  </code></pre><h2 id="直接用-url，使用-stream-相关参数："><a href="#直接用-url，使用-stream-相关参数：" class="headerlink" title="直接用 url，使用 stream 相关参数："></a>直接用 url，使用 stream 相关参数：</h2><pre><code>比如：http://localhost:80/solr/update/?stream.body=&lt;delete&gt;&lt;query&gt;*:*&lt;/query&gt;&lt;/delete&gt;&amp;stream.contentType=text/xml;charset=utf-8&amp;commit=truestream 相关参数还有：stream.file=（服务器本地文件），stream.url 分别指到你的删除文本，这里是直接字符串内容用 stream.body 参数。commit 参数是指提交，提交了才能看到删除效果。</code></pre><h2 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h2><blockquote><p>其实，方式1、2原理一样，直接 POST xml 数据过去。方式3就是直接可以告诉服务器从那些地方取删除的 xml 内容。</p></blockquote><p>删除指令有两种:</p><ol><li>用 <id></id> 包装；</li><li><query></query> 包装。</li></ol><p>指令都很明显，一个是 id 值（是在 schema.xml 的 uniqueKey 所指字段的值，而不是索引内部的 docId）；query 值是查询串，如：title:”solr lucene”。</p>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Solr </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring3.0.5的工具类</title>
      <link href="/2016/03/18/hou-duan/spring-3.0.5-utils/"/>
      <url>/2016/03/18/hou-duan/spring-3.0.5-utils/</url>
      
        <content type="html"><![CDATA[<blockquote><p>spring给我们提供了很多的工具类, 应该在我们的日常工作中很好的利用起来. 它可以大大的减轻我们的平时编写代码的长度. 因我们只想用spring的工具类,而不想把一个大大的spring工程给引入进来. 下面是我从spring3.0.5里抽取出来的工具类.</p></blockquote><a id="more"></a><h1 id="内置的resouce类型"><a href="#内置的resouce类型" class="headerlink" title="内置的resouce类型"></a>内置的resouce类型</h1><pre><code>UrlResourceClassPathResourceFileSystemResourceServletContextResourceInputStreamResourceByteArrayResourceEncodedResource 也就是Resource加上encoding, 可以认为是有编码的资源VfsResource (在jboss里经常用到, 相应还有 工具类 VfsUtils)org.springframework.util.xml.ResourceUtils  用于处理表达资源字符串前缀描述资源的工具. 如: classpath:.有 getURL, getFile, isFileURL, isJarURL, extractJarFileURL</code></pre><h1 id="工具类"><a href="#工具类" class="headerlink" title="工具类"></a>工具类</h1><pre><code>org.springframework.core.annotation.AnnotationUtils 处理注解org.springframework.core.io.support.PathMatchingResourcePatternResolver 用于处理 ant 匹配风格(com/*.jsp, com/**/*.jsp),找出所有的资源, 结合上面的resource的概念一起使用,对于遍历文件很有用. 具体请详细查看javadocorg.springframework.core.io.support.PropertiesLoaderUtils 加载Properties资源工具类,和Resource结合org.springframework.core.BridgeMethodResolver 桥接方法分析器.关于桥接方法请参考: http://java.sun.com/docs/books/jls/third_edition/html/expressions.html#15.12.4.5org.springframework.core.GenericTypeResolver 范型分析器, 在用于对范型方法, 参数分析.org.springframework.core.NestedExceptionUtils</code></pre><h1 id="xml工具"><a href="#xml工具" class="headerlink" title="xml工具"></a>xml工具</h1><pre><code>org.springframework.util.xml.AbstractStaxContentHandlerorg.springframework.util.xml.AbstractStaxXMLReaderorg.springframework.util.xml.AbstractXMLReaderorg.springframework.util.xml.AbstractXMLStreamReaderorg.springframework.util.xml.DomUtilsorg.springframework.util.xml.SimpleNamespaceContextorg.springframework.util.xml.SimpleSaxErrorHandlerorg.springframework.util.xml.SimpleTransformErrorListenerorg.springframework.util.xml.StaxUtilsorg.springframework.util.xml.TransformerUtils</code></pre><h1 id="其它工具集"><a href="#其它工具集" class="headerlink" title="其它工具集"></a>其它工具集</h1><pre><code>org.springframework.util.xml.AntPathMatcher ant风格的处理org.springframework.util.xml.AntPathStringMatcherorg.springframework.util.xml.Assert 断言,在我们的参数判断时应该经常用org.springframework.util.xml.CachingMapDecoratororg.springframework.util.xml.ClassUtils 用于Class的处理org.springframework.util.xml.CollectionUtils 用于处理集合的工具org.springframework.util.xml.CommonsLogWriterorg.springframework.util.xml.CompositeIteratororg.springframework.util.xml.ConcurrencyThrottleSupportorg.springframework.util.xml.CustomizableThreadCreatororg.springframework.util.xml.DefaultPropertiesPersisterorg.springframework.util.xml.DigestUtils 摘要处理, 这里有用于md5处理信息的org.springframework.util.xml.FileCopyUtils 文件的拷贝处理, 结合Resource的概念一起来处理, 真的是很方便org.springframework.util.xml.FileSystemUtilsorg.springframework.util.xml.LinkedCaseInsensitiveMap key值不区分大小写的LinkedMaporg.springframework.util.xml.LinkedMultiValueMap 一个key可以存放多个值的LinkedMaporg.springframework.util.xml.Log4jConfigurer 一个log4j的启动加载指定配制文件的工具类org.springframework.util.xml.NumberUtils 处理数字的工具类, 有parseNumber 可以把字符串处理成我们指定的数字格式, 还支持format格式, convertNumberToTargetClass 可以实现Number类型的转化.org.springframework.util.xml.ObjectUtils 有很多处理null object的方法. 如nullSafeHashCode, nullSafeEquals, isArray, containsElement, addObjectToArray, 等有用的方法org.springframework.util.xml.PatternMatchUtils spring里用于处理简单的匹配. 如 Spring&#39;s typical xxx*, *xxx and *xxx* pattern stylesorg.springframework.util.xml.PropertyPlaceholderHelper 用于处理占位符的替换org.springframework.util.xml.ReflectionUtils 反映常用工具方法. 有 findField, setField, getField, findMethod, invokeMethod等有用的方法org.springframework.util.xml.SerializationUtils 用于java的序列化与反序列化. serialize与deserialize方法org.springframework.util.xml.StopWatch 一个很好的用于记录执行时间的工具类, 且可以用于任务分阶段的测试时间. 最后支持一个很好看的打印格式. 这个类应该经常用org.springframework.util.xml.StringUtilsorg.springframework.util.xml.SystemPropertyUtilsorg.springframework.util.xml.TypeUtils 用于类型相容的判断. isAssignableorg.springframework.util.xml.WeakReferenceMonitor 弱引用的监控</code></pre><h1 id="和web相关的工具"><a href="#和web相关的工具" class="headerlink" title="和web相关的工具"></a>和web相关的工具</h1><pre><code>org.springframework.web.util.CookieGeneratororg.springframework.web.util.HtmlCharacterEntityDecoderorg.springframework.web.util.HtmlCharacterEntityReferencesorg.springframework.web.util.HtmlUtilsorg.springframework.web.util.HttpUrlTemplate 这个类用于用字符串模板构建url, 它会自动处理url里的汉字及其它相关的编码. 在读取别人提供的url资源时, 应该经常用String url = &quot;http://localhost/myapp/{name}/{id}&quot;org.springframework.web.util.JavaScriptUtilsorg.springframework.web.util.Log4jConfigListener 用listener的方式来配制log4j在web环境下的初始化org.springframework.web.util.UriTemplateorg.springframework.web.util.UriUtils 处理uri里特殊字符的编码org.springframework.web.util.WebUtils</code></pre>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>windows7共享网络</title>
      <link href="/2016/03/18/gong-ju/windows7-share-network/"/>
      <url>/2016/03/18/gong-ju/windows7-share-network/</url>
      
        <content type="html"><![CDATA[<ol><li><p>以管理员身份运行命令提示符：</p><pre><code>   快捷键win+R→输入cmd→回车</code></pre></li></ol><a id="more"></a><ol start="2"><li><p>启用并设定虚拟WiFi网卡：</p><pre><code>   运行命令： netsh wlan set hostednetwork mode=allow ssid=你的wifi名字 key=你的密码</code></pre></li><li><p>设置Internet连接共享：</p><pre><code>   在“网络连接”窗口中，右键单击已连接到Internet的网络连接，选择“属性”→“共享” 勾上“允许其他........连接(N)” 并选择刚才建立的wifi(直接选本地连接即可)</code></pre></li><li><p>开启无线网络：</p><pre><code> 继续在命令提示符中运行：netsh wlan start hostednetwork</code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> windows7 </tag>
            
            <tag> 共享网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows下创建软连接</title>
      <link href="/2016/03/18/gong-ju/windows-soft-link/"/>
      <url>/2016/03/18/gong-ju/windows-soft-link/</url>
      
        <content type="html"><![CDATA[<h1 id="要求"><a href="#要求" class="headerlink" title="要求:"></a>要求:</h1><ol><li><p>文件类型为NFS</p></li><li><p>使用junction</p><p> <code>下载junction(http://technet.microsoft.com/en-us/sysinternals/bb896768)</code></p></li></ol><a id="more"></a><h1 id="创建软连接"><a href="#创建软连接" class="headerlink" title="创建软连接"></a>创建软连接</h1><p>语法:</p><pre><code>junction [-s] destDir srcDir举例:junction -s message-test\src\main\webapp\js\easyjs message-easyjs\easyjs</code></pre><h1 id="删除软连接"><a href="#删除软连接" class="headerlink" title="删除软连接"></a>删除软连接</h1><p>语法:</p><pre><code>junction -d linkPath举例junction -d message-test\src\main\webapp\js\easyjs</code></pre>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux_oracle管理</title>
      <link href="/2016/03/18/shu-ju-ku/linux-oracle-manager/"/>
      <url>/2016/03/18/shu-ju-ku/linux-oracle-manager/</url>
      
        <content type="html"><![CDATA[<h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><ol><li><code>su - oracle</code> 切换到oracle用户且切换到它的环境</li><li><code>lsnrctl status</code> 查看监听及数据库状态</li><li><code>lsnrctl start</code> 启动监听</li><li><code>sqlplus /nolog</code> 进入sqlplus</li><li><code>SQL&gt; conn / as sysdba</code> 以DBA身份登录</li><li><code>SQL&gt; startup</code> 启动db</li></ol><a id="more"></a><h2 id="停止"><a href="#停止" class="headerlink" title="停止"></a>停止</h2><ol><li><p><code>su - oracle</code> 切换到oracle用户且切换到它的环境</p></li><li><p><code>lsnrctl stop</code> 停止监听</p></li><li><p><code>sqlplus /nolog</code> 进入sqlplus</p></li><li><p><code>SQL&gt;conn / as sysdba</code> 以DBA身份登录</p></li><li><p><code>SQL&gt;SHUTDOWN IMMEDIATE</code> 关闭db</p><p>  其中startup和shutdowm还有其他一些可选参数，有兴趣可以另行查阅</p></li></ol><h2 id="查看初始化参数及修改"><a href="#查看初始化参数及修改" class="headerlink" title="查看初始化参数及修改"></a>查看初始化参数及修改</h2><ol><li><code>su - oracle</code> 切换到oracle用户且切换到它的环境</li><li><code>sqlplus / as sysdba</code> 进入sqlplus</li><li><code>SQL&gt;conn / as sysdba</code> 以DBA身份登录</li><li><code>SQL&gt;show parameter session;</code> 查看所接受的session数量</li><li><code>SQL&gt;alter system set shared_servers=10;</code> 将shared_servers的数量设置为10</li></ol><h2 id="数据库连接数目"><a href="#数据库连接数目" class="headerlink" title="数据库连接数目"></a>数据库连接数目</h2><ol><li><p>其中一个数据库连接需要一个session,它的值由processes决定，session与processes通常有以下关系：</p><pre><code> session = 1.1 * processes + 5</code></pre></li><li><p>以<code>sysdba</code>身份登陆PL/SQL 或者 Worksheet</p><ul><li><p>查询目前连接数</p><pre><code>  show parameter processes;</code></pre></li><li><p>更改系统连接数</p><pre><code>  alter system set processes=1000 scope=spfile;</code></pre></li><li><p>创建pfile</p><pre><code>  create pfile from spfile;</code></pre></li><li><p>重启Oracle服务或重启Oracle服务器</p><p>不过这也不是绝对的，还要受到CPU和内存等硬件条件的限制。另外 processes和session不可以通过alter system语句直接修改，只可以修改服务器参数文件来更改(Server Parameter File)。如果存在一个server parameter file，通过alter system语句所作的更改将会被持久化到文件中。</p></li></ul></li></ol><h2 id="查询Oracle游标使用情况的方法"><a href="#查询Oracle游标使用情况的方法" class="headerlink" title="查询Oracle游标使用情况的方法"></a>查询Oracle游标使用情况的方法</h2><pre><code>   select * from v$open_cursor where user_name = &#39;TRAFFIC&#39;；</code></pre><h2 id="查询Oracle会话的方法"><a href="#查询Oracle会话的方法" class="headerlink" title="查询Oracle会话的方法"></a>查询Oracle会话的方法</h2><pre><code>   select * from v$session</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> database </tag>
            
            <tag> oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL常用命令</title>
      <link href="/2016/03/18/shu-ju-ku/mysql-command/"/>
      <url>/2016/03/18/shu-ju-ku/mysql-command/</url>
      
        <content type="html"><![CDATA[<ol><li><p>显示当前数据库服务器中的数据库列表：</p><pre><code> mysql&gt; SHOW DATABASES;</code></pre><p> 注意：mysql库里面有MYSQL的系统信息，我们改密码和新增用户，实际上就是用这个库进行操作。</p></li></ol><a id="more"></a><ol start="2"><li><p>显示数据库中的数据表：</p><pre><code> mysql&gt; USE 库名； mysql&gt; SHOW TABLES;</code></pre></li><li><p>显示数据表的结构：</p><pre><code> mysql&gt; DESCRIBE 表名;</code></pre></li><li><p>建立数据库：</p><pre><code> mysql&gt; CREATE DATABASE 库名;</code></pre></li><li><p>建立数据表：</p><pre><code> mysql&gt; USE 库名; mysql&gt; CREATE TABLE 表名 (字段名 VARCHAR(20), 字段名 CHAR(1));</code></pre></li><li><p>删除数据库：</p><pre><code> mysql&gt; DROP DATABASE 库名;</code></pre></li><li><p>删除数据表：</p><pre><code> mysql&gt; DROP TABLE 表名；</code></pre></li><li><p>将表中记录清空：</p><pre><code> mysql&gt; DELETE FROM 表名;</code></pre></li><li><p>显示表中的记录：</p><pre><code> mysql&gt; SELECT * FROM 表名;</code></pre></li><li><p>往表中插入记录：</p><pre><code>mysql&gt; INSERT INTO 表名 VALUES (”hyq”,”M”);</code></pre></li><li><p>更新表中数据：</p><pre><code>mysql-&gt; UPDATE 表名 SET 字段名1=’a&#39;,字段名2=’b’ WHERE 字段名3=’c&#39;;</code></pre></li><li><p>用文本方式将数据装入数据表中：</p><pre><code>mysql&gt; LOAD DATA LOCAL INFILE “D:/mysql.txt” INTO TABLE 表名;</code></pre></li><li><p>导入.sql文件命令：</p><pre><code>mysql&gt; USE 数据库名;mysql&gt; SOURCE d:/mysql.sql;</code></pre></li><li><p>命令行修改root密码：</p><pre><code>mysql&gt; UPDATE mysql.user SET password=PASSWORD(’新密码’) WHERE User=’root’;mysql&gt; FLUSH PRIVILEGES;</code></pre></li><li><p>显示use的数据库名：</p><pre><code>mysql&gt; SELECT DATABASE();</code></pre></li><li><p>显示当前的user：</p><pre><code>mysql&gt; SELECT USER();</code></pre></li><li><p>一个建库和建表以及插入数据的实例</p><pre><code>drop database if exists school; //如果存在SCHOOL则删除create database school; //建立库SCHOOLuse school; //打开库SCHOOLcreate table teacher //建立表TEACHER(    id int(3) auto_increment not null primary key,    name char(10) not null,    address varchar(50) default ‘深圳’,    year date); //建表结束//以下为插入字段insert into teacher values(”,’allen’,&#39;大连一中’,&#39;1976-10-10′);insert into teacher values(”,’jack’,&#39;大连二中’,&#39;1975-12-23′);</code></pre><p>如果你在mysql提示符键入上面的命令也可以，但不方便调试。</p><ol><li><p>你可以将以上命令原样写入一个文本文件中，假设为school.sql，然后复制到c:\下，然后键入以下命令：</p><pre><code> mysql -uroot -p密码 &lt; c:\\school.sql</code></pre><p>如果成功，空出一行无任何显示；如有错误，会有提示。（以上命令已经调试，你只要将//的注释去掉即可使用）。</p></li><li><p>或者进入命令行后使用 <code>mysql&gt; source c:\\school.sql</code>; 也可以将<code>school.sql</code>文件导入数据库中。</p></li></ol></li><li><p>将文本数据转到数据库中</p><ol><li><p>文本数据应符合的格式：字段数据之间用tab键隔开，null值用空格来代替.例：</p><pre><code> 3 rose 大连二中 1976-10-10 4 mike 大连一中 1975-12-23</code></pre><p> 假设你把这两组数据存为school.txt文件，放在c盘根目录下。</p></li><li><p>数据传入命令 <code>load data local infile “c:\\school.txt” into table 表名</code>;</p><p> 注意：你最好将文件复制到<code>\\mysql\\bin</code>目录下，并且要先用use命令打表所在的库。</p></li></ol></li><li><p>备份数据库</p><ol><li><p>导出整个数据库</p><p> 导出文件默认是存在mysql\bin目录下</p><pre><code> mysqldump -u 用户名 -p 数据库名 &gt; 导出的文件名 mysqldump -u user_name -p123456 database_name &gt; outfile_name.sql</code></pre></li><li><p>导出一个表</p><pre><code> mysqldump -u 用户名 -p 数据库名 表名&gt; 导出的文件名 mysqldump -u user_name -p database_name table_name &gt; outfile_name.sql</code></pre></li><li><p>导出一个数据库结构</p><pre><code> mysqldump -u user_name -p -d –add-drop-table database_name &gt; outfile_name.sql</code></pre><ul><li>-d 没有数据</li><li>–add-drop-table 在每个create语句之前增加一个drop table</li></ul></li><li><p>带语言参数导出</p><pre><code> mysqldump -uroot -p –default-character-set=latin1 –set-charset=gbk –skip-opt database_name &gt; outfile_name.sql</code></pre></li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> database </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL_修改root帐号密码</title>
      <link href="/2016/03/18/shu-ju-ku/mysql-update-root-pwd/"/>
      <url>/2016/03/18/shu-ju-ku/mysql-update-root-pwd/</url>
      
        <content type="html"><![CDATA[<blockquote><p>如果你忘了 MySQL 的 root 帐号密码，别担心，使用下面步骤就可以重设一个新密码：</p></blockquote><ol><li><p>首先停止 MySQL 服务 <code>/etc/init.d/mysql stop</code></p></li><li><p>启动 MySQL 服务并屏蔽用户权限检查，可通过如下命令：</p></li><li><a id="more"></a><pre><code>  mysqld_safe --skip-grant-tables</code></pre><p>  记住，当你使用这个参数启动服务时，任何人无需密码即可连接到 MySQL 并拥有最高权限，因此你需要确定你在做这个的过程中，别让其他人访问数据库。可以使用如下命令来拒绝网络连接：</p><pre><code>  mysqld_safe --skip-grant-tables --skip-networking</code></pre><p>  这样就只能通过本机连接到 MySQL 服务器</p></li><li><p>然后使用 <code>mysql -u anything</code> 命令来连接到 MySQL</p></li><li><p>执行 SQL 语句：</p><pre><code> update mysql.user set Password=PASSWORD(‘new-password’) WHERE User=’root’</code></pre></li><li><p>用 <code>mysqladmin -u qualquer_coisa shutdown</code> 命令停止 MySQL 服务，然后以正常模式启动 MySQL 即可</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> database </tag>
            
            <tag> MySQL </tag>
            
            <tag> root </tag>
            
            <tag> 密码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Oracle_降级导入导出</title>
      <link href="/2016/03/18/shu-ju-ku/oracle-expdb-impdb/"/>
      <url>/2016/03/18/shu-ju-ku/oracle-expdb-impdb/</url>
      
        <content type="html"><![CDATA[<blockquote><p>使用oracle的expdp和impdp</p></blockquote><a id="more"></a><ol><li><p>在服务器上<code>expdb</code>一下,服务器是<code>Linux</code>,切换到<code>oracle</code>用户,进行下面的操作:</p><pre><code> expdp userid=usr_oa_new/usr_oa_new@192.168.102.202:1521/urpdb schemas=usr_oa_new directory=test dumpfile=usr_oa_new_20130826.dmp logfile=log_20130826.log version=10.02.01</code></pre><p> 注意:</p><ul><li><p><code>userid=usr_oa_new/usr_oa_new@192.168.102.202:1521/urpdb</code> 不用说了,源数据库的信息</p></li><li><p><code>schemas=usr_oa_new</code> 该方案用于指定执行方案模式导出,默认为当前用户方案.</p></li><li><p><code>directory=test</code> 这里需要用有dba权限的oracle用户登录数据库新建一个目录地址,这里非真正的硬盘物理路径,仅仅相当于一个在oracle中的代号</p></li><li><p><code>create directory test as &#39;/home/oracle&#39;;</code></p></li><li><p><code>grant read,write on directory test to usr_oa_new;</code></p></li><li><p><code>dumpfile=usr_oa_new_20130826.dmp以及logfile=log_20130826.log</code> 你懂滴</p></li><li><p><code>version=10.02.01</code> 这个很重要,这里指定你希望以哪个版本的oracle的dmp导出,即目标数据库的版本号</p><p>至此,导出部分已经OK了.</p></li></ul></li><li><p>在目标数据库所在服务器上使用impdp,通常情况为windows系统</p><pre><code> impdp userid=usr_oa_cumt_new/usr_oa_cumt_new@sunhao remap_schema=usr_oa_new:usr_oa_cumt_new directory=test_2 dumpfile=usr_oa_new_20130826.dmp logfile=impdp.log table_exists_action=replace version=10.02.01</code></pre><p> 注意:</p><ul><li><code>userid=usr_oa_cumt_new/usr_oa_cumt_new@sunhao</code> the same as expdp</li><li><code>remap_schema=usr_oa_new:usr_oa_cumt_new</code> 如果目标用户与源用户一致,则可以不写,否则,格式为<code>remap_schema=源:目标</code></li><li><code>directory,dumpfile,logfile</code> the same as expdp</li><li><code>table_exists_action=replace</code> 表存在的时候怎么办</li><li><code>version=10.02.01</code> 要导入的数据库版本</li></ul></li></ol><p>如果报错:</p><pre><code>remap_schema需要权限,就用dba权限的用户设置权限去:grant imp_full_database to usr_oa_cumt_new;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> database </tag>
            
            <tag> Oracle </tag>
            
            <tag> 降级 </tag>
            
            <tag> 导入 </tag>
            
            <tag> 导出 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Oracle_关于oracle导入导出数据库表结构和数据</title>
      <link href="/2016/03/18/shu-ju-ku/oracle-export-import/"/>
      <url>/2016/03/18/shu-ju-ku/oracle-export-import/</url>
      
        <content type="html"><![CDATA[<ol><li>首先在系统环境变量中新建环境变量<code>ORACLE_HOME=F:\study\oracle\product\10.1.0\db_1</code>(视自己数据安装路径而定)</li><li>在path环境变量最后添加<code>%ORACLE_HOME%/BIN</code></li></ol><a id="more"></a><ol start="3"><li><p>在命令行中输入<code>exp username/password@dbname file=backup file path</code></p><ul><li><p>username: 导出数据库用户名</p></li><li><p>password: 导出数据库密码</p></li><li><p>backup file path: 数据库备份文件存放路径</p><p>如：</p><p>  exp scott/123456@sunhao file=d:\1.dmp</p></li></ul></li><li><p>在命令行中输入<code>imp tousername/password@dbname file=backup file path fromuser=fromusername touser=tousername</code></p><ul><li><p>tousername:        要导入的数据库用户名</p></li><li><p>password:        要导入的数据库密码</p></li><li><p>backup file path:    数据库备份文件存放路径</p></li><li><p>fromusername:        要导入的数据库用户名</p></li><li><p>tousername:        导入的那个数据库用户名</p><p>如：</p><p>  imp usr_oa_sys/usr_oa_sys@SUNHAO file=d:\oa_show.dmp fromuser=usr_oa_show touser=usr_oa_sys<br>5、导入导出单张表：</p><p>在exp或者imp语句后面加上<code>tables(table1,table2,...)</code></p></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> database </tag>
            
            <tag> Oracle </tag>
            
            <tag> 导入 </tag>
            
            <tag> 导出 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Oracle_忘记密码解决方案</title>
      <link href="/2016/03/18/shu-ju-ku/oracle-forget-password/"/>
      <url>/2016/03/18/shu-ju-ku/oracle-forget-password/</url>
      
        <content type="html"><![CDATA[<blockquote><p>如果忘记oracle的sys、system、scott等用户名的密码：</p></blockquote><a id="more"></a><ol><li><p>配置环境变量</p><pre><code> ORACLE_HOME=F:\study\oracle\product\10.1.0\db_1 path=(原path);ORACLE_HOME/BIN</code></pre></li><li><p>打开命令提示符窗口，输入<code>sqlplus /nolog</code></p><pre><code> conn /as sysdba alter user XXX identified by &quot;password&quot;;</code></pre><p>然后就OK了。</p></li></ol><hr><p>命令行内容：</p><pre><code>Microsoft Windows XP [版本 5.1.2600](C) 版权所有 1985-2001 Microsoft Corp.C:\Documents and Settings\Administrator&gt;sqlplus /nologSQL*Plus: Release 10.1.0.2.0 - Production on 星期四 11月 3 18:48:48 2011Copyright (c) 1982, 2004, Oracle.  All rights reserved.SQL&gt; conn /as sysdba已连接。SQL&gt; alter user scott identified by &quot;123456&quot;;用户已更改。SQL&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> database </tag>
            
            <tag> Oracle </tag>
            
            <tag> 忘记密码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Oracle_恢复数据</title>
      <link href="/2016/03/18/shu-ju-ku/oracle-revert-data/"/>
      <url>/2016/03/18/shu-ju-ku/oracle-revert-data/</url>
      
        <content type="html"><![CDATA[<h2 id="利用闪回恢复数据"><a href="#利用闪回恢复数据" class="headerlink" title="利用闪回恢复数据"></a>利用闪回恢复数据</h2><pre><code>alter table message.t_message_msg enable row movement;flashback table message.t_message_msg to timestamp to_timestamp(&#39;2013-05-19 08:30:00&#39;,&#39;yyyy-mm-dd hh24:mi:ss&#39;);</code></pre><p><code>message.t_message_msg</code> 指的是需要恢复数据的表</p><a id="more"></a><h2 id="使用undo恢复数据"><a href="#使用undo恢复数据" class="headerlink" title="使用undo恢复数据"></a>使用undo恢复数据</h2><pre><code>create table t_flow_workitem_bak_20131011_2 as select * from t_flow_workitem as of timestamp (sysdate - 100/1440);create table t_flow_histworkitem_bak_2 as select * from t_flow_histworkitem as of timestamp (sysdate - 70/1440);create table t_flow_startprocess_bak_4 as select * from t_flow_startprocess as of timestamp (sysdate - 200/1440);create table urgedhandle_feedback_bak_2 as select * from t_flow_urgedhandle_feedback as of timestamp (sysdate - 70/1440);create table urgedhandle_bak_20131011 as select * from t_flow_urgedhandle as of timestamp (sysdate - 70/1440);create table t_oa_doc_relay_20131011 as select * from t_oa_doc_relay as of timestamp (sysdate - 70/1440);create table t_oa_doc_receiver_20131011 as select * from t_oa_doc_receiver as of timestamp (sysdate - 70/1440);</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> database </tag>
            
            <tag> Oracle </tag>
            
            <tag> 恢复数据 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Oracle_查看锁表信息及解锁</title>
      <link href="/2016/03/18/shu-ju-ku/oracle-table-lock/"/>
      <url>/2016/03/18/shu-ju-ku/oracle-table-lock/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><ol><li><p>查看被锁的表的信息</p><pre><code> select s.username,    decode(l.type, &#39;tm&#39;, &#39;table lock&#39;, &#39;tx&#39;, &#39;row lock&#39;, null) lock_level,    o.owner,    o.object_name,    o.object_type,    s.sid,    s.serial#,    s.terminal,    s.machine,    s.program,    s.osuser from v$session s, v$lock l, dba_objects o where l.sid = s.sid and l.id1 = o.object_id(+) and s.username is not null;</code></pre></li><li><p>表解锁</p><pre><code> --kill session语句 alter system kill session &#39;50,492&#39;; ---(SID,SERIAL#)</code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> database </tag>
            
            <tag> Oracle </tag>
            
            <tag> 锁表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux_Ubuntu使用Deb安装rpm</title>
      <link href="/2016/03/18/yun-wei/linux-ubuntu-install-rpm-deb/"/>
      <url>/2016/03/18/yun-wei/linux-ubuntu-install-rpm-deb/</url>
      
        <content type="html"><![CDATA[<blockquote><p>ubuntu安装软件是用deb格式的文件安装，ubuntu对于rpm格式的文件安装软件是：<br>先将rpm格式的文件转换为deb格式的，再进行安装</p></blockquote><a id="more"></a> <h1 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h1><blockquote><p>ubuntu安装sqldeveloper-3.0.04.34-1.noarch.rpm</p></blockquote><ol><li><p>ubuntu 安装alien转换软件</p><pre><code> sudo apt-get install alien</code></pre></li><li><p>转换</p><pre><code> sudo alien --scripts sqldeveloper-3.0.04.34-1.noarch.rpm执行完后会生成一个sqldeveloper_3.0.04.34-2_all.deb这样的文件</code></pre></li><li><p>安装</p><p>在图像画面上双击deb文件<br/><br>或者<br/><br>在终端里面输入</p><pre><code> sudo dpkg -i sqldeveloper_3.0.04.34-2_all.deb</code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Ubuntu </tag>
            
            <tag> Deb </tag>
            
            <tag> rpm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux_Ubuntu_安装mongoDB</title>
      <link href="/2016/03/15/zhong-jian-jian/linux-ubuntu-install-mongodb/"/>
      <url>/2016/03/15/zhong-jian-jian/linux-ubuntu-install-mongodb/</url>
      
        <content type="html"><![CDATA[<ol><li><p>下载安装包(<code>mongodb-linux-x86_64-2.4.9.tgz</code>)</p></li><li><p>解压</p><pre><code> tar -zxvf mongodb-linux-x86_64-2.4.9.tgz</code></pre><p> 重命名，文件夹名称太长</p><pre><code> mv mongodb-linux-x86_64-2.4.9 mongodb</code></pre><a id="more"></a></li><li><p>新建数据库和日志文件夹，日志文件夹很重要，可以很快的定位问题出在哪里</p><ul><li><p>进入mongodb文件夹</p><pre><code>    cd mongodb</code></pre></li><li><p>新建文件夹</p><pre><code>  mkdir data  mkdir data/db  mkdir data/log  touch data/log/mongodb.log    --日志文件</code></pre></li></ul></li><li><p>新建启动脚本</p><ul><li><p>进入系统文件夹</p><pre><code>  cd /etc/init.d            --必须是此文件夹</code></pre></li><li><p>创建脚本</p><pre><code>  cd /opt/shell  touch mongodb</code></pre></li><li><p>文件内容</p><pre><code>  !/bin/sh  /opt/mongodb/bin/mongod --dbpath /opt/mongodb/data/db --logpath /opt/mongodb/data/log/mongodb.log</code></pre></li><li><p>设置可以运行的权限</p><pre><code>  chmod u+x mongodb</code></pre></li></ul></li><li><p>设置成系统服务，并随计算机启动而启动</p><pre><code>   update-rc.d mongodb defaults</code></pre></li><li><p>删除服务</p><pre><code> update-rc.d -f mongodb remove</code></pre></li><li><p>设置开机启动</p><pre><code> vim /etc/rc.local</code></pre><p> 最后一行加</p><pre><code> #start mongodb /opt/shell/mongodb &gt; /opt/logs/mongodb.log</code></pre></li><li><p>以配置文件方式启动<br> 写配置文件</p><ul><li><p>创建目录</p><pre><code>mkdir /opt/mongodb/conf</code></pre></li><li><p>创建配置文件</p><pre><code>touch /opt/mongodb/conf/mongodb.conf</code></pre></li><li><p>配置文件</p><pre><code># 端口port=27017                            #数据目录dbpath=/opt/mongodb/data/db#日志文件logpath=/opt/mongodb/data/log/mongodb.log#日志是否以append模式添加logappend=true#是否静默启动fork=true                                    </code></pre></li><li><p>回到第3步，文件内容</p><pre><code>!/bin/sh/opt/mongodb/bin/mongod -f /opt/mongodb/conf/mongodb.conf</code></pre></li></ul></li><li><p>设置别名</p><p> mongodb启动之后，在命令行进入数据库是通过命令$MONGO_HOME/bin/mongo。每次这么写很麻烦，是否可以把这一段变成一条命令，就像cd一样</p><pre><code> 这里用到alias设置别名 alias mongo=&#39;/opt/mongodb/bin/mongo&#39; alias mongodb=&#39;/etc/init.d/mongodb&#39;</code></pre><p> alias命令永久生效：</p><pre><code> 在用户主目录下，vim .bashrc，写入上面两行代码，source .bashrc</code></pre></li></ol><ol start="10"><li>安装rockmongo<ul><li><code>apt-get install php5-dev</code></li><li><code>pecl install mongo</code></li><li><code>cd /etc/php5/mods-available/</code></li><li><code>touch mongo.ini</code></li><li>写入<code>extension=mongo.so</code></li><li><code>ln -s /etc/php5/mods-available/mongo.ini /etc/php5/apache2/conf.d/mongo.ini</code></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Ubuntu </tag>
            
            <tag> mongoDB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux_Ubuntu_安装Nginx</title>
      <link href="/2016/03/15/zhong-jian-jian/linux-ubuntu-install-nginx/"/>
      <url>/2016/03/15/zhong-jian-jian/linux-ubuntu-install-nginx/</url>
      
        <content type="html"><![CDATA[<ol><li><p>下载</p><pre><code> sudo wget http://nginx.org/download/nginx-${version}.tar.gz</code></pre></li></ol><a id="more"></a><ol start="2"><li><p>解压</p><pre><code> tar -xzvf nginx-1.6.0.tar.gz</code></pre></li><li><p>进入相关nginx目录进行以下操作</p><pre><code> ./configure --prefix=/opt/nginx --with-http_stub_status_module make make install</code></pre><p> 其中：<code>--prefix</code>是制定nginx的安装目录</p></li><li><p>检查是否安装成功</p><pre><code> cd /opt/nginx/sbin ./nginx -t</code></pre><p> 结果显示：</p><pre><code> nginx: the configuration file /opt/nginx/conf/nginx.conf syntax is ok nginx: configuration file /opt/nginx/conf/nginx.conf test is successful</code></pre></li><li><p>启动nginx</p><p> <code>cd /opt/nginx/sbin</code> 目录下面 输入 <code>./nginx</code> 启动 <code>nginx</code>.<br/><br> 如果不在当下目录可以通过一下命令启动：</p><pre><code> /opt/nginx/sbin/nginx -c /opt/nginx/conf/nginx.conf</code></pre><p> <code>-c</code>制定配置文件的路径，不加nginx会自动加载默认路径的配置文件。</p></li><li><p>启动、停止、重启nginx</p><pre><code> /opt/nginx/sbin/nginx /opt/nginx/sbin/nginx -s stop /opt/nginx/sbin/nginx -s reload</code></pre></li><li><p>常见问题解决办法</p><ul><li><p>缺少<code>pcre library</code></p><p>错误信息：</p><pre><code>    ./configure: error: the HTTP rewrite module requires the PCRE library. You can either disable the module by using --without-http_rewrite_module option, or install the PCRE library into the system, or build the PCRE library statically from the source with nginx by using --with-pcre=&lt;path&gt; option.</code></pre><p>解决方法：</p><pre><code>- 下载安装pcre-8.31解决问题，解压后对pcre进行如下操作`sudo wget ftp://ftp.csx.cam.ac.uk/pub/software/programming/pcre/pcre-8.31.tar.gz`- sudo  tar -xzvf pcre-8.31.tar.gz- cd /usr/local/src/pcre-8.31- ./configure- make- sudo make install  运气好一次通过，运气不好，make pcre时会出错,缺少gcc-c++和libtool，也就是c++编译包    错误信息：        libtool: compile: unrecognized option `-DHAVE_CONFIG_H&#39;      libtool: compile: Try `libtool --help&#39; for more information.      make[1]: *** [pcrecpp.lo] Error 1      make[1]: Leaving directory `/usr/local/src//pcre-8.31&#39;      make: *** [all] Error 2root@wolfdog-virtual-machine:~/work/pcre-8.12$ libtool -help -DHAVE_CONFIG_H      The program &#39;libtool&#39; is currently not installed.  You can install it by typing:      sudo apt-get install libtool    解决方法：        1. 需要先安装libtool和gcc-c++      2. sudo apt-get install libtool      3. sudo apt-get install g++ 或者 gcc-c++</code></pre></li><li><p>缺少<code>openssl</code>库</p><pre><code>错误信息：    ./configure: error: the HTTP cache module requires md5 functions  from OpenSSL library.  You can either disable the module by using  --without-http-cache option, or install the OpenSSL library into the system,  or build the OpenSSL library statically from the source with nginx by using  --with-http_ssl_module --with-openssl=&lt;path&gt; options.缺少zlib库：    ./configure: error: the HTTP gzip module requires the zlib library.  You can either disable the module by using --without-http_gzip_module  option, or install the zlib library into the system, or build the zlib library  statically from the source with nginx by using --with-zlib=&lt;path&gt; option.解决办法：    sudo apt-get install openssl libssl-dev libperl-dev</code></pre></li><li><p>错误信息：</p><pre><code>  ./nginx -t  ./nginx: error while loading shared libraries: libpcre.so.1: cannot open shared object file: No such file or directory</code></pre><p>解决办法：<code>ln -s /usr/local/lib/libpcre.so.1 /lib</code></p></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Ubuntu </tag>
            
            <tag> Nginx </tag>
            
            <tag> frontend </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux_Ubuntu_安装rabbitmq</title>
      <link href="/2016/03/15/zhong-jian-jian/linux-ubuntu-install-rabbitmq/"/>
      <url>/2016/03/15/zhong-jian-jian/linux-ubuntu-install-rabbitmq/</url>
      
        <content type="html"><![CDATA[<ol><li><p>需要3个文件</p><pre><code> otp_src_17.3.tar.gz simplejson-3.6.4.tar.gz rabbitmq-server-generic-unix-3.3.5.tar.gz</code></pre><a id="more"></a></li><li><p>安装erlang</p><ol><li><p>tar -zxvf otp_src_17.3.tar.gz</p></li><li><p>cd otp_src_17.3/</p></li><li><p>./configure</p><blockquote><p>备注：</p></blockquote><ul><li><p>[无碍]</p><pre><code>  configure: WARNING:          wxWidgets must be installed on your system.  Please check that wx-config is in path, the directory  where wxWidgets libraries are installed (returned by  &#39;wx-config --libs&#39; or &#39;wx-config --static --libs&#39; command)  is in LD_LIBRARY_PATH or equivalent variable and  wxWidgets version is 2.8.4 or above.</code></pre></li><li><p>需要解决</p><pre><code>  configure: error: No curses library functions found  configure: error: /bin/bash &#39;/opt/software/otp_src_17.3/erts/configure&#39; failed for erts</code></pre><p>解决：</p><pre><code>    apt-cache search ncurses  apt-get install libncurses5-dev</code></pre></li></ul></li><li><p>make</p></li><li><p>make install</p></li></ol></li><li><p>安装simplejson</p><ul><li>tar -zxvf simplejson-3.6.4.tar.gz</li><li>cd simplejson-3.6.4</li><li>python setup.py install</li></ul></li><li><p>安装rabbitmq-server</p><ul><li><p><code>tar -zxvf rabbitmq-server-generic-unix-3.3.5.tar.gz</code></p></li><li><p><code>cd rabbitmq_server-3.3.5/etc/rabbitmq</code></p></li><li><p><code>touch rabbitmq.config</code></p></li><li><p><code>vim rabbitmq.config</code></p><p>  添加内容：</p><pre><code>  [{rabbit, [{loopback_users, []}]}].</code></pre></li><li><p>启动：</p><ol><li><p>cd rabbitmq_server-3.3.5/sbin</p></li><li><p>启用监控台web:</p><pre><code> ./rabbitmq-plugins enable rabbitmq_management</code></pre></li><li><p>启动</p><pre><code> ./rabbitmq-server</code></pre></li></ol></li><li><p>外网访问：</p><pre><code>  http://ip:15672</code></pre></li></ul></li><li><p>制作开机启动</p><ol><li><p>vim /etc/rc.local</p></li><li><p>最后exit 0之前加上：</p><pre><code> #start rabbitMq /opt/rabbitmq_server-3.3.5/sbin/rabbitmq-server -detached &gt; /opt/logs/rabbitmq.log</code></pre></li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Ubuntu </tag>
            
            <tag> rabbitmq </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux_Ubuntu_安装redis</title>
      <link href="/2016/03/15/zhong-jian-jian/linux-ubuntu-install-redis/"/>
      <url>/2016/03/15/zhong-jian-jian/linux-ubuntu-install-redis/</url>
      
        <content type="html"><![CDATA[<ol><li><p>下载安装：</p><p> 将安装包上传，放入<code>/opt/software/redis</code></p><pre><code> tar -zxf redis-2.8.13.tar.gz cd redis-2.8.13 make sudo make install make test</code></pre><p> 这时Redis的可执行文件被放到了<code>/usr/local/bin</code></p><a id="more"></a></li><li><p>下载配置文件和init启动脚本：</p><pre><code> wget https://github.com/ijonas/dotfiles/raw/master/etc/init.d/redis-server wget https://github.com/ijonas/dotfiles/raw/master/etc/redis.conf sudo mv redis-server /etc/init.d/redis-server sudo chmod +x /etc/init.d/redis-server sudo mv redis.conf /etc/redis.conf 备注: redis-server        --&gt; [Linux_Ubuntu安装Redis_redis-server] Redis_redis.conf    --&gt; [Linux_Ubuntu安装Redis_redis.conf]</code></pre></li><li><p>初始化用户和日志路径[必须执行]</p><p> 第一次启动Redis前，建议为Redis单独建立一个用户，并新建data和日志文件夹</p><pre><code> sudo useradd redis sudo mkdir -p /var/lib/redis sudo mkdir -p /var/log/redis sudo chown redis.redis /var/lib/redis sudo chown redis.redis /var/log/redis</code></pre></li><li><p>设置开机自动启动，关机自动关闭</p><pre><code> sudo update-rc.d redis-server defaults</code></pre></li><li><p>启动Redis：</p><pre><code> sudo /etc/init.d/redis-server start</code></pre></li><li><p>启动client客户端连接:</p><pre><code> root@sunhao-linux:~# redis-cli 127.0.0.1:6379&gt; set foo bar OK 127.0.0.1:6379&gt; get foo &quot;bar&quot;</code></pre></li></ol><h1 id="问题解决："><a href="#问题解决：" class="headerlink" title="问题解决："></a>问题解决：</h1><ol><li><p>如果遇到make test发生错误：</p><p> 现象：</p><pre><code> root@sunhao-linux:/opt/redis# make test cd src &amp;&amp; make test make[1]: 正在进入目录 `/opt/redis/src&#39; You need tcl 8.5 or newer in order to run the Redis test make[1]: *** [test] 错误 1 make[1]:正在离开目录 `/opt/redis/src&#39; make: *** [test] 错误 2</code></pre><p> 解决方案：</p><pre><code> root@sunhao-linux:/opt/redis# apt-get install tcl</code></pre></li></ol><blockquote><p>安装之后的信息</p></blockquote><pre><code>jemalloc version   : 3.6.0-0-g46c0af68bd248b04df75e4f92d5fb804c3d75340library revision   : 1CC                 : gccCPPFLAGS           :  -D_GNU_SOURCE -D_REENTRANTCFLAGS             : -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -fvisibility=hiddenLDFLAGS            : EXTRA_LDFLAGS      : LIBS               :  -lpthreadRPATH_EXTRA        : XSLTPROC           : falseXSLROOT            : PREFIX             : /usr/localBINDIR             : /usr/local/binINCLUDEDIR         : /usr/local/includeLIBDIR             : /usr/local/libDATADIR            : /usr/local/shareMANDIR             : /usr/local/share/mansrcroot            : abs_srcroot        : /opt/software/redis/redis-2.8.13/deps/jemalloc/objroot            : abs_objroot        : /opt/software/redis/redis-2.8.13/deps/jemalloc/JEMALLOC_PREFIX    : je_JEMALLOC_PRIVATE_NAMESPACE                   : je_install_suffix     : autogen            : 0experimental       : 1cc-silence         : 1debug              : 0code-coverage      : 0stats              : 1prof               : 0prof-libunwind     : 0prof-libgcc        : 0prof-gcc           : 0tcache             : 1fill               : 1utrace             : 0valgrind           : 0xmalloc            : 0mremap             : 0munmap             : 0dss                : 0lazy_lock          : 0tls                : 1</code></pre>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Ubuntu </tag>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux_Ubuntu_安装zookeeper</title>
      <link href="/2016/03/15/zhong-jian-jian/linux-ubuntu-install-zookeeper/"/>
      <url>/2016/03/15/zhong-jian-jian/linux-ubuntu-install-zookeeper/</url>
      
        <content type="html"><![CDATA[<ol><li><p>下载zookeeper，<a href="http://archive.apache.org/dist/zookeeper/" target="_blank" rel="noopener">http://archive.apache.org/dist/zookeeper/</a></p></li><li><p>解压到: /opt/zookeeper-3.4.6下载</p></li><li><p>把conf下的<code>zoo_sample.cfg</code> copy一份后重命名为: <code>zoo.cfg</code>.</p><a id="more"></a><pre><code> 文件中内容如下: syncLimit=5 initLimit=10 tickTime=2000 clientPort=2181 dataDir=/opt/zookeeper-3.4.6/data dataLogDir=/opt/zookeeper-3.4.6/logs</code></pre></li><li><p>新建zookeeper-3.4.6下的data,log目录,然后</p><pre><code> chmod u+x /opt/zookeeper-3.4.6/bin/*</code></pre></li><li><p>新建shell脚本<code>startZookeeper.sh</code>在<code>/opt/shell</code>文件夹下，</p><pre><code> chmod u+x /opt/shell/startZookeeper.sh</code></pre><p> 内容：</p><pre><code> #!/bin/sh #to start zookeeper #set environment export ZOOKEEPER_INSTALL=/opt/zookeeper-3.4.6 export PATH=$PATH:$ZOOKEEPER_INSTALL/bin PID_FILE=$ZOOKEEPER_INSTALL/data/zookeeper_server.pid FLAG=$1 if [ &quot;$FLAG&quot; = &quot;os_start&quot; ] &amp;&amp; [ -f &quot;$PID_FILE&quot; ] then         rm $PID_FILE fi #start zookeeper $ZOOKEEPER_INSTALL/bin/zkServer.sh start</code></pre></li><li><p>设置zookeeper开机启动</p><pre><code> vim /etc/rc.local 在最后一行添加如下两句话 #start zookeeper /opt/shell/startZookeeper.sh</code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Ubuntu </tag>
            
            <tag> zookeeper </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>solr_使用</title>
      <link href="/2016/03/15/zhong-jian-jian/solr-use/"/>
      <url>/2016/03/15/zhong-jian-jian/solr-use/</url>
      
        <content type="html"><![CDATA[<ol><li><p>见链接：<a href="http://www.blogjava.net/conans/articles/379556.html" target="_blank" rel="noopener">http://www.blogjava.net/conans/articles/379556.html</a></p><pre><code> 有待整理！</code></pre></li></ol><ol start="2"><li><p>solr搜索word、pdf：</p><pre><code> http://blog.csdn.net/aidayei/article/details/6535898</code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> solr </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux下mysql中文乱码解决方法</title>
      <link href="/2016/03/15/shu-ju-ku/linux-mysql-chinese/"/>
      <url>/2016/03/15/shu-ju-ku/linux-mysql-chinese/</url>
      
        <content type="html"><![CDATA[<h2 id="解决MySQL数据库乱码问题总结："><a href="#解决MySQL数据库乱码问题总结：" class="headerlink" title="解决MySQL数据库乱码问题总结："></a>解决MySQL数据库乱码问题总结：</h2><ol><li><p>修改安装文件根目录下的my.ini文件：</p><ol><li>搜索字段<code>default-character-set</code>，设置其值为<code>utf8/gbk</code>之一(注意设置utf8的时候不能设成utf-8)</li><li>再去重启MySQL服务器</li><li>如果还是出现乱码，接着执行下面操作<a id="more"></a></li></ol></li><li><p>修改数据库编码</p><ol><li><p>在安装目录的<code>data</code>目录下找到你出现乱码的数据库对应的文件夹(这个文件夹即是你这个数据库存放数据的地方)，</p></li><li><p>进入找到db.opt文件(即此数据库的编码配置文件)，修改值为下面的</p><pre><code> gbk:default-character-set=gbk     default-collation=gbk_chinese_ci utf8:default-character-set=utf8     default-collation=utf8_general_ci</code></pre></li><li><p>再去重启MySQL服务器</p></li><li><p>如果还是出现乱码，接着执行下面操作</p></li></ol></li><li><p>再不行，备份原数据库数据，直接drop掉这个数据库</p><p>重新创建数据库并设置编码</p><pre><code> create database yourDB character set utf8; 或者 create database yourDB character set gbk;</code></pre><p> 别忘了重启MySQL服务器</p></li></ol><p>综上：如果还没有解决，我也没辙了。重装吧，重装的时候设置下编码三处的编码要一致</p><h2 id="网上找到的"><a href="#网上找到的" class="headerlink" title="网上找到的"></a>网上找到的</h2><blockquote><p>系统环境:suse linux server 10,mysql 5.0</p></blockquote><blockquote><p>安装mysql后，默认的字符集是latin1。在linux下安装mysql不像在windows上安装那像，可以选择字符集(即使当时使用了默认的字符集，安装后也可以在安装目录下修改my.ini文件），但是在linux就不太一样了。</p></blockquote><ol><li><p>在shell输入mysql登陆后:</p><pre><code> mysql&gt;show variables like &#39;%char%&#39;;</code></pre><p> 回车后显示:</p><pre><code> +---------------------－+-----－－-------------- | Variable_name | Value +-----------------------+-－－------------------ | character_set_client | latin1 | character_set_connection | latin1 | character_set_database | latin1 | character_set_filesystem | binary | character_set_results | latin1 | character_set_server | latin1 | character_set_system | utf8 | character_sets_dir | /usr/share/mysql/charsets/ +---------------------+－－－-------------------</code></pre><p> 这就是它默认的设置。</p></li><li><p>接下来到/usr/share/mysql/目录下，将my-medium.cnf文件(使用其它实例配置文件也行)拷贝到/</p><p> etc目录下：</p><pre><code> pds:~# cp /usr/share/mysql/my-medium.cnf /etc/my.cnf pds:~# vi /etc/my.cnf</code></pre><p> 分别在如下几项中添加字符集：</p><pre><code> [client] default-character-set=gb2312 [mysqld_safe] default-character-set=gb2312 [mysqld] default-character-set=gb2312 #default-table-type=innodb [mysql] default-character-set=gb2312</code></pre></li><li><p>再重启mysql让配置生效:</p><pre><code> pds:~# service mysql restart Shutting down MySQL done Starting MySQL done</code></pre></li><li><p>再次登陆mysql后，查看变量：</p><pre><code> mysql&gt;show variables like &#39;%char%&#39;; +---------------------－+-----－－-------------- | Variable_name | Value +-----------------------+-－－------------------ | character_set_client | gb2312 | character_set_connection | gb2312 | character_set_database | gb2312 | character_set_filesystem | binary | character_set_results | gb2312 | character_set_server | gb2312 | character_set_system | utf8 | character_sets_dir | /usr/share/mysql/charsets/ +---------------------+－－－-------------------</code></pre></li><li><p>如此显示就完成了配置了，在表中插入一条含中文的记录，就不再出现乱码，但是原来插入的记录很可能还是乱码，因为原来的字符集与当前字符集不一致。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> database </tag>
            
            <tag> mysql </tag>
            
            <tag> 中文乱码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux_Ubuntu_安装Oracle</title>
      <link href="/2016/03/15/shu-ju-ku/linux-ubuntu-install-oracle/"/>
      <url>/2016/03/15/shu-ju-ku/linux-ubuntu-install-oracle/</url>
      
        <content type="html"><![CDATA[<ol><li><p>安装必需的包</p><pre><code> apt-get install gcc make binutils lesstif2 libc6 libc6dev rpm libmotif3 libaio1 libstdc++6 alien</code></pre></li><li><p>创建用户</p><pre><code> adduser oracle</code></pre><a id="more"></a></li><li><p>设置swap区</p><p> Oracle10g至少需要500M的内存和400M的交换空间，要查看swap区是否足够大小，用 <code>fdisk l</code> 命令去查，如果小于400M的空间，那么就要增加swap的大小</p><p> 重设交换分区可以使用如下操作:</p><pre><code> dd if=/dev/zero of=tmp_swap bs=1k count=900000 chmod 600 tmp_swap mkswap tmp_swap swapon tmp_swap 完成安装以后,可以释放这个空间: swapoff tmp_swap rm tmp_swap</code></pre></li><li><p>修改 <code>sysctl.conf</code></p><pre><code> kernel.shmmax = 3147483648 kernel.shmmni = 4096 kernel.shmall = 2097152 kernel.sem = 250 32000 100 128 fs.filemax = 65536 net.ipv4.ip_local_port_range = 1024 65000</code></pre></li><li><p>修改 <code>limits.conf</code></p><pre><code> * soft nproc 2407 * hard nproc 16384 * soft nofile 1024 * hard nofile 65536</code></pre></li><li><p>让修改生效</p><p> 修改了以上文件后,必须让其生效,或重启系统,或切换到 root 用户下用以下的方式改变内核运行参数: <code>sysctl p</code></p></li><li><p>产生相应的软连接</p><p> 创建一个文件如 kk，内容如下：</p><pre><code> #!/bin/bash ln s /usr/bin/awk /bin/awk ln s /usr/bin/rpm /bin/rpm ln s /usr/bin/basename /bin/basename mkdir /etc/rc.d ln s /etc/rc0.d /etc/rc.d/rc0.d ln s /etc/rc2.d /etc/rc.d/rc2.d ln s /etc/rc3.d /etc/rc.d/rc3.d ln s /etc/rc4.d /etc/rc.d/rc4.d ln s /etc/rc5.d /etc/rc.d/rc5.d ln s /etc/rc6.d /etc/rc.d/rc6.d ln s /etc/init.d /etc/rc.d/init.d</code></pre><p> 创建后，切换到 root 用户去执行一下。</p></li><li><p>创建RedHat的版本声明文件</p><p> 在/etc/redhatrelease中添加以下语句，以使安装程序认为正在一个RedHat的系统上安装：</p><pre><code> Red Hat Linux release 3.1 (drupal)</code></pre></li><li><p>修改环境变量</p><p> 编辑 /home/oracle/.bashrc，增加以下export 的内容。<br>(注意，在Ubnutu 7.04中用户的profile文件已改名为~/.profile，有很多安装教程都是用 ~/.bash_profile，在7.04中不行的)</p><pre><code> export ORACLE_HOME=/opt/oracle export ORACLE_OWNER=oracle export ORACLE_SID=oracle export ORACLE_TERM=xterm export PATH=$ORACLE_HOME/bin:$ORACLE_HOME/Apache/Apache/bin:$PATH</code></pre></li><li><p>开始安装</p><p>注销原来的用户，改用oracle用户登录。用env查看一下环境变量是否生效。 然后进行<code>/ora_ins_disk</code>中进行安装，执行安装脚本时还需要以root权限创建目录<code>/opt/oracle</code></p><pre><code>sudo mkdir /opt/oraclesudo chown R oracle:oracle /opt/oraclesudo chmod R 770 /opt/oraclecd/ora_ins_disk./runInstaller</code></pre><p>在安装过程中，请使用 Advanced Installation，然后一路按默认的设置进行往下设置，到窗单名为 “Specify Database Configuration Options”的时候，要修改以下设置： Database Character Set 中选择 Simplified Chinese ZHS16GBK 在安装的后期，系统提示需要用 root 用户去运行两个脚本文件orainstRoot.sh和root.sh，安装完毕后，Oracle是正常启动着的，你可以试一下连接数据库，同时也可以使用浏览器去设置一下Oracle，（url:http: //localhost:1158/em/）（Oracle 10g与之前的版本都不一样，使用WEB页的企业管理器来代替以前的C/S版JAVA企业管理器）</p></li><li><p>启动服务,一般采用手动:</p><p>Ubuntu下启动Oracle，启动oracle必须在你安装oracle的那个账户上进行的.</p><p>手动启动oracle:</p><pre><code>1.先在命令的模式下启动监听lsnrctl start2.然后使用sqlplus来启动oraclesqlplus / as sysdbastartupexit</code></pre><p>能看到oracle启动成功的消息就ok了。</p></li></ol><blockquote><p>安装过程中,可能会出错,解决方案:</p></blockquote><ol><li><p>问题：</p><p> 调用makefile <code>．．/sqlplus/lib/ins_sqlplus.mk</code> 的目标<code>install</code> 时出错。请参阅<code>/home/oracle/oraInventory/logs/installActions20111206_110318AM.log</code>以了解详细信息。  </p><p>   解决办法：</p><pre><code> $ORACLE_HOME/ /sqlplus/lib/env_sqlplus.mk添加一行：EXPDLIBS=lclntsh ，然后点击“重试”按钮， ok.</code></pre></li><li><p>问题：</p><p> 调用makefile <code>．．/sysman/lib/ins_sysman.mk</code> 的目标<code>agent nmo nmb</code> 时出错。请参阅<code>../oraInventory/logs/installActions20111206_110318AM.log</code> 以了解详细信息。 </p><p>   解决办法：</p><pre><code> 1. 降低gcc的版本,oracle10g的gcc是3.4左右的版本.使用gcc3.4_3.4.66ubuntu3_i386.deb. 2. 在ubuntu中有可能我们的gcc版本过高或者过低，需要改变到合适的版本，，， 3. 在/usr/bin/目录下，我们可以看到一些gcc开头的文件，其中有一个是gcc，用ls命令看一下，他是个链接文件，链接到当前的gcc文件，也即是说， 4. 他是连接到当前使用的gcc上的，所以改变他的链接源文件就可以了，假如我们现在的gcc是gcc4.6,我们要降级到gcc3.4，我们先下载一个gcc3.4安装， 5. 会在/usr/bin目录下看到gcc3.4这个文件，然后在/usr/bin目录下删除(备份)gcc这个文件，然后执行 6. ln s gcc3.4 gcc ,这样之后，执行：gcc v</code></pre></li><li><p>问题:</p><p> <code>libstdc++.so.5</code>找不到<code>No such file or directory</code></p><p>   解决办法:</p><ol><li><p>下载安装包：</p><p>   请到ubuntu的官方网站的packages栏目<code>http://packages.ubuntu.com/precise/amd64/libstdc++5/download</code>选择一个可用的链接来下载.deb文件。</p><p>   我已下载:<code>libstdc++5_3.3.625ubuntu1_amd64.deb</code></p></li><li><p>解包为libstdc++5：</p><p> <code>dpkg x libstdc++5_3.3.625ubuntu1_amd64.deb libstdc++5</code></p></li><li><p>复制到系统lib目录：</p><p> <code>sudo cp libstdc++5/usr/lib/x86_64linuxgnu/libstdc++.so.5.0.7 /usr/lib</code></p></li><li><p>进入系统lib目录建libstdc++5链接：</p><p> <code>cd /usr/lib</code><br/><br> <code>sudo ln s libstdc++.so.5.0.7 libstdc++.so.5</code></p></li></ol></li><li><p>问题:</p><p> <code>libgcc_s.so.1</code>找不到</p><p>   解决方案: 不予理会</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Ubuntu </tag>
            
            <tag> database </tag>
            
            <tag> Oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux下远程拷贝文件夹</title>
      <link href="/2016/03/15/yun-wei/linux-copy-remote/"/>
      <url>/2016/03/15/yun-wei/linux-copy-remote/</url>
      
        <content type="html"><![CDATA[<p><code>scp -r /opt/test root@202.119.200.201:/opt/</code></p><blockquote><p>远程从一台机器拷贝文件或者文件夹到另一台机器</p></blockquote><a id="more"></a><pre><code>scp [-r] dir name@ip:dir1. scp        远程拷贝命令2. -r        如果是拷贝文件夹，需要这个参数，表示向子目录递归；如果是拷贝文件，则不需要3. dir        源机器上的源文件路径4. name        目标机器的用户5. ip        目标机器IP6. dir        拷贝到目标机器哪个目录</code></pre>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 拷贝 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux_Ubuntu_允许root登录</title>
      <link href="/2016/03/15/yun-wei/linux-ubuntu-root-login/"/>
      <url>/2016/03/15/yun-wei/linux-ubuntu-root-login/</url>
      
        <content type="html"><![CDATA[<blockquote><p>ubuntu12.04默认是不允许root登录的，在登录窗口只能看到普通用户和访客登录。</p></blockquote><ol><li><p>以普通身份登陆Ubuntu后我们需要做一些修改,</p><p> 普通用户登录后，修改系统配置文件需要切换到超级用户模式,在终端窗口里面输入: <code>sudo -s</code>.然后输入普通用户登陆的密码，回车即可进入 root用户权限模式.</p><p> 然后执行: <code>vi /etc/lightdm/lightdm.conf</code></p><a id="more"></a><p> 增加 </p><pre><code> greeter-show-manual-login=true   allow-guest=false  </code></pre><p> 修改完的整个配置文件是</p><pre><code> [SeatDefaults] greeter-session=unity-greeter user-session=ubuntu greeter-show-manual-login=true        #手工输入登陆系统的用户名和密码 allow-guest=false                    #不允许guest登录</code></pre></li><li><p>然后我们启动root帐号：</p><pre><code> sudo passwd root</code></pre><p> 根据提示输入root帐号密码。</p></li><li><p>重启ubuntu，登录窗口会有“登录”选项，点击“登录”选项，就会提示让输入用户名了。这时候我们就可以通过root登录了。</p></li></ol><h2 id="通过登陆界面进入ubuntu-14-04-的-root。"><a href="#通过登陆界面进入ubuntu-14-04-的-root。" class="headerlink" title="通过登陆界面进入ubuntu 14.04 的 root。"></a>通过登陆界面进入ubuntu 14.04 的 root。</h2><ol><li>打开终端。</li><li>输入<code>sudo gedit /usr/share/lightdm/lightdm.conf.d/50-ubuntu.conf</code></li><li>在弹出的编辑框里输入：<code>greeter-show-manual-login=true</code> 保存关闭。</li><li>再在中端中输入：<code>sudo passwd root</code></li><li>输入你想要的密码，关机重启在多出的登录框里输入root 还有你的密码就好了！</li></ol>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Ubuntu </tag>
            
            <tag> root </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux_Ubuntu_防火墙操作</title>
      <link href="/2016/03/15/yun-wei/linux-ubuntu-ufw/"/>
      <url>/2016/03/15/yun-wei/linux-ubuntu-ufw/</url>
      
        <content type="html"><![CDATA[<ol><li><p>安装</p><pre><code> sudo apt-get install ufw</code></pre></li><li><p>启用</p><pre><code> sudo ufw enable sudo ufw default deny</code></pre><p> 运行以上两条命令后，开启了防火墙，并在系统启动时自动开启。<br> 关闭所有外部对本机的访问，但本机访问外部正常。</p></li></ol><a id="more"></a><ol start="3"><li><p>开启/禁用</p><pre><code> sudo ufw allow|deny [service]</code></pre><p> 打开或关闭某个端口，例如：</p><pre><code> sudo ufw allow smtp　允许所有的外部IP访问本机的25/tcp (smtp)端口 sudo ufw allow 22/tcp 允许所有的外部IP访问本机的22/tcp (ssh)端口 sudo ufw allow 53 允许外部访问53端口(tcp/udp) sudo ufw allow from 192.168.1.100 允许此IP访问所有的本机端口 sudo ufw allow proto udp 192.168.0.1 port 53 to 192.168.0.2 port 53 sudo ufw deny smtp 禁止外部访问smtp服务 sudo ufw delete allow smtp 删除上面建立的某条规则</code></pre></li><li><p>查看防火墙状态</p><pre><code> sudo ufw status</code></pre><p> 一般用户，只需如下设置：</p><ol><li><p><code>sudo apt-get install ufw</code></p></li><li><p><code>sudo ufw enable</code></p></li><li><p><code>sudo ufw default deny</code></p><p>以上三条命令已经足够安全了，如果你需要开放某些服务，再使用<code>sudo ufw allow</code>开启。<br>补充：</p></li></ol></li></ol><h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><ol><li><p>开启/关闭防火墙 (默认设置是’disable’)</p><pre><code> # ufw enable|disable</code></pre></li><li><p>转换日志状态</p><pre><code> # ufw logging on|off</code></pre></li><li><p>设置默认策略 (比如 “mostly open” vs “mostly closed”)</p><pre><code> # ufw default allow|deny</code></pre></li><li><p>许可或者屏蔽某些入埠的包 (可以在“status” 中查看到服务列表［见后文］)。可以用“协议：端口”的方式指定一个存在于/etc/services中的服务名称，也可以通过包的meta-data。 ‘allow’ 参数将把条目加入 /etc/ufw/maps ，而 ‘deny’ 则相反。基本语法如下：</p><pre><code> # ufw allow|deny [service]</code></pre></li><li><p>显示防火墙和端口的侦听状态，参见 /var/lib/ufw/maps。括号中的数字将不会被显示出来。</p><pre><code> # ufw status</code></pre><p>［注意：上文中虽然没有使用 sudo，但是命令提示符号都是“#”。所以……你知道啥意思了哈。原文如此。──译者注］</p></li></ol><h1 id="UFW-使用范例："><a href="#UFW-使用范例：" class="headerlink" title="UFW 使用范例："></a>UFW 使用范例：</h1><ol><li><p>允许 53 端口</p><pre><code> $ sudo ufw allow 53</code></pre></li><li><p>禁用 53 端口</p><pre><code> $ sudo ufw delete allow 53</code></pre></li><li><p>允许 80 端口</p><pre><code> $ sudo ufw allow 80/tcp</code></pre></li><li><p>禁用 80 端口</p><pre><code> $ sudo ufw delete allow 80/tcp</code></pre></li><li><p>允许 smtp 端口</p><pre><code> $ sudo ufw allow smtp</code></pre></li><li><p>删除 smtp 端口的许可</p><pre><code> $ sudo ufw delete allow smtp</code></pre></li><li><p>允许某特定 IP</p><pre><code> $ sudo ufw allow from 192.168.254.254</code></pre></li><li><p>删除上面的规则</p><pre><code> $ sudo ufw delete allow from 192.168.254.254</code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Ubuntu </tag>
            
            <tag> 防火墙 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在Linux上安装Memcached服务</title>
      <link href="/2016/03/14/zhong-jian-jian/install-memcache-linux/"/>
      <url>/2016/03/14/zhong-jian-jian/install-memcache-linux/</url>
      
        <content type="html"><![CDATA[<h1 id="安装Memcached服务"><a href="#安装Memcached服务" class="headerlink" title="安装Memcached服务"></a>安装Memcached服务</h1><ol><li><p>分别把memcached和libevent下载回来，放到 /tmp 目录下：</p><pre><code> # cd /tmp # wget http://www.danga.com/memcached/dist/memcached-1.2.0.tar.gz # wget http://www.monkey.org/~provos/libevent-1.2.tar.gz</code></pre></li></ol><a id="more"></a><ol start="2"><li><p>先安装libevent：</p><pre><code> # tar zxvf libevent-1.2.tar.gz # cd libevent-1.2 # ./configure –prefix=/usr # make # make install</code></pre></li><li><p>测试libevent是否安装成功：</p><pre><code> # ls -al /usr/lib | grep libevent lrwxrwxrwx 1 root root 21 11?? 12 17:38 libevent-1.2.so.1 -&gt; libevent-1.2.so.1.0.3 -rwxr-xr-x 1 root root 263546 11?? 12 17:38 libevent-1.2.so.1.0.3 -rw-r–r– 1 root root 454156 11?? 12 17:38 libevent.a -rwxr-xr-x 1 root root 811 11?? 12 17:38 libevent.la lrwxrwxrwx 1 root root 21 11?? 12 17:38 libevent.so -&gt; libevent-1.2.so.1.0.3 还不错，都安装上了。</code></pre></li><li><p>安装memcached，同时需要安装中指定libevent的安装位置：</p><pre><code> # cd /tmp # tar zxvf memcached-1.2.0.tar.gz # cd memcached-1.2.0 # ./configure –with-libevent=/usr # make # make install</code></pre><p>如果中间出现报错，请仔细检查错误信息，按照错误信息来配置或者增加相应的库或者路径。<br>安装完成后会把memcached放到 /usr/local/bin/memcached ，</p></li><li><p>测试是否成功安装memcached：</p></li><li><pre><code> # ls -al /usr/local/bin/mem* -rwxr-xr-x 1 root root 137986 11?? 12 17:39 /usr/local/bin/memcached -rwxr-xr-x 1 root root 140179 11?? 12 17:39 /usr/local/bin/memcached-debug</code></pre></li></ol><h1 id="启动Memcached服务"><a href="#启动Memcached服务" class="headerlink" title="启动Memcached服务"></a>启动Memcached服务</h1><ol><li><p>启动Memcache的服务器端：</p><pre><code> # /usr/local/bin/memcached -d -m 10 -u root -l 192.168.141.64 -p 12000 -c 256 -P /tmp/memcached.pid -d选项是启动一个守护进程， -m是分配给Memcache使用的内存数量，单位是MB，我这里是10MB， -u是运行Memcache的用户，我这里是root， -l是监听的服务器IP地址，如果有多个地址的话，我这里指定了服务器的IP地址192.168.0.200， -p是设置Memcache监听的端口，我这里设置了12000，最好是1024以上的端口， -c选项是最大运行的并发连接数，默认是1024，我这里设置了256，按照你服务器的负载量来设定， -P是设置保存Memcache的pid文件，我这里是保存在 /tmp/memcached.pid，</code></pre></li><li><p>如果要结束Memcache进程，执行：</p><pre><code> # kill `cat /tmp/memcached.pid` 也可以启动多个守护进程，不过端口不能重复。</code></pre></li></ol><h1 id="测试Memcached"><a href="#测试Memcached" class="headerlink" title="测试Memcached"></a>测试Memcached</h1><pre><code>[root@localhost /]# telnet 192.168.141.64 12000Trying 192.168.141.64...Connected to 192.168.141.64 (192.168.141.64).Escape character is &#39;^]&#39;.set key1 0 60 4zhouSTOREDget key1VALUE key1 0 4zhouEND</code></pre><blockquote><p>至此Memcached安装成功!</p></blockquote><h1 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题:"></a>常见问题:</h1><ol><li><p>如果启动Memcached服务的时候遇到了</p><pre><code> /usr/local/bin/memcached: error while loading shared libraries: libevent-1.2.so.1: cannot open shared object file: No such file or directory;</code></pre><blockquote><p>解决方案:</p></blockquote><pre><code> [root@localhost bin]# LD_DEBUG=libs memcached -v  [root@localhost bin]# ln -s /usr/lib/libevent-1.2.so.1 /usr/lib64/libevent-1.2.so.1 [root@localhost bin]# /usr/local/bin/memcached -d -m 100 -u root -p 12000 -c 1000 -P /tmp/memcached.pid [root@localhost bin]# ps -aux 可以看到启动的Memcached服务了.</code></pre></li></ol><ol start="2"><li><p>把Memcached服务加载到Linux的启动项中.万一机器断电系统重启.那么Memcached就会自动启动了.</p><pre><code> 假如启动Memcache的服务器端的命令为： # /usr/local/bin/memcached -d -m 10 -u root -l 192.168.141.64 -p 12000 -c 256 -P /tmp/memcached.pid容来自17jquery</code></pre><blockquote><p>想开机自动启动的话，只需在/etc/rc.d/rc.local中加入一行，下面命令<br> /usr/local/memcached/bin/memcached -d -m 10 -p 12000 -u apache -c 256<br> 上面有些东西可以参考一下：即，ip不指定时，默认是本机，用户:最好选择是：apache 或 deamon<br> 这样，也就是属于哪个用户的服务，由哪个用户启动。</p></blockquote></li></ol><h1 id="memcached之java客户端-spymemcached与spring整合"><a href="#memcached之java客户端-spymemcached与spring整合" class="headerlink" title="memcached之java客户端: spymemcached与spring整合"></a>memcached之java客户端: spymemcached与spring整合</h1><hr><blockquote><p>net.spy.memcached.spring.MemcachedClientFactoryBean在net.spy.memcached.MemcachedClient每次使用的时候创建MemcachedClient的新实例。</p></blockquote><pre><code>&lt;bean id=&quot;memcachedClient&quot; class=&quot;net.spy.memcached.spring.MemcachedClientFactoryBean&quot;&gt;      &lt;property name=&quot;servers&quot; value=&quot;host1:11211,host2:11211,host3:11211&quot;/&gt;      &lt;property name=&quot;protocol&quot; value=&quot;BINARY&quot;/&gt;      &lt;property name=&quot;transcoder&quot;&gt;        &lt;bean class=&quot;net.spy.memcached.transcoders.SerializingTranscoder&quot;&gt;          &lt;property name=&quot;compressionThreshold&quot; value=&quot;1024&quot;/&gt;        &lt;/bean&gt;      &lt;/property&gt;      &lt;property name=&quot;opTimeout&quot; value=&quot;1000&quot;/&gt;      &lt;property name=&quot;timeoutExceptionThreshold&quot; value=&quot;1998&quot;/&gt;      &lt;property name=&quot;hashAlg&quot; value=&quot;KETAMA_HASH&quot;/&gt;      &lt;property name=&quot;locatorType&quot; value=&quot;CONSISTENT&quot;/&gt;       &lt;property name=&quot;failureMode&quot; value=&quot;Redistribute&quot;/&gt;      &lt;property name=&quot;useNagleAlgorithm&quot; value=&quot;false&quot;/&gt;  &lt;/bean&gt;  </code></pre><blockquote><p>属性说明：</p></blockquote><ol><li>Servers<br>一个字符串，包括由空格或逗号分隔的主机或IP地址与端口号</li><li>Daemon<br>设置IO线程的守护进程(默认为true)状态</li><li>FailureMode<br>设置故障模式(取消，重新分配，重试)，默认是重新分配</li><li>HashAlg<br>设置哈希算法(见net.spy.memcached.HashAlgorithm的值)</li><li>InitialObservers<br>设置初始连接的观察者(观察初始连接)</li><li>LocatorType<br>设置定位器类型(ARRAY_MOD,CONSISTENT),默认是ARRAY_MOD</li><li>MaxReconnectDelay<br>设置最大的连接延迟</li><li>OpFact<br>设置操作工厂</li><li>OpQueueFactory<br>设置操作队列工厂</li><li>OpTimeout<br>以毫秒为单位设置默认的操作超时时间</li><li>Protocol<br>指定要使用的协议(BINARY,TEXT),默认是TEXT</li><li>ReadBufferSize<br>设置读取的缓冲区大小</li><li>ReadOpQueueFactory<br>设置读队列工厂</li><li>ShouldOptimize<br>如果默认操作优化是不可取的，设置为false(默认为true)</li><li>Transcoder<br>设置默认的转码器(默认以net.spy.memcached.transcoders.SerializingTranscoder)</li><li>UseNagleAlgorithm<br>如果你想使用Nagle算法，设置为true</li><li>WriteOpQueueFactory<br>设置写队列工厂</li><li>AuthDescriptor<br>设置authDescriptor,在新的连接上使用身份验证</li></ol>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Memcached </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux上安装JDK</title>
      <link href="/2016/03/14/hou-duan/install-jdk-linux/"/>
      <url>/2016/03/14/hou-duan/install-jdk-linux/</url>
      
        <content type="html"><![CDATA[<ol><li><p>上传<code>jdk1.6.0_26.zip</code></p></li><li><p>解压后设置环境变量</p><ul><li><p>/etc/rc.local</p><pre><code>  export JAVA_HOME=/opt/jdk1.6.0_26  export JRE_HOME=${JAVA_HOME}/jre  export CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/lib  export PATH=${JAVA_HOME}/bin:$PATH</code></pre></li><li><p>~/.bashrc</p><pre><code>  export JAVA_HOME=/opt/jdk1.6.0_26  export JRE_HOME=${JAVA_HOME}/jre  export CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/lib  export PATH=${JAVA_HOME}/bin:$PATH</code></pre></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Java </tag>
            
            <tag> JDK </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java命令打war包</title>
      <link href="/2016/03/14/hou-duan/java-war/"/>
      <url>/2016/03/14/hou-duan/java-war/</url>
      
        <content type="html"><![CDATA[<ol><li><p>命令行进入webapp下</p></li><li><p>执行<code>jar cvf temp.war */.</code></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> war </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux下安装花生壳</title>
      <link href="/2016/03/14/gong-ju/install-phddns-linux/"/>
      <url>/2016/03/14/gong-ju/install-phddns-linux/</url>
      
        <content type="html"><![CDATA[<ol><li><p>去花生壳官网下载花生壳for Linux（phddns-2.0.5.19225.tar.gz）</p><pre><code> D:\Software\OS\Linux\花生壳</code></pre></li><li><p>解压压缩包    </p><pre><code> tar zxvf phddns-2.0.5.19225.tar.gz</code></pre></li></ol><a id="more"></a><ol start="3"><li><p>转到解压包里面    cd phddns-2.0.2.16556/</p></li><li><p>./configure </p><pre><code> PS： 如果出现下面的错误： checking for C++ compiler default output file name... configure: error: C++ compiler cannot create executables See `config.log&#39; for more details. 则是G++没有安装好，你需要安装好G++，这个可以参照：http://www.cnblogs.com/umasuo/archive/2012/06/12/ubuntu_install_gplusplus.html 安装好后重新运行configure一下</code></pre></li><li><p>编译：make</p></li><li><p>跳转到src目录,查看一下文件列表：cd src  ll<br>　  若列表中有：-rwxr-xr-x 1 root root 47736 Jun 12 11:46 phddns*<br> 说明软件编译好了</p></li><li><p>运行：./phddns</p></li></ol><p>PS：</p><blockquote><p>由于是第一次运行，所以需要配置一下：</p></blockquote><pre><code>Enter server address(press ENTER use phlinux3.oray.net):在这里输入服务器地址，这里直接回车就行了。Enter your Oray account:在这里输入花生壳的账号Password:然后是passwordNetwork interface(s):[wlan0] = [IP:192.168.1.100][MAC:fd2e028a:fd2e028b:fd2e028c:fd2e028d:fd2e028e:fd2e028f][lo] = [IP:127.0.0.1][MAC:fd2e0262:fd2e0263:fd2e0264:fd2e0265:fd2e0266:fd2e0267]然后选择需要绑定的网卡，要是没有特殊的话，默认就可以了，我这里用的是无线，所以选择了wlan0Log to use(default /var/log/phddns.log):选择日志的保存地点Save to configuration file (/etc/phlinux.conf)?(yes/no/other):选择配置文件的保存地点，选择yes则直接保存到/etc/phlinux.conf，输入other可以指定文件，这里默认就可以了。</code></pre><blockquote><p>接下来程序开始运行，会出现以下东西：</p></blockquote><pre><code>192.168.1.100NIC bind successdefOnStatusChanged okConnectingdefOnStatusChanged okRedirectingdefOnStatusChanged okConnectingdefOnStatusChanged okDomainListeddefOnDomainRegistered umasuo.eicp.netdefOnDomainRegistered umasuo.comdefOnDomainRegistered www.umasuo.comdefOnUserInfo &lt;userInfo account=&#39;umasuo&#39; login=&#39;umasuo&#39;&gt;&lt;ID&gt;7554606&lt;/ID&gt;&lt;Account&gt;umasuo&lt;/Account&gt;&lt;Password&gt;&lt;/Password&gt;&lt;Email&gt;liuquan89@gmail.com&lt;/Email&gt;&lt;RegDate&gt;1339458707&lt;/RegDate&gt;&lt;Credit&gt;0.0&lt;/Credit&gt;&lt;Largess&gt;0.0&lt;/Largess&gt;&lt;IsEnable&gt;&lt;/IsEnable&gt;&lt;PHServer&gt;phcnc.oray.net&lt;/PHServer&gt;&lt;IsEnterprise&gt;0&lt;/IsEnterprise&gt;&lt;Contactor&gt;umasuo&lt;/Contactor&gt;&lt;IsMale&gt;1&lt;/IsMale&gt;&lt;ServiceType&gt;0&lt;/ServiceType&gt;&lt;ClientIP&gt;2105538930&lt;/ClientIP&gt;&lt;/userInfo&gt;defOnAccountDomainInfo &lt;domainInfo account=&#39;umasuo&#39; login=&#39;umasuo&#39;&gt;&lt;roots&gt;&lt;root&gt;&lt;RootName&gt;umasuo.com&lt;/RootName&gt;&lt;RegDate&gt;1339458812&lt;/RegDate&gt;&lt;ExpireDate&gt;0&lt;/ExpireDate&gt;&lt;StatusCode&gt;17&lt;/StatusCode&gt;&lt;IsCnRoot&gt;0&lt;/IsCnRoot&gt;&lt;/root&gt;&lt;/roots&gt;&lt;domains&gt;&lt;domain&gt;&lt;DomainName&gt;umasuo.eicp.net&lt;/DomainName&gt;&lt;RegDate&gt;1339458712&lt;/RegDate&gt;&lt;Account&gt;umasuo&lt;/Account&gt;&lt;StatusCode&gt;153&lt;/StatusCode&gt;&lt;RootName&gt;eicp.net&lt;/RootName&gt;&lt;IsFree&gt;1&lt;/IsFree&gt;&lt;/domain&gt;&lt;domain&gt;&lt;DomainName&gt;umasuo.com&lt;/DomainName&gt;&lt;RegDate&gt;1339458820&lt;/RegDate&gt;&lt;Account&gt;umasuo&lt;/Account&gt;&lt;StatusCode&gt;25&lt;/StatusCode&gt;&lt;RootName&gt;umasuo.com&lt;/RootName&gt;&lt;IsFree&gt;0&lt;/IsFree&gt;&lt;/domain&gt;&lt;domain&gt;&lt;DomainName&gt;www.umasuo.com&lt;/DomainName&gt;&lt;RegDate&gt;1339458820&lt;/RegDate&gt;&lt;Account&gt;umasuo&lt;/Account&gt;&lt;StatusCode&gt;25&lt;/StatusCode&gt;&lt;RootName&gt;umasuo.com&lt;/RootName&gt;&lt;IsFree&gt;0&lt;/IsFree&gt;&lt;/domain&gt;&lt;/domains&gt;&lt;domainInfo&gt;defOnStatusChanged okDomainsRegistered, UserType: 0看到上面这些就表示登录成功，这时候你可以ping一下你所绑定的域名，发现能够ping通了。</code></pre><blockquote><p>这个时候可以按ctrl+c先退出程序，将phddns拷贝到你希望的位置，例如：</p></blockquote><pre><code>cp phddns /opt/</code></pre><blockquote><p>这种东西一般可以采用后台模式运行：</p></blockquote><pre><code>/opt/phddns -c /etc/phlinux.conf -d</code></pre><blockquote><p>这样基本就可以了，如果有兴趣还可以将其配置自动启动。</p></blockquote><pre><code>PS:设置开机启动：vi /etc/rc.local最后一行加上/opt/phddns -c /etc/phlinux.conf -dps:刚刚想在ubuntu上安装一个花生壳，但是把花生壳下载下来以后想进行编译的时候出现了checking for C++ compiler default output file name... configure: error: C++ compiler cannot create executablesSee `config.log&#39; for more details.大仙是G++没有装好，于是就装了一次G++ubuntu 不知道从哪个版本开始就自带了GCC，但是G++貌似没有，于是用apt-get install g++安装，出现下面错误：The following packages have unmet dependencies:g++ : Depends: g++-4.6 (&gt;= 4.6.3-1~) but it is not going to be installedgoogle-chrome-stable : Depends: libxss1 but it is not going to be installedE: Unmet dependencies. Try &#39;apt-get -f install&#39; with no packages (or specify a solution).这个错误是因为有些需要的包没有尝试使用apt-get -f install把欠缺的包安装完毕。再次重试apt-get install g++安装成功运行g++ --version显示以下信息：g++ (Ubuntu/Linaro 4.6.3-1ubuntu5) 4.6.3Copyright (C) 2011 Free Software Foundation, Inc.This is free software; see the source for copying conditions.  There is NOwarranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.说明G++安装成功了。</code></pre>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 花生壳 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux_远程访问Linux下的mysql</title>
      <link href="/2016/03/14/shu-ju-ku/linux-access-mysql-remote/"/>
      <url>/2016/03/14/shu-ju-ku/linux-access-mysql-remote/</url>
      
        <content type="html"><![CDATA[<ol><li><p>首先尝试在mysql内赋予该账户从远程IP访问的权限。</p><pre><code> mysql -u root -p use mysql; 登陆以后运行以下命令，给予远程访问客户端权限.. grant all on *.* to &#39;ray7hu&#39;@&#39;192.168.1.5&#39; identified by &#39;password&#39;; 其中：ray7hu表示用户名.  &#39;192.168.1.5&#39; 是需要赋予访问权限的Iip地址；password表示远程登陆密码. mysql&gt; grant all on *.* to user_name@&#39;%&#39;identified by&#39;user_password&#39;;  mysql&gt; grant all on *.* to user_name@&#39;%&#39; identified by &#39;user_password&#39;; 上面的命令授予的用户权限可以访问mysql中的任意数据库和表.</code></pre></li></ol><a id="more"></a><ol start="2"><li><p>取消mysql本机绑定</p><pre><code> 也就是取消mysql默认的只能本机访问的限制。 编辑/etc/mysql/my.cnf（ubuntu下默认mysql的话就是my.cnf，不然就有可能不是这个文件名）；找到 # Instead of skip-networking the defaultis now to listen only on # localhost which is more compatible and is not less secure. bind-address = 127.0.0.1 将&quot;bind-address = 127.0.0.1&quot;注释掉（前面加上个#即可）；如果有需要，可以将127.0.0.1修改成特定的IP地址。 修改之后需要重启一下mysql服务才能生效。命令： sudo /etc/init.d/mysql restart 至此已经能够远程访问MySQL，但是你也许会发现能访问但是看不到数据库。这是因为还没有授予访问特定数据库的权限。</code></pre></li><li><p>给以存在的数据库授权</p><pre><code> 如果用户test 经常在远程IP地址192.168.1.5的客户端访问webdb数据库，那么在服务器端执行的命令应该为（改表法）： mysql&gt; use mysql mysql&gt; update db set Host=&#39;192.168.1.5&#39;where Db=&#39;webdb&#39;; mysql&gt; update user set Host=&#39;192.168.1.5&#39;where user=&#39;test&#39;; 至此，如果没有意外的话，应该就能远程访问数据库了。</code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> database </tag>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux_基本学习</title>
      <link href="/2016/03/14/yun-wei/linux-base-study/"/>
      <url>/2016/03/14/yun-wei/linux-base-study/</url>
      
        <content type="html"><![CDATA[<ol><li>快捷操作：<ul><li>切换控制台，由图形转换到控制台模式：ctrl+alt+f1(同时按下3秒钟不要马上松开)。由控制台转向图形模式是：alt+f7 </li><li>命令行—&gt;图形界面 startx</li><li>修改默认的语言项（在控制台下）：vi /etc/sysconfig/i18n中的LANG=zh_CN.GB18030(注意大小写，然后重启系统即可) </li><li>修改默认启动级别：vi /etc/inittab 修改id:3:initdefault中的3为想要的级别</li><li>翻页：shift+pageup/pagedown</li><li>关机：shutdown</li><li>重启：reboot</li></ul></li></ol><a id="more"></a><ol start="2"><li><p>我的Linux配置</p><pre><code> 用户名root        密码sunhao 用户名sunhao    密码1314520 IP地址 192.168.220.129     广播地址 192.168.220.255     子网掩码255.255.255.0</code></pre></li><li><p>Linux中的命令：</p><ul><li><p>pwd    查看当前路径名</p></li><li><p>whoami    查看当前登录的用户名</p></li><li><p>ls    列出当前路径下所有的文件和目录</p><ul><li>ls -l     按照一定格式(实验)<br/><pre><code>   以d开头的都是目录&lt;br/&gt;   以-开头的都是文件&lt;br/&gt;   以l开头的都是链接</code></pre></li><li>ls -R    按照树状结构列出目录</li></ul></li><li><p>cd    进入一个目录</p><ul><li>cd ..    返回上一层目录</li></ul></li><li><p>mkdir     创建一个目录</p></li><li><p>touch     创建一个文件</p></li><li><p>rmdir     删除一个目录(只能是空目录)</p><ul><li>rm -rf 目录    强制删除一个目录(不管是否为空)</li><li>rm -r 目录    删除一个非空的目录(会询问是否删除此目录的子目录)</li></ul></li><li><p>mount     挂载</p><ul><li>mount /dev/cdrom /mnt/cdr    把dev下的cdrom(光驱)挂载在mnt下的cdr目录下</li><li>umount (设备名/挂载点名)    取消挂载(注意要推出访问设备)</li></ul></li><li><p>cp    拷贝</p><ul><li>cp 1 2    把文件名为1的文件拷贝一份为文件2</li><li>cp    -r    s1 s2    把目录s1复制到目录s2下</li></ul></li><li><p>mv    移动文件</p><ul><li>mv 1 s1    把文件1移动到s1目录下</li><li>mv -r    同cp -r</li><li>mv sunhaoInfo sunhao    把名为sunhaoInfo的文件夹改名为sunhao</li></ul></li><li><p>clear    清屏</p></li><li><p>vi    (文本编辑器)往创建好的文件中写入</p><ul><li>vi 3.txt    如何有则直接写入，如果没有则创建<ul><li>a(回车)    开始编辑模式</li><li>ESC    退出编辑模式</li><li>:    返回命令行模式</li><li>w    存盘</li><li>q    退出</li><li>qw    存盘退出</li><li>q!    不存盘退出</li><li>dd    删除一行</li><li>dw    删除一个单词</li><li>o    往下插入一行</li><li>O(大写)    往上插入一行</li></ul></li></ul></li><li><p>more    查看文件内容</p><ul><li>more 3.txt    查看文件的内容</li></ul></li><li><p>cat        同上(顺序显示)</p></li><li><p>tac        同上(逆序显示)</p></li><li><p>head    同上</p><ul><li>head -n 3.txt    显示3.txt的前n行内容</li></ul></li><li><p>tail    同上</p><ul><li>tail -n 3.txt    显示3.txt的后n行内容</li></ul></li><li><p>find    查找文件在哪里</p><ul><li>find /sunhao -name <em>.txt    从/sunhao路径下开始查找符合</em>.txt的文件(查文档)</li></ul></li><li><p>grep    查找字符</p><ul><li>grep sunhao 1.txt    查找1.txt中字符串sunhao所在的一行</li></ul></li><li><p>whereis        查看命令在哪里</p><ul><li>whereis ls    查看ls命令所在的位置</li></ul></li><li><p>echo    查看环境变量</p><ul><li>echo $PATH    查看Linux下的PATH环境变量值(大写)</li></ul></li><li><p>ln        链接命令符</p><ul><li>ln 3.txt 4    创建3.txt的一个链接4(硬链接，复制了一个文件并在文件中建立一个链接)</li><li>ln -s 3.txt 5    同上，但是软链接(软链接、符号链接，相当于Windows中的快捷方式)</li><li>区别：删掉源文件后硬链接依然存在，而软链接就失去了链接</li></ul></li><li><p>groupadd    添加组</p><ul><li>groupadd testgroup    添加组testgroup</li></ul></li><li><p>useradd/adduser        添加用户(如果没有指定组就创建一个跟用户名相同的组)</p><ul><li>useradd testuser    添加testuser用户</li><li>useradd testuser -g testgroup    添加用户testuser到testgroup用户组</li></ul></li><li><p>passwd    为用户指定密码</p><ul><li><p>passwd testuser    为testuser添加密码</p><pre><code>  (当以普通用户身份登录的时候，直接输入passwd      1、输入当前密码      2、输入新密码      3、再次输入新密码  )</code></pre></li></ul></li><li><p>groupdel    删除组(没有用户)</p><ul><li>groupdel testgroup    删除组testgroup</li></ul></li><li><p>userdel        删除用户(注意要删除用户的主目录，home下)</p><ul><li>userdel test    删除用户test</li></ul></li><li><p>usermod        为用户更改组</p><ul><li>usermod -g testgroup testuser    把用户testuser的组改成testgroup</li></ul></li><li><p>su            切换用户</p></li></ul></li><li><p>Linux中有四种权限：<code>rwx-    ---&gt; read write execute none(读、写、执行、无)</code></p><pre><code> 权限：-rwxr-xr-x  ---&gt; 分成四组(1、表示文件类型；2、文件所有者的权限；3、文件所有者所在组的人的权限；4、其他人权限) chmod    修改权限(+:添加权限 -:取消权限)(按照rwx顺序排列) chmod +x 4    给4文件添加权限x(全部的人) chmod u+x 4        给当前用户添加4文件的x权限 chmod g+x 4        给文件所有者所在组的人添加文件4的权限x chmod o+x 4        给所有不在同组的人添加文件4的权限x chmod 777    特殊的方式修改权限         9位权限分成3组(所有者，同组人，其他人)         每一组用3位二进制表示，即752---&gt;111101010(rwxr-x-w-) chown    修改文件所有者 chown sunhao 1.txt    修改1.txt的所有者为sunhao</code></pre></li><li><p>管道    把命令以|隔开，表示依次执行</p><pre><code> ls -l | grep &quot;^d&quot;    先执行列出目录，然后执行查找以d开头的行(即只列出目录) ls -l | grep &quot;^d&quot; | wc -l     输出目录的个数 wall    警告所有登录的人 wall date    所有登录的用户都会显示all wall ・date・        警告所有登录的人执行date之后的结果(显示当前系统日期时间)</code></pre></li><li><p>重定向    把命令执行的结果写在一个文件中(输出)</p><pre><code> ls &gt; 2.txt    把ls执行结果写在2.txt中(替换) ls &gt;&gt; 2.txt        把执行结果写在2.txt中文本的最后(不替换) lsss 2&gt; 2.txt    把执行命令的错误信息写入到2.txt中    </code></pre></li><li><p>重定向    把文本中的信息取出然后输入</p><pre><code> wall &lt; 2.txt    把2.txt中的文本取出警告所有登录的人</code></pre></li><li><p>Linux FTP Service</p><pre><code> 启动：service vsftpd start    d表示后台启动 停止：service vsftpd stop 重启：service vsftpd restart 登录：ftp localhost 查IP：ifconfig    查询Linux的IP地址</code></pre></li><li><p>关闭Linux防火墙    </p><pre><code> service iptables stop</code></pre></li><li><p>允许匿名登录</p><pre><code>cmd连接Linux的FTP： ftp 192.168.94.129匿名用户名：        anonymous密码：                空</code></pre></li><li><p>Linux中FTP配置文件：/etc/vsftpd/vsftpd.conf</p></li><li><p>Linux中允许root用户登录FTP(记得要重启FTP service)：</p><pre><code>修改文件/etc/vsftpd.user_list，把root给注释掉修改文件/etc/vsftpd.ftpusers,把root给注释掉</code></pre></li><li><p>Linux中设置vsftp开机自启动：</p><pre><code>方法1：vi /ect/rc.local加入以下一句:/user/local/bin/vsftpd &amp;(表示以后台程序启动)方法2：chkconfig vsftpd on(查ckconfig的用法)</code></pre></li><li><p>ssh        远程登录</p><pre><code>启动：service sshd start(基本与vsftpd相同)</code></pre></li><li><p>Linux下安装tomcat</p><ol><li><p>解压文件：先gzip -d 文件名</p><pre><code>   再tar -xvf 上面解压后的文件名   tar -zxvf ??.tar.gz</code></pre></li><li><p>需要指定JAVA_HOME环境变量(要执行export JAVA_HOME,别人才能使用)</p></li><li><p>ps -ef        查看所有的进程(重要参数是id)</p><pre><code> ps -ef tomcat    查看tomcat进程</code></pre></li><li><p>关闭tomcat进程        <code>kill tomcat进程id</code></p></li><li><p>设置tomcat开机启动</p><pre><code> vi /etc/rc.local 加上JAVA_HOME=/usr/java/jdk1.6.0_25 export JAVA_HOME /sunhao/tomcat/bin/startup.sh</code></pre></li></ol></li><li><p>rpm </p><ul><li><p>rpm-qa    查看装了哪些软件</p><pre><code>  rpm -qa | grep jdk        查看有没有装jdk</code></pre></li><li><p>rpm    -e    卸载(查强制卸载)</p><pre><code>  rpm -e 安装包名</code></pre></li><li><p>rpm -ivh    安装</p><pre><code>  rpm -ivh 文件名(rpm文件)</code></pre></li></ul></li><li><p>设置全局环境变量</p><pre><code>/etc/profile文件    vi /etc/profile    最后一行加上JAVA_HOME=jdk目录</code></pre></li><li><p>Linux下MySQL    用户名：root    密码：1314520</p><pre><code>设置密码    mysqladmin -uroot password &#39;1314520&#39;</code></pre></li><li><p>要是发现我们的应用和数据库服务器系统时间不对可以使用这几个命令修改：</p><ul><li><p>先设置日期</p><pre><code>  date -s 20080103</code></pre></li><li><p>设置时间</p><pre><code>  date -s 18:24:00</code></pre></li><li><p>如果要同时更改BIOS时间</p><pre><code>  再执行clock -w</code></pre></li></ul></li></ol><blockquote><p>export PATH=/usr/bin:/usr/sbin:/bin:/sbin:/usr/X11R6/bin</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux_检查和收集Linux硬件信息的7个命令</title>
      <link href="/2016/03/14/yun-wei/linux-hardware/"/>
      <url>/2016/03/14/yun-wei/linux-hardware/</url>
      
        <content type="html"><![CDATA[<ol><li><p>lscpu用于查询CPU信息</p></li><li><p>lshw显示硬件信息表</p><blockquote><p>这个命令应用普遍，它可通过个人需求而列出多种不同的硬件参数：CPU、内存、硬盘、USB控制器、lshw卡片等等，本质上就是从/proc目录不同文件中中提取对应的硬件信息。</p></blockquote><pre><code> 按照下面的步骤去安装lshw工具，然后就可以使用了。 wget http://ezix.org/software/files/lshw-B.02.14.tar.gz tar -zxvf lshw-B.02.14.tar.gz cd lshw-B.02.14 make &amp;&amp; make install</code></pre></li></ol><a id="more"></a><ol start="3"><li><p>hwinfo-硬件信息</p><blockquote><p>hwinfo类似于lshw，也能查询硬件信息，且应用广泛。它也能输出多个硬件部分的详细或者简要信息，但是不同的是有时hwinfo比lshw的信息更详细。</p></blockquote><pre><code> 默认情况下，Linux系统没有安装hwinfo工具，所以你需要按照以下步骤自己安装： CentOS 6     #rpm -Uvh http://mirror.symnds.com/distributions/gf/el/6/gf/x86_64/gf-release-6-6.gf.el6.noarch.rpm     #yum list hwinfo     #yum install hwinfo CentOS 5     #rpm -Uvh http://mirror.symnds.com/distributions/gf/el/5/gf/x86_64/gf-release-5-6.gf.el5.noarch.rpm     #yum list hwinfo     #yum install hwinfo</code></pre></li><li><p>lspci</p><blockquote><p>lsppci命令可列出PCI总线的信息以及连接到PCI总线上的设备信息，比如VGA适配器、SATA控制器、其他模块等等。lspci工具是pciutils包的一部分，所以在安装lspci之前，你需要安装pciutils包。</p></blockquote><pre><code> 安装pciutils包使用下面的命令： yum install pciutils</code></pre></li><li><p>lsusb-列出USB总线信息</p></li><li><pre><code> 这个命令可列出USB控制器的设备信息。 lsusb工具是usbutils包的一部分，所以你需要按照如下命令安装： #yum install usbutils</code></pre></li><li><p>lsblk-列出块设备的信息</p><pre><code> [root@devops tmp]# lsblk</code></pre></li><li><p>lsscsi-列出SCSI的设备信息</p><pre><code> 列出SCSI/SDAT设备的信息，比如硬盘驱动器、光盘驱动器。 [root@devops tmp]# lsscsi</code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 检查 </tag>
            
            <tag> 收集 </tag>
            
            <tag> 硬件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux_设置时间</title>
      <link href="/2016/03/14/yun-wei/linux-setting-time/"/>
      <url>/2016/03/14/yun-wei/linux-setting-time/</url>
      
        <content type="html"><![CDATA[<h4 id="将系统时间设定成2008年3月28日的命令如下。"><a href="#将系统时间设定成2008年3月28日的命令如下。" class="headerlink" title="将系统时间设定成2008年3月28日的命令如下。"></a>将系统时间设定成2008年3月28日的命令如下。</h4><pre><code>#date -s 03/28/2008 </code></pre><h3 id="将系统时间设定成下午11点12分0秒的命令如下。"><a href="#将系统时间设定成下午11点12分0秒的命令如下。" class="headerlink" title="将系统时间设定成下午11点12分0秒的命令如下。"></a>将系统时间设定成下午11点12分0秒的命令如下。</h3><pre><code>#date -s 11:12:00 </code></pre><p>注意，这里说的是系统时间，是linux由操作系统维护的。 　　 </p><blockquote><p>在系统启动时，Linux操作系统将时间从CMOS中读到系统时间变量中，以后修改时间通过修改系统时间实现。为了保持系统时间与CMOS时间的一致性，Linux每隔一段时间会将系统时间写入CMOS。由于该同步是每隔一段时间（大约是11分钟）进行的，在我们执行date -s后，如果马上重起机器，修改时间就有可能没有被写入CMOS,这就是问题的原因。如果要确保修改生效可以执行如下命令。 </p></blockquote><h3 id="这个命令强制把系统时间写入CMOS。"><a href="#这个命令强制把系统时间写入CMOS。" class="headerlink" title="这个命令强制把系统时间写入CMOS。"></a>这个命令强制把系统时间写入CMOS。</h3><pre><code>#clock -w </code></pre>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 时间 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux上给新建的用户赋权限</title>
      <link href="/2016/03/14/yun-wei/linux-user-permission/"/>
      <url>/2016/03/14/yun-wei/linux-user-permission/</url>
      
        <content type="html"><![CDATA[<blockquote><p>ubuntu的超级管理员root用户默认是不启用的，root默认是空密码，所以root是不能使用的。</p></blockquote><ol><li><p>为root设置密码，在终端执行<code>sudo passwd root</code>指令后，系统会提示你设置一个root账号的密码。在你没有经过当前用户密码验证的时候，还会要求你先输入当前用户的密码，然后才能设置root帐号的密码。设置完成后，就可以在终端切换到root用户了。</p><pre><code>切换用户su root或者su sunhao</code></pre></li></ol><a id="more"></a><h1 id="linux下如何添加一个用户并且让用户获得root权限"><a href="#linux下如何添加一个用户并且让用户获得root权限" class="headerlink" title="linux下如何添加一个用户并且让用户获得root权限"></a>linux下如何添加一个用户并且让用户获得root权限</h1><h3 id="添加用户，首先用adduser命令添加一个普通用户，命令如下："><a href="#添加用户，首先用adduser命令添加一个普通用户，命令如下：" class="headerlink" title="添加用户，首先用adduser命令添加一个普通用户，命令如下："></a>添加用户，首先用adduser命令添加一个普通用户，命令如下：</h3><pre><code>    #adduser tommy  //添加一个名为tommy的用户    #passwd tommy   //修改密码    Changing password for user tommy.    New UNIX password:     //在这里输入新密码    Retype new UNIX password:  //再次输入新密码    passwd: all authentication tokens updated successfully.</code></pre><h3 id="赋予root权限"><a href="#赋予root权限" class="headerlink" title="赋予root权限"></a>赋予root权限</h3><ol><li><p>修改 /etc/sudoers 文件，找到下面一行，把前面的注释（#）去掉</p><pre><code> ## Allows people in group wheel to run all commands %wheel    ALL=(ALL)    ALL</code></pre><p> 然后修改用户，使其属于root组（wheel），命令如下：</p><pre><code> #usermod -g root tommy</code></pre><p> 修改完毕，现在可以用tommy帐号登录，然后用命令 su - ，即可获得root权限进行操作。</p></li><li><p>修改 <code>/etc/sudoers</code> 文件，找到下面一行，在root下面添加一行，如下所示：</p><pre><code> ## Allow root to run any commands anywhere root    ALL=(ALL)     ALL tommy   ALL=(ALL)     ALL</code></pre><p> 修改完毕，现在可以用tommy帐号登录，然后用命令 su - ，即可获得root权限进行操作。</p></li><li><p>修改 <code>/etc/passwd</code> 文件，找到如下行，把用户ID修改为 0 ，如下所示：</p><pre><code> tommy:x:500:500:tommy:/home/tommy:/bin/bash</code></pre><p> 修改后如下</p><pre><code> tommy:x:0:500:tommy:/home/tommy:/bin/bash</code></pre><p> 保存，用tommy账户登录后，直接获取的就是root帐号的权限。</p></li></ol><blockquote><p>友情提醒：虽然方法三看上去简单方便，但一般不推荐使用，推荐使用方法二。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 权限 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>外网访问本机</title>
      <link href="/2015/06/27/gong-ju/wai-wang-fang-wen-ben-ji/"/>
      <url>/2015/06/27/gong-ju/wai-wang-fang-wen-ben-ji/</url>
      
        <content type="html"><![CDATA[<ol><li><p>登陆路由器：一般地址为192.168.1.1，默认用户admin，密码admin。</p></li><li><p>隐射端口：找到“转发规则”―“虚拟服务器”―增加新条目–服务端口号设置为8080，IP地址设置为安装项目的IP，保存即可。</p><pre><code>  8080:指的是项目tomcat的端口号</code></pre></li><li><p>找到外网IP：一般在“运行状态”-“WAN口状态”-“IP地址”中显示，如113.<em>.</em>.*</p></li><li><p>此时外网已经可以访问，不过路由器的IP地址是动态的，会经常变，可以通过安装个动态域名解析软件来解决这个问题，以花生壳为例子。</p></li><li><p>注册个动态域名解析花生壳帐号：<a href="http://www.oray.com/passport/register.php" target="_blank" rel="noopener">http://www.oray.com/passport/register.php</a></p></li><li><p>登陆花生壳后，在域名管理注册一个免费域名</p></li><li><p>下载花生壳软件：<a href="http://www.oray.com/peanuthull/download.php" target="_blank" rel="noopener">http://www.oray.com/peanuthull/download.php</a></p></li><li><p>在安装项目的电脑上安装花生壳软件，并且使用花生壳帐号登陆，如果登陆成功，外网已经可以通过域名访问项目，地址为http://免费域名:8080/项目部署名</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>要去读的书</title>
      <link href="/2015/06/18/qi-ta/yao-qu-du-de-shu/"/>
      <url>/2015/06/18/qi-ta/yao-qu-du-de-shu/</url>
      
        <content type="html"><![CDATA[<ol><li>淘宝技术这十年</li><li>反模式</li><li>代码之美</li><li>企业应用架构模式</li><li>编程珠玑</li></ol>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>guava vs jdk8</title>
      <link href="/2015/06/14/hou-duan/guava-vs-jdk8/"/>
      <url>/2015/06/14/hou-duan/guava-vs-jdk8/</url>
      
        <content type="html"><![CDATA[<p>#Guava<br>Guava是Google公司开源的一个实用工具库，对Java类库进行了多方面的增强。比如说，对函数式编程的支持，新的集合类（Multimap等），Cache支持，等等。在Java8之前，Guava和Java之间的关系，可以表示成下面这幅图：<br><img src="http://img.blog.csdn.net/20140923165231890?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvenhob28=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p><a id="more"></a><p>但是随着Java8的发布，Guava和Java的关系发生了一些改变。Guava提供的很多功能，被内置在了Java8里，如下图所示：<br><img src="http://img.blog.csdn.net/20140923134859281?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvenhob28=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p><ul><li>源码： <a href="https://github.com/google/guava" target="_blank" rel="noopener" title="Github">Github</a> <a href="https://code.google.com/p/guava-libraries/" target="_blank" rel="noopener" title="Google Code">Google Code</a></li><li>API： <a href="http://docs.guava-libraries.googlecode.com/git-history/release/javadoc/index.html" target="_blank" rel="noopener" title="API">API</a></li><li>Users’ Guide：<a href="https://code.google.com/p/guava-libraries/wiki/GuavaExplained" target="_blank" rel="noopener" title="Users&#39; Guide">Users’ Guide</a></li></ul><ol><li><p>Joiner用来拼接n个字符串，下面是一个例子：</p><ul><li><p>使用guava</p><pre><code>  public static String useGuava(List strList) {      return Joiner.on(&quot;,&quot;).skipNulls().join(strList);  }</code></pre></li><li><p>使用jdk8</p><pre><code>  public static String useJdk8(List strList) {      //lambda表达式      return strList.stream().filter(m -&gt; m != null).collect(Collectors.joining(&quot;,&quot;));  }</code></pre></li><li><p>使用jdk7以及jdk7之前的版本</p><pre><code>  public static String useJdk7(List strList) {      StringBuilder sb = new StringBuilder();      for (int i = 0; i &lt; strList.size(); i++) {          sb.append(strList.get(i));          if (i + 1 != strList.size()) {              sb.append(&quot;,&quot;);          }      }      return sb.toString();  }</code></pre></li></ul></li><li><p>Guava提供了Ordering类以方便我们创建Comparator</p><ul><li><p>使用guava</p><pre><code>  public static List useGuava(List players) {      Ordering ordering = Ordering.natural().nullsFirst().onResultOf(new Function() {          @Override          public Integer apply(Player foo) {              return foo.getOrder();          }      });      return ordering.sortedCopy(players);  }</code></pre></li><li><p>使用jdk8</p><pre><code>  public static List useJdk8(List players) {      Comparator cmp = Comparator.comparing(Player::getOrder, Comparator.nullsFirst(Comparator.naturalOrder()));      players.sort(cmp);      return players;  }</code></pre></li><li><p>使用jdk7以及jdk7之前的版本</p><pre><code>  public static List useJdk7(List players) {      players.sort(new Comparator() {          @Override          public int compare(Player o1, Player o2) {              Integer order1 = o1.getOrder();              Integer order2 = o2.getOrder();              if (order1 &gt; order2) {                  return 1;              } else if (order1 == order2) {                  return 0;              } else {                  return -1;              }          }      });      return players;  }</code></pre></li></ul></li><li><p>对null的处理</p><ul><li><p>guava中对null的处理<code>Optional</code></p><ul><li><p>null是模棱两可的，会引起令人困惑的错误，有些时候它让人很不舒服。很多Guava工具类用快速失败拒绝null值，而不是盲目地接受。</p></li><li><p><code>Optional</code>是一个<code>abstract</code>类，两个实现类<code>Present</code>、<code>Absent</code></p><ul><li><code>Present</code>: Implementation of an Optional containing a reference.</li><li><code>Absent</code>: Implementation of an Optional not containing a reference.</li></ul><p>eg:</p><pre><code>   // 创建一个非空对象，类型为integer   Optional possible = Optional.of(6);   // Returns true if this holder contains a (non-null) instance.   System.out.println(&quot;possible isPresent: &quot; + possible.isPresent());   System.out.println(&quot;possible value: &quot; + possible.get());   // 创建一个空对象   Optional absentOpt = Optional.absent();   // 取值，会报错   System.out.println(&quot;absentOpt value: &quot; + absentOpt.get());   // If nullableReference is non-null, returns an Optional instance containing that reference; otherwise returns Optional.absent.   // fromNullable表示如果创建一个非空对象，则返回Present   Optional&lt;Integer&gt; NoNullableOpt  = Optional.fromNullable(10);   // 创建空对象，则返回Absent   Optional&lt;Integer&gt; NullableOpt = Optional.fromNullable(null);</code></pre><p>其他详细请查阅API - <a href="http://docs.guava-libraries.googlecode.com/git-history/release/javadoc/com/google/common/base/Optional.html" target="_blank" rel="noopener" title="Guava Optional API">Guava Optional API</a></p></li></ul></li><li><p>Guava使用<code>Preconditions</code>对null的预先判断</p><ul><li><p>类似我们使用StringUtils等工具类</p></li><li><p>但是不同的是，StringUtils等工具类是判断是否为空并得到结果，而Guava是使用判断的结果，如果为空，则直接抛异常。<br>eg.</p><pre><code>      // givenName是传入的参数      String name = Preconditions.checkNotNull(givenName);      // com.google.common.base.Preconditions.checkNotNull方法重载了三次      public static &lt;T&gt; T checkNotNull(T reference)      public static &lt;T&gt; T checkNotNull(T reference, Object errorMessage)      public static &lt;T&gt; T checkNotNull(T reference, String errorMessageTemplate, Object... errorMessageArgs)      // 而jdk8中的java.util.Objects也提供了三个类似的方法      public static &lt;T&gt; T requireNonNull(T obj) // @since 1.7      public static &lt;T&gt; T requireNonNull(T obj, String message) // @since 1.7      public static &lt;T&gt; T requireNonNull(T obj, Supplier&lt;String&gt; messageSupplier) // @since 1.8</code></pre></li></ul></li><li><p>jdk8对null的处理<br> jdk8新加入类java.util.Optional，使用方法与Guava相似。关于jdk8中的Optional可参考<a href="http://www.ithome.com.tw/voice/91013" target="_blank" rel="noopener" title="迟到的Optional">迟到的Optional</a>。Optional 被定义为一个简单的容器，其值可能是null或者不是null。在Java 8之前一般某个函数应该返回非空对象但是偶尔却可能返回了null，而在Java 8中，不推荐你返回null而是返回Optional。<br>eg.</p><pre><code>      // 不直接返回需要的类型String，而是返回Optional包含的String      Optional&lt;String&gt; optional = Optional.of(&quot;bam&quot;);      //  true if there is a value present, otherwise false      optional.isPresent();           // true      //  取值，如果为空，则抛出异常NoSuchElementException      optional.get();                 // &quot;bam&quot;      // 如果为空则返回传入的值，否则返回其值      optional.orElse(&quot;fallback&quot;);    // &quot;bam&quot;      // 结合lambda表达式      optional.ifPresent((s) -&gt; System.out.println(s.charAt(0)));     // &quot;b&quot;</code></pre></li></ul><p>其他详细请查阅API - <a href="http://docs.oracle.com/javase/8/docs/api/java/util/Optional.html" target="_blank" rel="noopener" title="JDK8 Optional API">JDK8 Optional API</a></p></li><li><p>对于集合的处理</p><ul><li><p>创建集合</p><ul><li><p>普通做法<br>  eg.</p><pre><code>  List&lt;Player&gt; players = new ArrayList&lt;Player&gt;();  players.add(new Player(&quot;bowen&quot;,20));  players.add(new Player(&quot;bob&quot;, 20));  players.add(new Player(&quot;Katy&quot;, 18));  players.add(new Player(&quot;Logon&quot;, 24));</code></pre></li><li><p>在Guava中：<br>  eg.</p><pre><code>  List&lt;Player&gt;  players = Lists.newArrayList(new Player(&quot;bowen&quot;, 20), new Player(&quot;bob&quot;, 20), new Player(&quot;Katy&quot;, 18), new Player(&quot;Logon&quot;, 24));</code></pre></li><li><p>Java中：<br>  eg.</p><pre><code>  List&lt;Player&gt; players = new ArrayList&lt;Player&gt;() { {      add(new Player(&quot;bowen&quot;, 20));      add(new Player(&quot;bob&quot;, 20));      add(new Player(&quot;Katy&quot;, 18));      add(new Player(&quot;Logon&quot;, 24));  }};</code></pre></li></ul></li><li><p>操作集合<br>  要求：按年龄将上述人员分组</p><ul><li><p>通常的做法（jdk8之前的版本）</p><pre><code>  public void mapListJava7(List&lt;Player&gt; players) {      Map&lt;Integer, List&lt;Player&gt;&gt; groups = new HashMap&lt;&gt;();      for (Player player : players) {          List&lt;Player&gt; group = groups.get(player.getAge());          if (group == null) {              group = new ArrayList&lt;&gt;();              groups.put(player.getAge(), group);          }          group.add(player);      }  }</code></pre></li><li><p>在guava中，提供了<code>Multimap</code></p><pre><code>  public void guavaMultimap(List&lt;Player&gt; players) {      Multimap&lt;Integer, Player&gt; groups = ArrayListMultimap.create();      for (Player player : players) {          groups.put(player.getAge(), player);      }  }</code></pre></li><li><p>在jdk8中，给Map添加了一个新的方法<code>getOrDefault()</code>，即使不用lambda表达式，代码也清洁许多：</p><pre><code>  // 非lambda  public void mapListJava8(List&lt;Player&gt; players) {      Map&lt;Integer, List&lt;Player&gt;&gt; groups = new HashMap&lt;&gt;();      for (Player player : players) {          List&lt;Player&gt; group = groups.getOrDefault(player.getAge(), new ArrayList&lt;&gt;());          group.add(player);          groups.put(player.getAge(), group);      }  }  // 使用lambda表达式  public void groupingByJava8(List&lt;Player&gt; players) {      Map&lt;Integer, List&lt;Player&gt;&gt; groups = players.stream().collect(Collectors.groupingBy(Player::getAge));  }</code></pre></li></ul></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JDK8 </tag>
            
            <tag> guava </tag>
            
            <tag> 函数式编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数式编程介绍</title>
      <link href="/2015/06/14/hou-duan/han-shu-shi-bian-cheng-jie-shao/"/>
      <url>/2015/06/14/hou-duan/han-shu-shi-bian-cheng-jie-shao/</url>
      
        <content type="html"><![CDATA[<p>##什么是函数式编程<br>函数式编程是种编程典范，它将电脑运算视为函数的计算。函数编程语言最重要的基础是 λ 演算（lambda calculus）。而且λ演算的函数可以<strong>接受函数当作输入（参数）和输出（返回值）</strong>。和指令式编程相比，函数式编程强调函数的计算比指令的执行重要。和过程化编程相比，函数式编程里，函数的计算可随时调用。</p><a id="more"></a><p>##Guava中的函数式编程<br>为了支持函数式编程，Guava提供了下面这两个接口：</p><pre><code>public interface Function&lt;F, T&gt; {    @Nullable T apply(@Nullable F input);}public interface Predicate&lt;T&gt; {    boolean apply(@Nullable T input);}</code></pre><p>举个例子：在一群People对象中，找到年龄大于20的People</p><ul><li><p>通常做法：</p><p>  List<Person> oldPeople = new ArrayList<Person>();<br>  for (Person person : people) {</p><pre><code>  if (person.getAge() &gt;= 20) {      oldPeople.add(person);  }</code></pre><p>  }</p></li><li><p>在Guava中提供了filter模式，filter即从一个集合中根据一个条件筛选元素。</p><ul><li><p>找出age大于20的</p><pre><code>  List&lt;Person&gt; oldPeople = Lists.newArrayList(Collections2.filter(people, new Predicate&lt;Person&gt;() {      public boolean apply(Person person) {          return person.getAge() &gt;= 20;      }  }));</code></pre></li><li><p>找出name中含有字符w的</p><pre><code>  List&lt;Person&gt; oldPeople = Lists.newArrayList(Collections2.filter(people, new Predicate&lt;Person&gt;() {      public boolean apply(Person person) {          return person.getName().contains(&quot;w&quot;);      }  }));</code></pre></li><li><p>找出age&gt;20并且name中含有字符w的人</p><pre><code>  // 一般大家都会这么写，当然这种写法是可以的  List&lt;Person&gt; oldPersons = Lists.newArrayList(Collections2.filter(persons, new Predicate&lt;Person&gt;() {      public boolean apply(Person person) {          return person.getAge() &gt;= 20 &amp;&amp; person.getName().contains(&quot;w&quot;);      }  }));</code></pre></li></ul></li></ul><p>这样写的话就有一定的代码重复，因为之前我们已经写了两个Predicate来分别实现这两个条件判断，能不能重用之前的Predicate那？答案是能。 我们首先将之前生成年龄判断和名称判断的两个Predicate抽成方法。</p><pre><code>private Predicate&lt;Person&gt; ageBiggerThan(final int age) {    return new Predicate&lt;Person&gt;() {        public boolean apply(Person person) {            return person.getAge() &gt;= age;        }    };}private Predicate&lt;Person&gt; nameContains(final String str) {    return new Predicate&lt;Person&gt;() {        public boolean apply(Person person) {            return person.getName().contains(str);        }    };}//而我们的结果其实就是这两个Predicate相与。Guava给我们提供了and方法，用于对一组Predicate求与。List&lt;Person&gt; filteredPeople = Lists.newArrayList(Collections2.filter(people, Predicates.and(ageBiggerThan(20), nameContains(&quot;w&quot;))));</code></pre><p>##JDK8中的函数式编程<br>在上面的例子中：</p><ul><li><p>在一群People对象中，找到年龄大于20的People</p><p>  List<Person> filteredPeople = persons.stream().filter(p -&gt; p.getAge() &gt;= 20).collect(Collectors.toList());</p></li><li><p>找出name中含有字符w的</p><pre><code>  List&lt;Person&gt; filteredPeople = persons.stream().filter(p -&gt; p.getName().contains(&quot;w&quot;)).collect(Collectors.toList());</code></pre></li></ul><p>##总结</p><ol><li>无法升级jdk版本的项目，推荐使用guava<blockquote><p>guava作为jdk8最好的替代品，是值得使用的</p></blockquote></li><li>可以平稳升级jdk的项目，推荐使用jdk8<blockquote><p>jdk8天生的优势，注定它优于guava，再加上后来引入的lambda表达式，使jdk8的语法更加优美</p></blockquote></li><li>jdk8出生于guava之后，所以说，jdk8很多地方都是借鉴于guava</li></ol>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JDK8 </tag>
            
            <tag> 函数式编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的服务列表</title>
      <link href="/2014/10/26/qi-ta/wo-de-fu-wu-lie-biao/"/>
      <url>/2014/10/26/qi-ta/wo-de-fu-wu-lie-biao/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Git</p></blockquote><ul><li><a href="http://git.sunhao.com:82/" target="_blank" rel="noopener" title="我的gitlab">我的gitlab</a></li></ul><a id="more"></a><hr><blockquote><p>SVN</p></blockquote><ul><li><a href="http://sunhao-java.vicp.cc/svntool/" target="_blank" rel="noopener" title="Subversion 在线自助密码修改">Subversion 在线自助密码修改</a></li><li><a href="http://sunhao-java.vicp.cc/message/" target="_blank" rel="noopener" title="message - svn">message - svn</a></li><li><a href="http://sunhao-java.vicp.cc/messageboard/" target="_blank" rel="noopener" title="messageboard - svn">messageboard - svn</a></li><li><a href="http://sunhao-java.vicp.cc/resources/" target="_blank" rel="noopener" title="resources - svn">resources - svn</a></li><li><a href="http://sunhao-java.vicp.cc/blog/" target="_blank" rel="noopener" title="blog - svn">blog - svn</a></li><li><a href="http://sunhao-java.vicp.cc/knowledge/" target="_blank" rel="noopener" title="knowledge - svn">knowledge - svn</a></li></ul><hr><blockquote><p>Demo</p></blockquote><ul><li><a href="http://sunhao-java.vicp.cc/message_test/" target="_blank" rel="noopener" title="Message-Core Demo">Message-Core Demo</a></li></ul><hr><blockquote><p>工具类</p></blockquote><ul><li><a href="http://sunhao-java.vicp.cc/myblog/" target="_blank" rel="noopener" title="孙昊的博客">孙昊的博客</a></li><li><a href="http://sunhao-java.vicp.cc/nexus/" target="_blank" rel="noopener" title="Nexus">Nexus</a></li><li><a href="http://sunhao-java.vicp.cc/sonar/" target="_blank" rel="noopener" title="Sonar代码质量管理">Sonar代码质量管理</a></li><li><a href="http://sunhao-java.vicp.cc/jenkins/" target="_blank" rel="noopener" title="Jenkins [Dashboard]">Jenkins [Dashboard]</a></li></ul><hr><blockquote><p>数据库管理</p></blockquote><ul><li><a href="http://sunhao-java.vicp.cc/mysql/" target="_blank" rel="noopener" title="phpMyAdmin">phpMyAdmin</a></li><li><a href="http://sunhao-java.vicp.cc/rockmongo/index.php?action=login.index" target="_blank" rel="noopener" title="RockMongo">RockMongo</a></li><li><a href="http://sunhao-java.vicp.cc/redis/" target="_blank" rel="noopener" title="phpRedisAdmin">phpRedisAdmin</a></li><li><a href="http://sunhao-java.vicp.cc/memcached/" target="_blank" rel="noopener" title="phpMemcachedAdmin">phpMemcachedAdmin</a></li></ul><hr><blockquote><p>监控</p></blockquote><ul><li><a href="http://sunhao-java.vicp.cc/solr/" target="_blank" rel="noopener" title="Solr">Solr</a></li><li><a href="http://sunhao-java.vicp.cc/dubbo/" target="_blank" rel="noopener" title="Dubbo Admin">Dubbo Admin</a></li><li><a href="http://sunhao-java.vicp.cc:15672/" target="_blank" rel="noopener" title="RabbitMQ">RabbitMQ</a></li></ul><hr><blockquote><p>帮助文档</p></blockquote><ul><li><a href="http://sunhao-java.vicp.cc/jdk7/" target="_blank" rel="noopener" title="Java Platform SE 7">Java Platform SE 7</a></li><li><a href="http://sunhao-java.vicp.cc/jdk8/" target="_blank" rel="noopener" title="Java Platform SE 8">Java Platform SE 8</a></li><li><a href="http://sunhao-java.vicp.cc/jquery/" target="_blank" rel="noopener" title="jQuery 帮助文档">jQuery 帮助文档</a></li><li><a href="http://sunhao-java.vicp.cc/python/" target="_blank" rel="noopener" title="Python documentation">Python documentation</a></li><li><a href="http://sunhao-java.vicp.cc/bootstrap/" target="_blank" rel="noopener" title="bootstrap">bootstrap</a></li><li><a href="http://sunhao-java.vicp.cc/adminLTE/" target="_blank" rel="noopener" title="bootstrap adminLTE">bootstrap adminLTE</a></li><li><a href="http://sunhao-java.vicp.cc/php/" target="_blank" rel="noopener" title="PHP 手册">PHP 手册</a></li><li><a href="http://sunhao-java.vicp.cc/redisdoc/" target="_blank" rel="noopener" title="Redis 命令参考">Redis 命令参考</a></li><li><a href="http://sunhao-java.vicp.cc/redisbook/" target="_blank" rel="noopener" title="Redis 设计与实现">Redis 设计与实现</a></li></ul><hr><blockquote><p>其他</p></blockquote><ul><li><a href="http://sunhao-java.vicp.cc/mail/" target="_blank" rel="noopener" title="php mail">php mail</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 孙昊 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sonar使用方法</title>
      <link href="/2014/10/17/zhong-jian-jian/sonar-shi-yong-fang-fa/"/>
      <url>/2014/10/17/zhong-jian-jian/sonar-shi-yong-fang-fa/</url>
      
        <content type="html"><![CDATA[<p>###方法1：直接在服务器分析</p><ul><li><p>在项目源代码目录新建sonar-project.properties文件<code>touch sonar-project.properties</code></p></li><li><p>编辑此文件<code>vim sonar-project.properties</code>，内容如下：</p><pre><code>  # Required metadata  sonar.projectKey=my:project        #项目的key  sonar.projectName=My project    #项目显示的名称  sonar.projectVersion=1.0        #版本</code></pre></li></ul><a id="more"></a><pre><code>    # Path to the parent source code directory.    # Path is relative to the sonar-project.properties file. Replace &quot;\&quot; by &quot;/&quot; on Windows.    # Since SonarQube 4.2, this property is optional if sonar.modules is set.    # If not set, SonarQube starts looking for source code from the directory containing    # the sonar-project.properties file.    sonar.sources=src                #项目源代码目录    # Encoding of the source code    sonar.sourceEncoding=UTF-8        #使用的编码格式    # Additional parameters    sonar.my.property=value</code></pre><ul><li>执行债务分析<ul><li>在上面文件所在路径执行<code>sonar-runner</code></li></ul></li></ul><p>###方法2：结合maven使用</p><ul><li><p>配置maven的setting.xml文件，位置：<code>%MAVEN_HOME%/conf/settings.xml</code></p><pre><code>  &lt;profile&gt;     &lt;id&gt;sonar&lt;/id&gt;     &lt;activation&gt;        &lt;activeByDefault&gt;true&lt;/activeByDefault&gt;     &lt;/activation&gt;     &lt;properties&gt;        &lt;!-- 数据库url --&gt;        &lt;sonar.jdbc.url&gt;jdbc:mysql://172.16.128.160:3306/sonar&lt;/sonar.jdbc.url&gt;        &lt;!-- 数据库driver --&gt;        &lt;sonar.jdbc.driver&gt;com.mysql.jdbc.Driver&lt;/sonar.jdbc.driver&gt;        &lt;!-- 数据库username --&gt;        &lt;sonar.jdbc.username&gt;sonar&lt;/sonar.jdbc.username&gt;        &lt;!-- 数据库password --&gt;        &lt;sonar.jdbc.password&gt;sonar&lt;/sonar.jdbc.password&gt;        &lt;!-- sonar地址 --&gt;        &lt;sonar.host.url&gt;http://172.16.128.160:19000&lt;/sonar.host.url&gt;     &lt;/properties&gt;  &lt;/profile&gt;</code></pre></li><li><p>执行maven命令</p><ul><li>mvn sonar:sonar</li></ul></li></ul><hr><p>#问题解决:</p><ul><li><p>执行债务分析时，若报错，并且sonar后台日志（%SONARQUBE_HOME%/logs/sonar.log）中有如下错误<br>  <code>undefined method &#39;generate&#39; for #&lt;JSON::Ext::Generator::State:0x76afc32d&gt;</code></p><p>  <strong>问题原因</strong>：Sonar后台有Ruby on Rails工程，会用到Ruby的API，这个是Ruby的异常。由于部署的服务器刚好也装过Ruby版本，导致了调用自己安装的Ruby，而不是Sonar内嵌的Ruby，导致出现错误</p><p>  <strong>解决方案</strong>：在sonar的启动脚本soanr.sh的开头加入unset GEM_PATH ，在重新启动即可，通过这个命令可以保证每次启动的时候使用sonar内置的ruby版本</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Sonar </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sonar安装步骤</title>
      <link href="/2014/10/13/zhong-jian-jian/sonar-an-zhuang-bu-zou/"/>
      <url>/2014/10/13/zhong-jian-jian/sonar-an-zhuang-bu-zou/</url>
      
        <content type="html"><![CDATA[<ol><li>下载<strong>sonarqube-4.5.zip</strong>和<strong>sonar-runner-dist-2.4.zip</strong><ul><li>下载地址：<ul><li><a href="http://www.sonarqube.org/downloads/" target="_blank" rel="noopener" title="sonarqube">http://www.sonarqube.org/downloads/</a></li></ul></li></ul></li></ol><a id="more"></a><ol start="2"><li><p>上传到服务器，解压</p><ul><li><code>unzip sonarqube-4.5.zip</code></li><li><code>unzip sonar-runner-dist-2.4.zip</code></li></ul></li><li><p>设置环境变量</p><pre><code> export SONAR_RUNNER_HOME=/opt/sonar/sonar-runner-2.4 export PATH=$SONAR_RUNNER_HOME/bin:$PATH</code></pre></li><li><p>修改配置</p><ul><li><p>修改sonarqube的配置<code>%SONARQUBE_HOME%/conf/sonar.properties</code></p><pre><code>  # User credentials.  # Permissions to create tables, indices and triggers must be granted to JDBC user.  # The schema must be created first.  sonar.jdbc.username=sonar  sonar.jdbc.password=sonar  #----- MySQL 5.x  sonar.jdbc.url=jdbc:mysql://localhost:3306/sonar?useUnicode=true&amp;characterEncoding=utf8&amp;rewriteBatchedStatements=true&amp;useConfigs=maxPerformance</code></pre></li><li><p>修改sonar-runner的配置<code>%SONAR_RUNNER_HOME%/conf/sonar-runner.properties</code></p><pre><code>  #----- Default SonarQube server  sonar.host.url=http://localhost:9000  #----- PostgreSQL  #sonar.jdbc.url=jdbc:postgresql://localhost/sonar  #----- MySQL  sonar.jdbc.url=jdbc:mysql://localhost:3306/sonar?useUnicode=true&amp;amp;characterEncoding=utf8  #----- Global database settings  sonar.jdbc.username=sonar  sonar.jdbc.password=sonar  #----- Default source code encoding  sonar.sourceEncoding=UTF-8  #----- Security (when &#39;sonar.forceAuthentication&#39; is set to &#39;true&#39;)  sonar.login=admin  sonar.password=admin</code></pre></li></ul></li><li><p>创建数据库，脚本如下：</p><pre><code> create database if not exists sonar character set utf8; CREATE USER &#39;sonar&#39;@&#39;%&#39; IDENTIFIED BY &#39;sonar&#39;; CREATE USER &#39;sonar&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;sonar&#39;; grant all privileges on sonar.* to &#39;sonar&#39;@&#39;%&#39; identified by &#39;sonar&#39;; grant all privileges on sonar.* to &#39;sonar&#39;@&#39;localhost&#39; identified by &#39;sonar&#39;; flush privileges;</code></pre></li><li><p>启动sonar:</p><ul><li><code>%SONARQUBE_HOME%/bin/linux-x86-64/sonar.sh</code></li><li>请将%SONARQUBE_HOME%替换成sonar安装目录</li><li>linux-x86-64视具体操作系统而定</li></ul></li><li><p>汉化步骤</p><ul><li>下载汉化包<br>  <a href="http://repository.codehaus.org/org/codehaus/sonar-plugins/l10n/sonar-l10n-zh-plugin/" target="_blank" rel="noopener" title="sonar-l10n-zh-plugin">http://repository.codehaus.org/org/codehaus/sonar-plugins/l10n/sonar-l10n-zh-plugin/</a></li><li>放入%SONARQUBE_HOME%/extensions/plugins/下</li><li>重启server即可</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Sonar </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux_Ubuntu安装Redis</title>
      <link href="/2014/10/12/zhong-jian-jian/linux-ubuntu-an-zhuang-redis/"/>
      <url>/2014/10/12/zhong-jian-jian/linux-ubuntu-an-zhuang-redis/</url>
      
        <content type="html"><![CDATA[<ol><li><p>下载安装</p><ul><li><p>将安装包上传，放入<code>/opt/software/redis</code></p></li><li><p>执行命令</p><pre><code>  tar -zxf redis-2.8.13.tar.gz  cd redis-2.8.13  make  sudo make install  make test</code></pre></li></ul></li></ol><a id="more"></a><ol start="2"><li><p>这时Redis 的可执行文件被放到了<code>/usr/local/bin</code></p><ul><li><p>下载配置文件和init启动脚本：</p><pre><code>  wget https://github.com/ijonas/dotfiles/raw/master/etc/init.d/redis-server  wget https://github.com/ijonas/dotfiles/raw/master/etc/redis.conf  sudo mv redis-server /etc/init.d/redis-server  sudo chmod +x /etc/init.d/redis-server  sudo mv redis.conf /etc/redis.conf  备注:  redis-server        --&gt; [Linux_Ubuntu安装Redis_redis-server]  Redis_redis.conf    --&gt; [Linux_Ubuntu安装Redis_redis.conf]</code></pre></li></ul></li><li><p>初始化用户和日志路径[必须执行]</p><ul><li><p>第一次启动Redis前，建议为Redis单独建立一个用户，并新建data和日志文件夹</p><pre><code>  sudo useradd redis  sudo mkdir -p /var/lib/redis  sudo mkdir -p /var/log/redis  sudo chown redis.redis /var/lib/redis  sudo chown redis.redis /var/log/redis</code></pre></li></ul></li><li><p>设置开机自动启动，关机自动关闭</p><pre><code> sudo update-rc.d redis-server defaults</code></pre></li><li><p>启动Redis：</p><pre><code> sudo /etc/init.d/redis-server start</code></pre></li><li><p>启动client客户端连接:</p><pre><code> root@sunhao-linux:~# redis-cli 127.0.0.1:6379&gt; set foo bar OK 127.0.0.1:6379&gt; get foo &quot;bar&quot;</code></pre></li></ol><hr><p>#####问题解决：</p><ol><li><p>如果遇到make test发生错误：</p><pre><code> 现象：     root@sunhao-linux:/opt/redis# make test     cd src &amp;&amp; make test     make[1]: 正在进入目录 `/opt/redis/src&#39;     You need tcl 8.5 or newer in order to run the Redis test     make[1]: *** [test] 错误 1     make[1]:正在离开目录 `/opt/redis/src&#39;     make: *** [test] 错误 2 解决方案：     root@sunhao-linux:/opt/redis# apt-get install tcl</code></pre></li></ol><hr><p>#####PS:安装之后的信息<br>    =============================================================================<br>    jemalloc version   : 3.6.0-0-g46c0af68bd248b04df75e4f92d5fb804c3d75340<br>    library revision   : 1<br>    CC                 : gcc<br>    CPPFLAGS           :  -D_GNU_SOURCE -D_REENTRANT<br>    CFLAGS             : -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -fvisibility=hidden<br>    LDFLAGS            :<br>    EXTRA_LDFLAGS      :<br>    LIBS               :  -lpthread<br>    RPATH_EXTRA        :<br>    XSLTPROC           : false<br>    XSLROOT            :<br>    PREFIX             : /usr/local<br>    BINDIR             : /usr/local/bin<br>    INCLUDEDIR         : /usr/local/include<br>    LIBDIR             : /usr/local/lib<br>    DATADIR            : /usr/local/share<br>    MANDIR             : /usr/local/share/man<br>    srcroot            :<br>    abs_srcroot        : /opt/software/redis/redis-2.8.13/deps/jemalloc/<br>    objroot            :<br>    abs_objroot        : /opt/software/redis/redis-2.8.13/deps/jemalloc/<br>    JEMALLOC_PREFIX    : je_<br>    JEMALLOC_PRIVATE_NAMESPACE<br>                       : je_<br>    install_suffix     :<br>    autogen            : 0<br>    experimental       : 1<br>    cc-silence         : 1<br>    debug              : 0<br>    code-coverage      : 0<br>    stats              : 1<br>    prof               : 0<br>    prof-libunwind     : 0<br>    prof-libgcc        : 0<br>    prof-gcc           : 0<br>    tcache             : 1<br>    fill               : 1<br>    utrace             : 0<br>    valgrind           : 0<br>    xmalloc            : 0<br>    mremap             : 0<br>    munmap             : 0<br>    dss                : 0<br>    lazy_lock          : 0<br>    tls                : 1<br>    =============================================================================</p>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Ubuntu </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>作为一个苦逼码农，我要想想我以后的出路</title>
      <link href="/2014/04/09/ge-ren-gan-wu/as-a-coder/"/>
      <url>/2014/04/09/ge-ren-gan-wu/as-a-coder/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;程序员，在外行看来是一个很高端的行业，搞IT的，高端人才，天天坐办公室，多爽。可是在我们自己看来，只有自己知道自己的苦。每天不固定的加班不说，还有忍受着客户各种无理苛刻的需求。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;或许是我们自己对技术的热爱，对新技术的狂热追求，他甚至曾经有段时间超越我追求妹子的欲望。我可以为一个bug熬个通宵，我可以为了一个新技术狂啃3天馒头不出门，但是我忍受不了别人对我的努力不赞同。这可能就是最真实的程序猿。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;程序猿不擅长与人交流，因为程序猿最擅长的是和电脑打交道，他们视电脑如媳妇，视代码如孩子，视新技术如新衣服一样的狂热追求。有人说，程序猿是最好的老公人选，他们有着固定的工作，拿着高薪，而且不会乱花钱，接触面很窄，很难出轨，经常会加班，不会约束到另一方。是的，我们确实是这样的状态，但是谁能知道我们心中的狂野吗？我们会骂，这傻逼系统，真垃圾，要我做，绝对比这好一百倍。还有这傻逼客户，怎么会提出这样傻逼的需求呢？</p><p>&nbsp;&nbsp;&nbsp;&nbsp;今天一个同事说要辞职了，问他原因，他说要去自己做生意了，觉得做程序猿没有前途，要去和朋友合伙卖手机。很好的一个想法，反过来我想想自己，除了能写的了一手好代码，又能干些什么？在公司，每天帮着同事解决各种他们解决不了的问题，然后听着他们说你好厉害啊，我觉得心里特别舒服，很有成就感，或者发现某一个问题很操蛋，然后自己熬了一个通宵写出一个工具，然后心满意足的群发一封邮件给各个同事，最好带着慢慢的成就感上床睡觉去了。可是，一走到外面，那情况就正好反过来了，别人都说，你怎么这个都不会。。。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;我的生活很单调，除了公司、吃饭的地方、睡觉的地方就没有了，每个周末之前都在心里说，明天是个好周末，我要出去转转，结果周五或者周六晚上，领导或者现场一个电话来，说这里有问题，帮忙改改，明天要上线客户要看，我就哼哧哼哧的搞到2-3点钟，第二天一觉睡到下午，久而久之，也就习惯了这样的作息时间。以至于现在没了六块腹肌，没了胸肌，没了肱二头肌。啥也没了。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;如果不做程序猿，我能做什么？去珠江路开个修电脑的店？在小区附近开个奶茶店？还是回老家和我爸一起做装潢？我他妈的到底能做什么？</p>]]></content>
      
      
      <categories>
          
          <category> 个人感悟 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>写给亲爱的媳妇还有未来的娃</title>
      <link href="/2014/01/14/ge-ren-gan-wu/for-you/"/>
      <url>/2014/01/14/ge-ren-gan-wu/for-you/</url>
      
        <content type="html"><![CDATA[<p>现在是2014年1月14号晚上6点39。</p><h1 id="致我未来的媳妇（现在叫亲爱的媳妇）："><a href="#致我未来的媳妇（现在叫亲爱的媳妇）：" class="headerlink" title="致我未来的媳妇（现在叫亲爱的媳妇）："></a>致我未来的媳妇（现在叫亲爱的媳妇）：</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;虽然我现在还不知道你到底是谁？到底是哪里人？但是有些话我还是很想跟你说说。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;首先，你可以说你不懂爱情，因为我自己也不太懂，咱可以一起去学习什么是爱情，什么是家庭。我们一起长大，一起慢慢的变老，直到死去。这不是很浪漫很幸福的事情吗。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;其次，咱结婚以后，家里的财政大臣由你来当，我不会理财，也不喜欢去理财，所以这重任只能交给你来做了。我负责挣钱，你负责花钱。在家，你就是我的公主、我的皇上，我是你的取暖器、你的泄气包；在外，我是你的避风港、你的移动指路台、你的保镖。如果以后我们有了孩子，如果是女孩，那我会永远保护你们娘俩，如果是男孩，那我们爷俩永远会保护你。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;最后，也是最重要的一点，我喜欢你能像对你父母兄弟姐妹一样的对待我的父母兄弟姐妹，因为他们是我在这个世界上除了你以外最亲最爱的人了，同样，我也会像对待我自己的父母兄弟姐妹一样对待你的父母兄弟姐妹。也只有这样，我们的小家庭才会永远的幸福美满。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;现在，我想说一句：我会努力的去做一个合格的丈夫，以后我们有了孩子以后，我还会变成一个合格的父亲！</p><h1 id="致我未来的娃："><a href="#致我未来的娃：" class="headerlink" title="致我未来的娃："></a>致我未来的娃：</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;现在我还不知道你这熊孩子是男孩是女，不过不管你是男还是女，我都会爱你的。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;如果你是男孩，在你没有上学之前，我不会要求你去背什么唐诗宋词，学什么乱七八糟的数学英语什么的，我会给你一个美好的童年。在你上学之后，我也不需要你考试每次都能考到第一第二名的，因为谁也不能保证每次考试都能考好。原则上的事情我会对你很严格的，但是我不会动手K你的，打你只能会让你变得更加叛逆。还有，在你18岁之后，请自己为你自己的路做决定，你老爹我只会给你建议。在你18岁之前，老爸我都是你的避风港，18岁之后，你要负责和我一起保护你老妈，一直到我老了，你就要保护我和你老妈了。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;如果你是女孩，我会一直一直把你当成我的小公主，我会给你买最漂亮的衣服，吃最好的，用最好的。考试成绩神马的，老爸都不会要求你的，只需要你给我平平安安的。还有18岁之前不要谈恋爱，18岁之后谈恋爱了，必须要把那家伙给我带回来看看，老爸要是不同意看不上，你就赶紧的让他拜拜。我对你的他的要求就是：能够保护你，要对你百分之一百的好。我在想，在你出嫁的那天，我一定会哭的，因为有个男人把你从我身边抢走了。</p><h1 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;好了，写到这里了，连媳妇都没有的人，在这胡思乱想。唉，洗洗睡吧。</p><p>PS：</p><ol><li>媳妇已经出现了，马上就要一起步入爱情的坟墓了！</li><li>努力造娃ing</li></ol>]]></content>
      
      
      <categories>
          
          <category> 个人感悟 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于maven的几个常用插件</title>
      <link href="/2013/11/18/hou-duan/maven-plugins/"/>
      <url>/2013/11/18/hou-duan/maven-plugins/</url>
      
        <content type="html"><![CDATA[<blockquote><p>最近整理了自己写的一个项目,使用maven+svn管理,idea开发,搭建了一个maven的私服.原来是凌乱不堪,所以费了好大劲才整理好,而且平时公司项目上事情多的一米…</p></blockquote><p>下面说说使用的几个插件(至于那些dependency就让它们见鬼去吧)</p><p>不说废话了,代码贴上</p><ol><li><p>clean插件</p><pre><code> &lt;plugin&gt;     &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;     &lt;artifactId&gt;maven-clean-plugin&lt;/artifactId&gt;     &lt;version&gt;2.5&lt;/version&gt;     &lt;configuration&gt;         &lt;filesets&gt;             &lt;fileset&gt;                 &lt;directory&gt;F:/logs&lt;/directory&gt;             &lt;/fileset&gt;             &lt;fileset&gt;                 &lt;directory&gt;../message-test&lt;/directory&gt;                 &lt;includes&gt;                     &lt;include&gt;spy.log&lt;/include&gt;                 &lt;/includes&gt;             &lt;/fileset&gt;             &lt;fileset&gt;                 &lt;directory&gt;../message-test/target&lt;/directory&gt;             &lt;/fileset&gt;         &lt;/filesets&gt;     &lt;/configuration&gt; &lt;/plugin&gt;</code></pre><p> 这个插件没啥好说的,要是不需要删除别的地方代码,就用默认的,不用任何配置</p></li><li><p>单元测试插件</p><pre><code> &lt;plugin&gt;     &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;     &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;     &lt;version&gt;2.16&lt;/version&gt;     &lt;configuration&gt;         &lt;skip&gt;true&lt;/skip&gt;     &lt;/configuration&gt; &lt;/plugin&gt;</code></pre><p> 单元测试没做好,一测就报错,干脆给skip了</p></li><li><p>resources</p><pre><code> &lt;plugin&gt;     &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;     &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt;     &lt;version&gt;2.6&lt;/version&gt;     &lt;executions&gt;         &lt;execution&gt;             &lt;id&gt;copy-resources&lt;/id&gt;             &lt;!-- here the phase you need --&gt;             &lt;phase&gt;validate&lt;/phase&gt;             &lt;goals&gt;                 &lt;goal&gt;copy-resources&lt;/goal&gt;             &lt;/goals&gt;             &lt;configuration&gt;                 &lt;outputDirectory&gt;${basedir}/target/test-classes&lt;/outputDirectory&gt;                 &lt;resources&gt;                     &lt;resource&gt;                         &lt;directory&gt;${basedir}/src/main/webapp/WEB-INF/config&lt;/directory&gt;                         &lt;filtering&gt;true&lt;/filtering&gt;                     &lt;/resource&gt;                 &lt;/resources&gt;             &lt;/configuration&gt;         &lt;/execution&gt;     &lt;/executions&gt; &lt;/plugin&gt;</code></pre><p> 用来复制一些资源文件,配置都是直译的</p></li><li><p>war</p><pre><code> &lt;plugin&gt;     &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;     &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt;     &lt;version&gt;2.4&lt;/version&gt;     &lt;configuration&gt;         &lt;warName&gt;${message.war.name}&lt;/warName&gt;         &lt;includeEmptyDirectories&gt;true&lt;/includeEmptyDirectories&gt;         &lt;webResources&gt;             &lt;resource&gt;                 &lt;directory&gt;../message-easyjs&lt;/directory&gt;                 &lt;targetPath&gt;js&lt;/targetPath&gt;                 &lt;excludes&gt;                     &lt;exclude&gt;**/.svn&lt;/exclude&gt;                     &lt;exclude&gt;**/*.iml&lt;/exclude&gt;                     &lt;exclude&gt;**/pom.xml&lt;/exclude&gt;                 &lt;/excludes&gt;             &lt;/resource&gt;         &lt;/webResources&gt;     &lt;/configuration&gt; &lt;/plugin&gt;</code></pre><p> 打war包的插件</p></li><li><p>jetty</p><pre><code> &lt;plugin&gt;     &lt;groupId&gt;org.mortbay.jetty&lt;/groupId&gt;     &lt;artifactId&gt;maven-jetty-plugin&lt;/artifactId&gt;     &lt;version&gt;6.1.10&lt;/version&gt;     &lt;configuration&gt;         &lt;!-- 配置扫描时间 --&gt;         &lt;scanIntervalSeconds&gt;10&lt;/scanIntervalSeconds&gt;         &lt;!-- 配置项目在容器中的根路径 --&gt;         &lt;contextPath&gt;${project.contextPath}&lt;/contextPath&gt;         &lt;!-- 配置jetty容器中的jndi --&gt;         &lt;jettyEnvXml&gt;src/main/resources/jetty.xml&lt;/jettyEnvXml&gt;         &lt;connectors&gt;             &lt;connector implementation=&quot;org.mortbay.jetty.nio.SelectChannelConnector&quot;&gt;                 &lt;!-- 端口 --&gt;                 &lt;port&gt;${project.port}&lt;/port&gt;                 &lt;maxIdleTime&gt;60000&lt;/maxIdleTime&gt;             &lt;/connector&gt;         &lt;/connectors&gt;         &lt;!-- 按照官网上说的是配置停止容器的快捷键和端口,至今不知怎么在idea中如何使用,有知道的麻烦告知下,3Q --&gt;         &lt;stopKey&gt;foo&lt;/stopKey&gt;         &lt;stopPort&gt;8888&lt;/stopPort&gt;     &lt;/configuration&gt;     &lt;executions&gt;         &lt;!-- 配置在maven哪个生命周期执行插件的哪个动作 --&gt;         &lt;execution&gt;             &lt;id&gt;jetty_run&lt;/id&gt;             &lt;!-- maven生命周期 --&gt;             &lt;phase&gt;compile&lt;/phase&gt;             &lt;!-- 执行插件的哪个动作 --&gt;             &lt;goals&gt;&lt;goal&gt;run&lt;/goal&gt;&lt;/goals&gt;         &lt;/execution&gt;     &lt;/executions&gt;     &lt;dependencies&gt;         &lt;!-- 这个插件依赖的几个包 --&gt;         &lt;dependency&gt;             &lt;groupId&gt;org.eclipse.jetty&lt;/groupId&gt;             &lt;artifactId&gt;jetty-io&lt;/artifactId&gt;             &lt;version&gt;7.6.6.v20120903&lt;/version&gt;         &lt;/dependency&gt;         &lt;dependency&gt;             &lt;groupId&gt;org.eclipse.jetty&lt;/groupId&gt;             &lt;artifactId&gt;jetty-server&lt;/artifactId&gt;             &lt;version&gt;7.6.6.v20120903&lt;/version&gt;         &lt;/dependency&gt;     &lt;/dependencies&gt; &lt;/plugin&gt;</code></pre><p> jetty这个插件当时可是整的我头疼,各种报错各种上网找资料,附上jetty的配置文件:jetty.xml</p><pre><code> &lt;?xml version=&quot;1.0&quot;?&gt; &lt;!DOCTYPE Configure PUBLIC &quot;-//Mort Bay Consulting//DTD Configure//EN&quot; &quot;http://jetty.mortbay.org/configure.dtd&quot;&gt; &lt;Configure class=&quot;org.mortbay.jetty.webapp.WebAppContext&quot;&gt;     &lt;New id=&quot;mysql&quot; class=&quot;org.mortbay.jetty.plus.naming.Resource&quot;&gt;         &lt;Arg&gt;jdbc/core&lt;/Arg&gt;         &lt;Arg&gt;             &lt;New class=&quot;com.mysql.jdbc.jdbc2.optional.MysqlConnectionPoolDataSource&quot;&gt;                 &lt;Set name=&quot;Url&quot;&gt;jdbc:mysql://localhost:3306/message&lt;/Set&gt;                 &lt;Set name=&quot;User&quot;&gt;root&lt;/Set&gt;                 &lt;Set name=&quot;Password&quot;&gt;123456&lt;/Set&gt;             &lt;/New&gt;         &lt;/Arg&gt;     &lt;/New&gt; &lt;/Configure&gt;</code></pre></li><li><p>cargo(可以启动tomcat,远程部署,本地部署,都支持的,这里我只用到本地部署,远程部署需要配置tomcat-user.xml和tomcat的控制台)</p><pre><code> &lt;plugin&gt;     &lt;groupId&gt;org.codehaus.cargo&lt;/groupId&gt;     &lt;artifactId&gt;cargo-maven2-plugin&lt;/artifactId&gt;     &lt;version&gt;1.4.3&lt;/version&gt;     &lt;configuration&gt;         &lt;container&gt;             &lt;!-- tomcat的版本,tomcat6使用tomcat6x --&gt;             &lt;containerId&gt;${cargo.tomcat.version}&lt;/containerId&gt;             &lt;!-- tomcat在本地的绝对路径 --&gt;             &lt;home&gt;${tomcat.home}&lt;/home&gt;             &lt;!-- 本地安装就用installed,远程使用remote --&gt;             &lt;type&gt;installed&lt;/type&gt;             &lt;!-- tomcat日志文件路径 --&gt;             &lt;output&gt;${tomcat.home}/logs/container.log&lt;/output&gt;             &lt;append&gt;false&lt;/append&gt;             &lt;log&gt;${tomcat.home}/logs/cargo.log&lt;/log&gt;         &lt;/container&gt;         &lt;configuration&gt;             &lt;!-- 本地部署,已存在 --&gt;             &lt;type&gt;existing&lt;/type&gt;             &lt;!-- 再配置一次tomcat绝对路径 --&gt;             &lt;home&gt;${tomcat.home}&lt;/home&gt;             &lt;properties&gt;                 &lt;!-- 端口 --&gt;                 &lt;cargo.servlet.port&gt;${project.port}&lt;/cargo.servlet.port&gt;             &lt;/properties&gt;         &lt;/configuration&gt;         &lt;!-- 这里一次可以部署多个项目 --&gt;         &lt;deployables&gt;             &lt;!-- 指定我部署的项目GAV --&gt;             &lt;deployable&gt;                 &lt;groupId&gt;com.message&lt;/groupId&gt;                 &lt;artifactId&gt;message-test&lt;/artifactId&gt;                 &lt;!-- war包形式部署 --&gt;                 &lt;type&gt;war&lt;/type&gt;                 &lt;properties&gt;                     &lt;!-- 容器中的上下文根 --&gt;                     &lt;context&gt;${project.contextPath}&lt;/context&gt;                 &lt;/properties&gt;             &lt;/deployable&gt;         &lt;/deployables&gt;     &lt;/configuration&gt;     &lt;!-- 同jetty --&gt;     &lt;executions&gt;         &lt;execution&gt;             &lt;id&gt;tomcat-run&lt;/id&gt;             &lt;phase&gt;package&lt;/phase&gt;             &lt;goals&gt;&lt;goal&gt;run&lt;/goal&gt;&lt;/goals&gt;         &lt;/execution&gt;     &lt;/executions&gt; &lt;/plugin&gt;</code></pre><ul><li>tomcat使用cargo这个插件有个缺点,不能debug了,而且不是热部署,不知道cargo有没有热部署的功能,暂时我还没找到,待研究 </li><li>jetty那个是可以热部署的,不管改Java类还是jsp或者css,js都可以(加减方法,改参数不行)</li></ul></li><li><p>附上maven的properties</p><pre><code> &lt;properties&gt;     &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;     &lt;junit.version&gt;4.10&lt;/junit.version&gt;     &lt;spring.version&gt;3.0.5.RELEASE&lt;/spring.version&gt;     &lt;jdk.version&gt;jdk15&lt;/jdk.version&gt;     &lt;tomcat.version&gt;6.0.32&lt;/tomcat.version&gt;     &lt;message.war.name&gt;message&lt;/message.war.name&gt;     &lt;project.port&gt;8099&lt;/project.port&gt;     &lt;project.contextPath&gt;/core&lt;/project.contextPath&gt;     &lt;tomcat.home&gt;F:\study\apache-tomcat-6.0.32&lt;/tomcat.home&gt;     &lt;cargo.tomcat.version&gt;tomcat6x&lt;/cargo.tomcat.version&gt; &lt;/properties&gt;   </code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于p6spy的介绍</title>
      <link href="/2013/07/11/hou-duan/p6spy/"/>
      <url>/2013/07/11/hou-duan/p6spy/</url>
      
        <content type="html"><![CDATA[<p>最近公司项目里需要使用到将所有执行的sql打出日志，放在一个文件下。公司一大神级人物给解决了，刚刚花了点时间给研究了一下。</p><p>他用的就是p6spy，其实也没做多少工作。主要的工作p6spy都已经做过了。</p><p>p6spy我的理解就是：p6spy将应用的数据源给劫持了，应用操作数据库其实在调用p6spy的数据源，p6spy劫持到需要执行的sql或者hql之类的语句之后，他自己去调用一个realDatasource，再去操作数据库，只要劫持到那些sql之后，能干的事情就很多了。</p><p>p6spy 可以输出日志到文件中、控制台、或者传递给 Log4j，而且还能配搭 SQL Profiler 或 IronTrackSQL 图形化监控 SQL 语句，监测到哪些语句的执行是耗时的，逐个优化。关于与 SQL Profiler 或 IronTrackSQL 的配合使用可参数文件的链接。 </p><p>p6spy在sourceforge上下载：[p6spy][]<br>[p6spy]: <a href="http://sourceforge.net/projects/p6spy/?source=dlp" target="_blank" rel="noopener">http://sourceforge.net/projects/p6spy/?source=dlp</a></p><p>p6spy的配置：</p><ol><li><p>p6spy.jar放入应用的classpath下</p></li><li><p>修改连接池或者连接配置的jdbc的驱动为p6spy所提供的驱动，<code>com.p6spy.engine.spy.P6SpyDriver</code></p><p> 在单独的Hibernate的应用中，数据库驱动配置在hibernate.cfg.xml里面,所以我需要配置文件中的connection.driver_class属性从oracle.jdbc.driver.OracleDriver改为com.p6spy.engine.spy.P6SpyDriver其他的用户名密码等等配置信息全部不用修改.在web程序中，配置的连接池部分，也只需要修改jdbc-driver的配置即可。</p><p> Hibernate.cfg.xml:</p><pre><code> &lt;session-factory&gt;     &lt;!-- 在这里改成p6spy提供的数据源 --&gt;     &lt;property name=&quot;connection.driver_class&quot;&gt;com.p6spy.engine.spy.P6SpyDriver&lt;/property&gt;            &lt;property name=&quot;connection.url&quot;&gt;jdbc:oracle:thin:@localhost:1521:orcl&lt;/property&gt;     &lt;property name=&quot;connection.username&quot;&gt;scott&lt;/property&gt;     &lt;property name=&quot;connection.password&quot;&gt;tiger&lt;/property&gt;     &lt;property name=&quot;connection.pool_size&quot;&gt;1&lt;/property&gt;     &lt;property name=&quot;dialect&quot;&gt;org.hibernate.dialect.Oracle9Dialect&lt;/property&gt;     &lt;property name=&quot;current_session_context_class&quot;&gt;thread&lt;/property&gt;     &lt;property name=&quot;cache.provider_class&quot;&gt;org.hibernate.cache.NoCacheProvider&lt;/property&gt;     &lt;property name=&quot;show_sql&quot;&gt;true&lt;/property&gt;     &lt;property name=&quot;hbm2ddl.auto&quot;&gt;false&lt;/property&gt;     &lt;property name=&quot;hibernate.jdbc.batch_size&quot;&gt;0&lt;/property&gt; &lt;/session-factory&gt;</code></pre></li><li><p>修改 <code>spy.properties</code> 并将其放到classpath下：</p><pre><code> ################################################################# # MODULES                                                       # #                                                               # # Modules provide the P6Spy functionality.  If a module, such   # # as module_log is commented out, that functionality will not   # # be available.  If it is not commented out (if it is active),  # # the functionality will be active.                             # #                                                               # # Values set in Modules cannot be reloaded using the            # # reloadproperties variable.  Once they are loaded, they remain # # in memory until the application is restarted.                 # #                                                               # ################################################################# #第一：module.log的属性必须配置，如果不配置，P6SPY将不起任何作用，典型配置： module.log=com.p6spy.engine.logging.P6LogFactory #module.outage=com.p6spy.engine.outage.P6OutageFactory ################################################################# # REALDRIVER(s)                                                 # #                                                               # # In your application server configuration file you replace the # # &quot;real driver&quot; name with com.p6spy.engine.P6SpyDriver. This is # # where you put the name of your real driver P6Spy can find and # # register your real driver to do the database work.            # #                                                               # # If your application uses several drivers specify them in      # # realdriver2, realdriver3.  See the documentation for more     # # details.                                                      # #                                                               # # Values set in REALDRIVER(s) cannot be reloaded using the      # # reloadproperties variable.  Once they are loaded, they remain # # in memory until the application is restarted.                 # #                                                               # ################################################################# #第二：数据库驱动配置，你懂的，不多说了 # oracle driver # realdriver=oracle.jdbc.driver.OracleDriver # mysql Connector/J driver # realdriver=com.mysql.jdbc.Driver # informix driver # realdriver=com.informix.jdbc.IfxDriver # ibm db2 driver # realdriver=COM.ibm.db2.jdbc.net.DB2Driver # the mysql open source driver realdriver=org.gjt.mm.mysql.Driver #specifies another driver to use realdriver2= #specifies a third driver to use realdriver3= #第三：appender配置，一般分为三种 #specifies the appender to use for logging #appender=com.p6spy.engine.logging.appender.Log4jLogger #控制台 #appender=com.p6spy.engine.logging.appender.StdoutLogger appender=com.p6spy.engine.logging.appender.FileLogger # name of logfile to use, note Windows users should make sure to use forward slashes in their pathname (e:/test/spy.log) (used for file logger only) #日志文件存放路径及文件名 logfile     = spy.log # append to  the p6spy log file.  if this is set to false the # log file is truncated every time.  (file logger only) append=true #The following are for log4j logging only log4j.appender.STDOUT=org.apache.log4j.ConsoleAppender log4j.appender.STDOUT.layout=org.apache.log4j.PatternLayout log4j.appender.STDOUT.layout.ConversionPattern=p6spy - %m%n log4j.logger.p6spy=INFO,STDOUT</code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> p6spy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用history.back(-1)的问题</title>
      <link href="/2013/06/05/qian-duan/history/"/>
      <url>/2013/06/05/qian-duan/history/</url>
      
        <content type="html"><![CDATA[<blockquote><p>今天在调一个项目现场的问题，觉得有点记录下来的意义。</p></blockquote><p>首先看看重现问题的步骤：</p><ol><li><p>选择一个事物分类进行查询，搜到一条记录，然后进入申请页面。</p><p> <img src="/imgs/history/1.png" alt=""></p></li><li><p>进入申请页面之后点返回，页面立即没有了（只在IE下会出现问题）而且页面上显示的是webpage has expired!页面已经过期。</p><p> ps:返回按钮触发的事件是：<code>window.history.back(-1);</code></p><p> <img src="/imgs/history/2.jpg" alt=""></p></li><li><p>解决办法：</p><p> 页面过期，我在想了是不是页面上的meta设置no-cache了，即：</p><pre><code> &lt;meta http-equiv=&quot;Pragma&quot; content=&quot;no-cache&quot;/&gt;</code></pre><p> 然后我立即查看页面源代码，发现木有这个东西。我就纳闷了，那是怎么了呢。</p><p> 后来一想是不是我查询的时候提交了一个表单，这时候已经跳到我查询的目标页面(虽然还是同一个jsp页面)，这时候用history.back(-1)已经找不到参数了，所以会报页面找不到的问题。</p><p> 然后想到form表单里面的method=”post”和method=”get”的区别（具体的网上搜索去吧）。</p><p> so, 我把搜索的form中method改成get。</p></li></ol><p>然后就OK了，问题解决了。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> frontend </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>个人简历</title>
      <link href="/1900/01/01/ge-ren-jian-li/"/>
      <url>/1900/01/01/ge-ren-jian-li/</url>
      
        <content type="html"><![CDATA[<style>    div.img-item {        display: inherit;    }    br {        display: none;    }</style><h1 id="联系方式"><a href="#联系方式" class="headerlink" title="联系方式"></a>联系方式</h1><ul><li>手机：18014480006</li><li>Email：<a href="mailto:sunhao0550@163.com">sunhao0550@163.com</a></li><li>微信：同手机号</li></ul><hr><h1 id="个人信息"><a href="#个人信息" class="headerlink" title="个人信息"></a>个人信息</h1><ul><li>孙昊/男/1990-03-18 </li><li>工作年限：7年半</li><li>本科/安徽理工大学信息与计算科学</li><li>技术博客：<a href="https://www.crazy-coder.cn">https://www.crazy-coder.cn</a> </li><li>荣誉奖励：2011年实习期间获得优秀实习生</li><li>Github：<a href="https://github.com/sunhao-java" target="_blank" rel="noopener">https://github.com/sunhao-java </a></li><li>Gitee：<a href="https://gitee.com/crazy-coder" target="_blank" rel="noopener">https://gitee.com/crazy-coder</a></li><li>期望职位：Java资深开发工程师、架构师</li><li>期望城市：南京</li></ul><hr><h1 id="工作经历"><a href="#工作经历" class="headerlink" title="工作经历"></a>工作经历</h1><h2 id="南京叶子科技有限公司"><a href="#南京叶子科技有限公司" class="headerlink" title="南京叶子科技有限公司"></a>南京叶子科技有限公司</h2><h3 id="职位、在职时间"><a href="#职位、在职时间" class="headerlink" title="职位、在职时间"></a>职位、在职时间</h3><p>架构师、2018-08~至今</p><h3 id="工作内容"><a href="#工作内容" class="headerlink" title="工作内容"></a>工作内容</h3><p>南京叶子科技有限公司，是OPPO公司的全资子公司，负责oppo销售领域的数字化构建工作。</p><ol><li>带领团队完成公司PaaS层的构建（控制台、流程中心、网关中心、任务调度中心、集成中心）</li><li>协助运维完成公司devops流程的构建</li><li>构建公司底层工具类组件（公司内部广泛使用）</li><li>公司使用的技术选型</li><li>疑难问题解答、协助</li><li>负责一些简单的大数据相关（入门，刚接触）</li></ol><h2 id="中兴软创科技股份有限公司"><a href="#中兴软创科技股份有限公司" class="headerlink" title="中兴软创科技股份有限公司"></a>中兴软创科技股份有限公司</h2><h3 id="职位、在职时间-1"><a href="#职位、在职时间-1" class="headerlink" title="职位、在职时间"></a>职位、在职时间</h3><p>架构师、2015-04~2018-08</p><h3 id="工作内容-1"><a href="#工作内容-1" class="headerlink" title="工作内容"></a>工作内容</h3><p>中兴软创 政企部门 智慧城市 底层架构开发 （中间有段时间离职去创业的，时间：2015-08～2016-01）</p><h3 id="离职原因"><a href="#离职原因" class="headerlink" title="离职原因"></a>离职原因</h3><p>第一次离职时因为和朋友一起出去创业</p><h2 id="南京橘子星球网络科技有限公司"><a href="#南京橘子星球网络科技有限公司" class="headerlink" title="南京橘子星球网络科技有限公司"></a>南京橘子星球网络科技有限公司</h2><h3 id="职位、在职时间-2"><a href="#职位、在职时间-2" class="headerlink" title="职位、在职时间"></a>职位、在职时间</h3><p>架构师、2015-08~2016-01</p><h3 id="工作内容-2"><a href="#工作内容-2" class="headerlink" title="工作内容"></a>工作内容</h3><p>负责公司技术上的架构，技术选型，技术培训等</p><h3 id="离职原因-1"><a href="#离职原因-1" class="headerlink" title="离职原因"></a>离职原因</h3><p>公司融资失败，趋于破产</p><h2 id="联创车盟汽车服务有限公司"><a href="#联创车盟汽车服务有限公司" class="headerlink" title="联创车盟汽车服务有限公司"></a>联创车盟汽车服务有限公司</h2><h3 id="职位、在职时间-3"><a href="#职位、在职时间-3" class="headerlink" title="职位、在职时间"></a>职位、在职时间</h3><p>高级java开发工程师、2014-07~2015-04</p><h3 id="工作内容-3"><a href="#工作内容-3" class="headerlink" title="工作内容"></a>工作内容</h3><p>联创车盟（AA China）2004年7月成立于北京，隶属于联创科技集团，是国内处于领先地位的全国汽车服务网络提供商。<br>主要负责开发慧驾平台的结算系统，以及产品技术支撑。合作完成系统架构，研究新技术</p><h3 id="离职原因-2"><a href="#离职原因-2" class="headerlink" title="离职原因"></a>离职原因</h3><p>公司欠薪，领导鼓励离职</p><h2 id="江苏金智教育信息技术有限公司"><a href="#江苏金智教育信息技术有限公司" class="headerlink" title="江苏金智教育信息技术有限公司"></a>江苏金智教育信息技术有限公司</h2><h3 id="职位、在职时间-4"><a href="#职位、在职时间-4" class="headerlink" title="职位、在职时间"></a>职位、在职时间</h3><p>高级java开发工程师、2011-07~2014-07</p><h3 id="工作内容-4"><a href="#工作内容-4" class="headerlink" title="工作内容"></a>工作内容</h3><p>主要做同一通信平台和关于工作流方面的项目，面向全国本专科学校<br>自定义表单的协助开发<br>以及内容管理系统(CMS)的开发，主要负责内容模型的开发。2011.7-2012.7  实习一年，并且获得优秀实习生。</p><h3 id="离职原因-3"><a href="#离职原因-3" class="headerlink" title="离职原因"></a>离职原因</h3><p>寻求新的发展、突破自我</p><hr><h1 id="开源项目和技术文章"><a href="#开源项目和技术文章" class="headerlink" title="开源项目和技术文章"></a>开源项目和技术文章</h1><h2 id="开源项目"><a href="#开源项目" class="headerlink" title="开源项目"></a>开源项目</h2><ul><li><p><a href="https://github.com/lodsve/lodsve-framework" target="_blank" rel="noopener">lodsve-framework</a> ：Let our development of Spring very easy! </p>  <div class="github-widget" data-repo="lodsve/lodsve-framework"></div></li><li><p><a href="https://github.com/lodsve/lodsve-maven-archetype" target="_blank" rel="noopener">lodsve-maven-archetype</a> ：Maven archetypes to create a project with lodsve-framework!</p>  <div class="github-widget" data-repo="lodsve/lodsve-maven-archetype"></div></li><li><p><a href="https://github.com/lodsve/lodsve-maven-plugins" target="_blank" rel="noopener">lodsve-maven-plugins</a> ：maven plugins for lodsve</p>  <div class="github-widget" data-repo="lodsve/lodsve-maven-plugins"></div></li></ul><hr><h1 id="自我描述"><a href="#自我描述" class="headerlink" title="自我描述"></a>自我描述</h1><p>以下均为我熟练使用的技能</p><ul><li>熟练使用Eclipse/IDEA等IDE </li><li>熟练使用Tomcat/Websphere/JBoss[wildfly]等Web服务器 </li><li>熟练使用Struts2/Hibernate/Spring/Titles等开源框架;擅长Spring+Hibernate开发,曾在Spring/Hibernate的基础上重新开发一套框架;熟悉J2EE体系架构，对MVC三层架构有着较为深入的理解；了解Android开发,对iBatis/EJB3.0有一定了解. </li><li>熟悉spring restful </li><li>熟练使用Linux服务器，熟练使用一些Linux常用命令,对项目部署有一定经验 </li><li>熟练使用Oracle、MySQL数据库.常用Oracle、mysql，了解SQL Server </li><li>了解、并且使用nosql数据库，如mongodb。可随时深入研究 </li><li>对redis、memcached等也有过研究 </li><li>熟练使用maven、gradle等构建工具 </li><li>了解并研究过一些其他语言，如：javascript、python、groovy、php、nodejs、scala等 </li><li>对持续集成有过研究，搭建过jenkins+maven+gitlab一套开发工具 </li><li>了解并熟悉整个互联网开发体系及架构，如分布式服务调度框架dubbo，消息队列rabbitmq等等 </li><li>有着较强的团队合作能力、较强的自学能力,对新的知识充满渴望</li></ul><hr><h1 id="END"><a href="#END" class="headerlink" title="END"></a>END</h1><p>感谢您花时间阅读我的简历，期待能有机会和您共事。</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
